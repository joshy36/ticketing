"use strict";exports.id=2295,exports.ids=[2295],exports.modules={42295:(e,t,r)=>{r.d(t,{w:()=>fetchRequestHandler});var n=r(26739),o=r(10249),s=r(60289),a=r(23326);let deserializeInputValue=(e,t)=>void 0!==e?t.input.deserialize(e):e,i={GET:"query",POST:"mutation"},u={getInputs:e=>{let t=function(e){let{req:t}=e;try{if("GET"===t.method){if(!t.query.has("input"))return;let e=t.query.get("input");return JSON.parse(e)}if(!e.preprocessedBody&&"string"==typeof t.body)return 0===t.body.length?void 0:JSON.parse(t.body);return t.body}catch(e){throw new s.T({code:"PARSE_ERROR",cause:e})}}(e),r=e.router._def._config.transformer;if(!e.isBatchCall)return{0:deserializeInputValue(t,r)};if(null==t||"object"!=typeof t||Array.isArray(t))throw new s.T({code:"BAD_REQUEST",message:'"input" needs to be an object when doing a batch call'});let n={};for(let e in t){let o=t[e],s=deserializeInputValue(o,r);n[e]=s}return n}};function initResponse(e){let{ctx:t,paths:r,type:o,responseMeta:s,untransformedJSON:a,errors:i=[]}=e,u=a?(0,n.b)(a):200,c={"Content-Type":"application/json"},d=!a,p=d?[]:Array.isArray(a)?a:[a],l=s?.({ctx:t,paths:r,type:o,data:p,errors:i,eagerGeneration:d})??{};for(let[e,t]of Object.entries(l.headers??{}))c[e]=t;return l.status&&(u=l.status),{status:u,headers:c}}async function inputToProcedureCall(e){let{opts:t,ctx:r,type:n,input:i,path:u}=e;try{let e=await (0,o.b)({procedures:t.router._def.procedures,path:u,rawInput:i,ctx:r,type:n});return{result:{data:e}}}catch(o){let e=(0,s.g)(o);return t.onError?.({error:e,path:u,input:i,ctx:r,type:n,req:t.req}),{error:(0,a.g)({config:t.router._def._config,error:e,type:n,path:u,input:i,ctx:r})}}}function caughtErrorToData(e,t){let{router:r,req:n,onError:o}=t.opts,i=(0,s.g)(e);o?.({error:i,path:t.path,input:t.input,ctx:t.ctx,type:t.type,req:n});let u={error:(0,a.g)({config:r._def._config,error:i,type:t.type,path:t.path,input:t.input,ctx:t.ctx})},c=(0,a.t)(r._def._config,u),d=JSON.stringify(c);return{error:i,untransformedJSON:u,body:d}}async function resolveHTTPResponse(e){let t,r;let{router:n,req:o,unstable_onHead:c,unstable_onChunk:d}=e;if("HEAD"===o.method){let e={status:204};return c?.(e,!1),d?.([-1,""]),e}let p=e.contentTypeHandler??u,l=e.batching?.enabled??!0,f=i[o.method]??"unknown",h=!!o.query.get("batch"),y=h&&c&&d&&"stream"===o.headers["trpc-batch-mode"];try{if(r=await e.createContext(),e.error)throw e.error;if(h&&!l)throw Error("Batching is not enabled on the server");/* istanbul ignore if -- @preserve */if("subscription"===f)throw new s.T({message:"Subscriptions should use wsLink",code:"METHOD_NOT_SUPPORTED"});if("unknown"===f)throw new s.T({message:`Unexpected request method ${o.method}`,code:"METHOD_NOT_SUPPORTED"});let i=await p.getInputs({isBatchCall:h,req:o,router:n,preprocessedBody:e.preprocessedBody??!1});t=h?decodeURIComponent(e.path).split(","):[e.path];let u=t.map((t,n)=>inputToProcedureCall({opts:e,ctx:r,type:f,input:i[n],path:t}));if(!y){let o=await Promise.all(u),s=o.flatMap(e=>"error"in e?[e.error]:[]),i=initResponse({ctx:r,paths:t,type:f,responseMeta:e.responseMeta,untransformedJSON:o,errors:s});c?.(i,!1);let p=h?o:o[0],l=(0,a.t)(n._def._config,p),y=JSON.stringify(l);return d?.([-1,y]),{status:i.status,headers:i.headers,body:y}}let g=initResponse({ctx:r,paths:t,type:f,responseMeta:e.responseMeta});c(g,!0);let m=new Map(u.map((e,t)=>[t,e.then(e=>[t,e])]));for(let o of t){let[o,s]=await Promise.race(m.values());m.delete(o);try{let e=(0,a.t)(n._def._config,s),t=JSON.stringify(e);d([o,t])}catch(u){let n=t[o],s=i[o],{body:a}=caughtErrorToData(u,{opts:e,ctx:r,type:f,path:n,input:s});d([o,a])}}return}catch(i){let{error:n,untransformedJSON:o,body:s}=caughtErrorToData(i,{opts:e,ctx:r,type:f}),a=initResponse({ctx:r,paths:t,type:f,responseMeta:e.responseMeta,untransformedJSON:o,errors:[n]});return c?.(a,!1),d?.([-1,s]),{status:a.status,headers:a.headers,body:s}}}async function fetchRequestHandler(e){let t,r,n,o;let s=new Headers,createContext=async()=>e.createContext?.({req:e.req,resHeaders:s}),a=new URL(e.req.url),i=a.pathname.slice(e.endpoint.length+1),u={query:a.searchParams,method:e.req.method,headers:Object.fromEntries(e.req.headers),body:e.req.headers.get("content-type")?.startsWith("application/json")?await e.req.text():""},c=new Promise(e=>t=e),d=200,p=!1;return resolveHTTPResponse({req:u,createContext,path:i,router:e.router,batching:e.batching,responseMeta:e.responseMeta,onError(t){e?.onError?.({...t,req:e.req})},unstable_onHead:(e,a)=>{for(let[t,r]of Object.entries(e.headers??{}))/* istanbul ignore if -- @preserve */if(void 0!==r){if("string"==typeof r){s.set(t,r);continue}for(let e of r)s.append(t,e)}if(d=e.status,a){s.set("Transfer-Encoding","chunked"),s.append("Vary","trpc-batch-mode");let e=new ReadableStream({start(e){r=e}}),a=new Response(e,{status:d,headers:s});t(a),n=new TextEncoder,o=function(){let e=!0;function format(t,r){let n=e?"{":",";return e=!1,`${n}"${t}":${r}
`}return format.end=()=>"}",format}(),p=!0}},unstable_onChunk:([e,a])=>{if(-1===e){let e=new Response(a||null,{status:d,headers:s});t(e)}else r.enqueue(n.encode(o(e,a)))}}).then(()=>{p&&(r.enqueue(n.encode(o.end())),r.close())}).catch(()=>{p&&r.close()}),c}r(58610)}};