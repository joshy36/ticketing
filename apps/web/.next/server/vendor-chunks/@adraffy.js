"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@adraffy";
exports.ids = ["vendor-chunks/@adraffy"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload(\"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\");\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload(\"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\");\n// https://unicode.org/reports/tr15/\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n            x,\n            i + 1 << 24\n        ]))); // pre-shifted\nconst EXCLUSIONS = new Set(read_sorted(r));\nconst DECOMP = new Map();\nconst RECOMP = new Map();\nfor (let [cp, cps] of read_mapped(r)){\n    if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n        let [a, b] = cps;\n        let bucket = RECOMP.get(a);\n        if (!bucket) {\n            bucket = new Map();\n            RECOMP.set(a, bucket);\n        }\n        bucket.set(b, cp);\n    }\n    DECOMP.set(cp, cps.reverse()); // stored reversed\n}\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\n//const t0 = performance.now();\nconst STOP = 0x2E;\nconst FE0F = 0xFE0F;\nconst STOP_CH = \".\";\nconst UNIQUE_PH = 1;\nconst HYPHEN = 0x2D;\nfunction read_set() {\n    return new Set(read_sorted(r$1));\n}\nconst MAPPED = new Map(read_mapped(r$1));\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/ // 20230217: we still need all CM for proper error formatting\n// but norm only needs NSM subset that are potentially-valid\nconst CM = read_set();\nconst NSM = new Set(read_sorted(r$1).map(function(i) {\n    return this[i];\n}, [\n    ...CM\n]));\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/ const ESCAPE = read_set(); // characters that should not be printed\nconst NFC_CHECK = read_set();\nconst CHUNKS = read_sorted_arrays(r$1);\nfunction read_chunked() {\n    // deduplicated sets + uniques\n    return new Set([\n        read_sorted(r$1).map((i)=>CHUNKS[i]),\n        read_sorted(r$1)\n    ].flat(2));\n}\nconst UNRESTRICTED = r$1();\nconst GROUPS = read_array_while((i)=>{\n    // minifier property mangling seems unsafe\n    // so these are manually renamed to single chars\n    let N = read_array_while(r$1).map((x)=>x + 0x60);\n    if (N.length) {\n        let R = i >= UNRESTRICTED; // first arent restricted\n        N[0] -= 32; // capitalize\n        N = str_from_cps(N);\n        if (R) N = `Restricted[${N}]`;\n        let P = read_chunked(); // primary\n        let Q = read_chunked(); // secondary\n        let V = [\n            ...P,\n            ...Q\n        ].sort((a, b)=>a - b); // derive: sorted valid\n        //let M = r()-1; // combining mark\n        let M = !r$1(); // not-whitelisted, check for NSM\n        // code currently isn't needed\n        /*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/ return {\n            N,\n            P,\n            M,\n            R,\n            V: new Set(V)\n        };\n    }\n});\nconst WHOLE_VALID = read_set();\nconst WHOLE_MAP = new Map();\n// decode compressed wholes\n[\n    ...WHOLE_VALID,\n    ...read_set()\n].sort((a, b)=>a - b).map((cp, i, v)=>{\n    let d = r$1();\n    let w = v[i] = d ? v[i - d] : {\n        V: [],\n        M: new Map()\n    };\n    w.V.push(cp); // add to member set\n    if (!WHOLE_VALID.has(cp)) {\n        WHOLE_MAP.set(cp, w); // register with whole map\n    }\n});\n// compute confusable-extent complements\nfor (let { V, M } of new Set(WHOLE_MAP.values())){\n    // connect all groups that have each whole character\n    let recs = [];\n    for (let cp of V){\n        let gs = GROUPS.filter((g)=>g.V.has(cp));\n        let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));\n        if (!rec) {\n            rec = {\n                G: new Set(),\n                V: []\n            };\n            recs.push(rec);\n        }\n        rec.V.push(cp);\n        gs.forEach((g)=>rec.G.add(g));\n    }\n    // per character cache groups which are not a member of the extent\n    let union = recs.flatMap(({ G })=>[\n            ...G\n        ]);\n    for (let { G, V } of recs){\n        let complement = new Set(union.filter((g)=>!G.has(g)));\n        for (let cp of V){\n            M.set(cp, complement);\n        }\n    }\n}\nlet union = new Set(); // exists in 1+ groups\nlet multi = new Set(); // exists in 2+ groups\nfor (let g of GROUPS){\n    for (let cp of g.V){\n        (union.has(cp) ? multi : union).add(cp);\n    }\n}\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\nfor (let cp of union){\n    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n        WHOLE_MAP.set(cp, UNIQUE_PH);\n    }\n}\nconst VALID = new Set([\n    ...union,\n    ...nfd(union)\n]); // possibly valid\n// decode emoji\nconst EMOJI_SORTED = read_sorted(r$1); // temporary\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\nconst EMOJI_ROOT = read_emoji_trie([]);\nfunction read_emoji_trie(cps) {\n    let B = read_array_while(()=>{\n        let keys = read_sorted(r$1).map((i)=>EMOJI_SORTED[i]);\n        if (keys.length) return read_emoji_trie(keys);\n    }).sort((a, b)=>b.Q.size - a.Q.size); // sort by likelihood\n    let temp = r$1();\n    let V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\n    temp = temp / 3 | 0;\n    let F = temp & 1; // allow FE0F\n    temp >>= 1;\n    let S = temp & 1; // save\n    let C = temp & 2; // check\n    return {\n        B,\n        V,\n        F,\n        S,\n        C,\n        Q: new Set(cps)\n    };\n}\n//console.log(performance.now() - t0);\n// free tagging system\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"◌\");\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([\n        cp\n    ]))} `) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error(\"invalid label extension\");\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(`leading ${prev}`);\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(`${prev} + ${match}`);\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(`trailing ${prev}`);\n}\n// note: set(s) cannot be exposed because they can be modified\nfunction is_combining_mark(cp) {\n    return CM.has(cp);\n}\nfunction should_escape(cp) {\n    return ESCAPE.has(cp);\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(process(explode_cp(label), nf).flatMap((x)=>x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(ens_split(name));\n}\nfunction ens_beautify(name) {\n    let split = ens_split(name, true);\n    // this is experimental\n    for (let { type, output, error } of split){\n        if (error) continue;\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        // ξ => Ξ if not greek\n        if (type !== \"Greek\") {\n            let prev = 0;\n            while(true){\n                let next = output.indexOf(0x3BE, prev);\n                if (next < 0) break;\n                output[next] = 0x39E;\n                prev = next + 1;\n            }\n        }\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(split);\n}\nfunction ens_split(name, preserve_emoji) {\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        let norm;\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                throw new Error(`empty label`);\n            } else {\n                let chars = tokens[0];\n                let emoji = token_count > 1 || chars.is_emoji;\n                if (!emoji && chars.every((cp)=>cp < 0x80)) {\n                    norm = chars;\n                    check_leading_underscore(norm);\n                    // only needed for ascii\n                    // 20230123: matches matches WHATWG, see note 3.3\n                    check_label_extension(norm);\n                    // cant have fenced\n                    // cant have cm\n                    // cant have wholes\n                    // see derive: \"Fastpath ASCII\"\n                    type = \"ASCII\";\n                } else {\n                    if (emoji) {\n                        info.emoji = true;\n                        chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                    }\n                    norm = tokens.flatMap((x)=>!preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\n                    check_leading_underscore(norm);\n                    if (!chars.length) {\n                        type = \"Emoji\";\n                    } else {\n                        // 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                        if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                        for(let i = 1; i < token_count; i++){\n                            let cps = tokens[i];\n                            if (!cps.is_emoji && CM.has(cps[0])) {\n                                // bidi_qq() not needed since emoji is LTR and cps is a CM\n                                throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([\n                                    cps[0]\n                                ])}\"`);\n                            }\n                        }\n                        check_fenced(norm);\n                        let unique = [\n                            ...new Set(chars)\n                        ];\n                        let [g] = determine_group(unique); // take the first match\n                        // see derive: \"Matching Groups have Same CM Style\"\n                        // alternative: could form a hybrid type: Latin/Japanese/...\t\n                        check_group(g, chars); // need text in order\n                        check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                        type = g.N;\n                    // 20230121: consider exposing restricted flag\n                    // it's simpler to just check for 'Restricted'\n                    // or even better: type.endsWith(']')\n                    //if (g.R) info.restricted = true;\n                    }\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        info.output = norm;\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = []; // TODO: can this be avoided?\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : [\n                ...set\n            ];\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaning groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>g.V.has(cp))) {\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>g.V.has(cp));\n        if (!gs.length) {\n            if (groups === GROUPS) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map(({ input, error, output })=>{\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp));\n    if (gg) {\n        quoted = `${gg.N} ${quoted}`;\n    }\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n    return new Error(`illegal placement: ${where}`);\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    let { V, M } = g;\n    for (let cp of cps){\n        if (!V.has(cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\nfunction process(input, nf) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(emoji);\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps);\n                } else if (!IGNORED.has(cp)) {\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// allows optional FE0F\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten) eaten.length = 0; // clear input buffer (if needed)\n    while(pos){\n        let cp = cps[--pos];\n        node = node.B.find((x)=>x.Q.has(cp));\n        if (!node) break;\n        if (node.S) {\n            saved = cp;\n        } else if (node.C) {\n            if (cp === saved) break;\n        }\n        stack.push(cp);\n        if (node.F) {\n            stack.push(FE0F);\n            if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\n        }\n        if (node.V) {\n            emoji = conform_emoji_copy(stack, node);\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    /*\r\n\t// *** this code currently isn't needed ***\r\n\tif (!emoji) {\r\n\t\tlet cp = cps[cps.length-1];\r\n\t\tif (EMOJI_SOLO.has(cp)) {\r\n\t\t\tif (eaten) eaten.push(cp);\r\n\t\t\temoji = Emoji.of(cp);\r\n\t\t\tcps.pop();\r\n\t\t}\r\n\t}\r\n\t*/ return emoji;\n}\n// create a copy and fix any unicode quirks\nfunction conform_emoji_copy(cps, node) {\n    let copy = Emoji.from(cps); // copy stack\n    if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\n    return copy;\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    // *** this code currently isn't needed ***\n    //let ret = [...EMOJI_SOLO].map(x => [x]);\n    let ret = [];\n    build(EMOJI_ROOT, []);\n    return ret.sort(compare_arrays);\n    function build(node, cps, saved) {\n        if (node.S) {\n            saved = cps[cps.length - 1];\n        } else if (node.C) {\n            if (saved === cps[cps.length - 1]) return;\n        }\n        if (node.F) cps.push(FE0F);\n        if (node.V) ret.push(conform_emoji_copy(cps, node));\n        for (let br of node.B){\n            for (let cp of br.Q){\n                build(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name, { nf = true } = {}) {\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji,\n                input: eaten.slice(),\n                cps: filter_fe0f(emoji)\n            });\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxrQkFBa0JDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTTtJQUNWLFNBQVNDO1FBQVEsT0FBTyxLQUFNLENBQUNELE1BQU0sSUFBSSxJQUFLRCxLQUFLLENBQUNDLE1BQU07SUFBRTtJQUU1RCw2QkFBNkI7SUFDN0IsSUFBSUUsZUFBZUQ7SUFDbkIsSUFBSUUsUUFBUTtJQUNaLElBQUlDLE1BQU07UUFBQztRQUFHO0tBQUUsRUFBRSwrQkFBK0I7SUFDakQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILGNBQWNHLElBQUs7UUFDdENELElBQUlFLElBQUksQ0FBQ0gsU0FBU0Y7SUFDbkI7SUFFQSw0REFBNEQ7SUFDNUQsSUFBSU0sT0FBT047SUFDWCxJQUFJTyxjQUFjUjtJQUNsQkEsT0FBT087SUFFUCxJQUFJRSxhQUFhO0lBQ2pCLElBQUlDLGNBQWM7SUFDbEIsU0FBU0M7UUFDUixJQUFJRixjQUFjLEdBQUc7WUFDcEIsc0NBQXNDO1lBQ3RDLGdDQUFnQztZQUNoQ0MsY0FBYyxlQUFnQixJQUFLWCxLQUFLLENBQUNDLE1BQU07WUFDL0NTLGFBQWE7UUFDZDtRQUNBLE9BQU8sZUFBZ0IsRUFBRUEsYUFBYztJQUN4QztJQUVBLE1BQU1HLElBQUk7SUFDVixNQUFNQyxPQUFPLEtBQUdEO0lBQ2hCLE1BQU1FLE9BQU9ELFNBQVM7SUFDdEIsTUFBTUUsT0FBT0QsUUFBUTtJQUNyQixNQUFNRSxPQUFPSCxPQUFPO0lBRXBCLGdCQUFnQjtJQUNoQixJQUFJSSxXQUFXO0lBQ2YsSUFBSyxJQUFJWixJQUFJLEdBQUdBLElBQUlPLEdBQUdQLElBQUtZLFdBQVcsWUFBYSxJQUFLTjtJQUV6RCxJQUFJTyxVQUFVLEVBQUU7SUFDaEIsSUFBSUMsTUFBTTtJQUNWLElBQUlDLFFBQVFQLE1BQU0scUJBQXFCO0lBQ3ZDLE1BQU8sS0FBTTtRQUNaLElBQUlRLFFBQVFDLEtBQUtDLEtBQUssQ0FBQyxDQUFDLENBQUVOLFdBQVdFLE1BQU0sS0FBS2hCLFFBQVMsS0FBS2lCO1FBQzlELElBQUlJLFFBQVE7UUFDWixJQUFJQyxNQUFNdkI7UUFDVixNQUFPdUIsTUFBTUQsUUFBUSxFQUFHO1lBQ3ZCLElBQUlFLE1BQU0sUUFBU0QsUUFBUztZQUM1QixJQUFJSixRQUFRakIsR0FBRyxDQUFDc0IsSUFBSSxFQUFFO2dCQUNyQkQsTUFBTUM7WUFDUCxPQUFPO2dCQUNORixRQUFRRTtZQUNUO1FBQ0Q7UUFDQSxJQUFJRixTQUFTLEdBQUcsT0FBTywyQkFBMkI7UUFDbEROLFFBQVFaLElBQUksQ0FBQ2tCO1FBQ2IsSUFBSUcsSUFBSVIsTUFBTUcsS0FBS0MsS0FBSyxDQUFDSCxRQUFRaEIsR0FBRyxDQUFDb0IsTUFBTSxHQUFLckI7UUFDaEQsSUFBSXlCLElBQUlULE1BQU1HLEtBQUtDLEtBQUssQ0FBQ0gsUUFBUWhCLEdBQUcsQ0FBQ29CLFFBQU0sRUFBRSxHQUFHckIsU0FBUztRQUN6RCxNQUFPLENBQUMsQ0FBQ3dCLElBQUlDLENBQUFBLElBQUtkLElBQUcsS0FBTSxFQUFHO1lBQzdCRyxXQUFXLFlBQWEsSUFBS0QsT0FBT0w7WUFDcENnQixJQUFJLEtBQU0sSUFBS1g7WUFDZlksSUFBSSxLQUFNLElBQUtaLE9BQU87UUFDdkI7UUFDQSxNQUFPVyxJQUFJLENBQUNDLElBQUliLEtBQU07WUFDckJFLFdBQVcsV0FBWUgsT0FBUyxZQUFhLElBQU1FLFNBQVMsSUFBTUw7WUFDbEVnQixJQUFJLEtBQU0sSUFBS2I7WUFDZmMsSUFBSSxDQUFFQSxJQUFJZCxJQUFHLEtBQU0sSUFBS0EsT0FBTztRQUNoQztRQUNBSyxNQUFNUTtRQUNOUCxRQUFRLElBQUlRLElBQUlEO0lBQ2pCO0lBQ0EsSUFBSUUsU0FBUzNCLGVBQWU7SUFDNUIsT0FBT2dCLFFBQVFZLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDbEIsT0FBUUEsSUFBSUY7WUFDWCxLQUFLO2dCQUFHLE9BQU9BLFNBQVMsVUFBVyxNQUFNLENBQUNyQixjQUFjLElBQUksS0FBT1QsS0FBSyxDQUFDUyxjQUFjLElBQUksSUFBS1QsS0FBSyxDQUFDUyxjQUFjO1lBQ3BILEtBQUs7Z0JBQUcsT0FBT3FCLFNBQVMsUUFBUyxNQUFNLENBQUNyQixjQUFjLElBQUksSUFBS1QsS0FBSyxDQUFDUyxjQUFjO1lBQ25GLEtBQUs7Z0JBQUcsT0FBT3FCLFNBQVM5QixLQUFLLENBQUNTLGNBQWM7WUFDNUM7Z0JBQVMsT0FBT3VCLElBQUk7UUFDckI7SUFDRDtBQUNEO0FBRUEsb0RBQW9EO0FBQ3BELFNBQVNDLGFBQWFDLENBQUM7SUFDdEIsSUFBSWpDLE1BQU07SUFDVixPQUFPLElBQU1pQyxDQUFDLENBQUNqQyxNQUFNO0FBQ3RCO0FBQ0EsU0FBU2tDLHdCQUF3QkMsQ0FBQztJQUNqQyxPQUFPSCxhQUFhbEMsa0JBQWtCc0MsWUFBWUQ7QUFDbkQ7QUFFQSx1QkFBdUI7QUFDdkIsMkNBQTJDO0FBQzNDLFNBQVNDLFlBQVlELENBQUM7SUFDckIsSUFBSUUsU0FBUyxFQUFFO0lBQ2Y7V0FBSTtLQUFtRSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsR0FBR2xDLElBQU1nQyxNQUFNLENBQUNFLEVBQUVDLFVBQVUsQ0FBQyxHQUFHLEdBQUduQztJQUNwSCxJQUFJb0MsSUFBSU4sRUFBRU8sTUFBTTtJQUNoQixJQUFJQyxNQUFNLElBQUlDLFdBQVcsSUFBS0gsS0FBTTtJQUNwQyxJQUFLLElBQUlwQyxJQUFJLEdBQUdMLE1BQU0sR0FBRzZDLFFBQVEsR0FBR0MsUUFBUSxHQUFHekMsSUFBSW9DLEdBQUdwQyxJQUFLO1FBQzFEeUMsUUFBUSxTQUFVLElBQUtULE1BQU0sQ0FBQ0YsRUFBRUssVUFBVSxDQUFDbkMsR0FBRztRQUM5Q3dDLFNBQVM7UUFDVCxJQUFJQSxTQUFTLEdBQUc7WUFDZkYsR0FBRyxDQUFDM0MsTUFBTSxHQUFJOEMsU0FBVUQsQ0FBQUEsU0FBUztRQUNsQztJQUNEO0lBQ0EsT0FBT0Y7QUFDUjtBQUVBLHNDQUFzQztBQUN0QyxTQUFTSSxPQUFPMUMsQ0FBQztJQUNoQixPQUFPLElBQUssSUFBTSxDQUFDQSxLQUFLLElBQU1BLEtBQUs7QUFDcEM7QUFFQSxTQUFTMkMsWUFBWVAsQ0FBQyxFQUFFUSxJQUFJO0lBQzNCLElBQUloQixJQUFJaUIsTUFBTVQ7SUFDZCxJQUFLLElBQUlwQyxJQUFJLEdBQUcwQixJQUFJLEdBQUcxQixJQUFJb0MsR0FBR3BDLElBQUs0QixDQUFDLENBQUM1QixFQUFFLEdBQUcwQixLQUFLZ0IsT0FBT0U7SUFDdEQsT0FBT2hCO0FBQ1I7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBU2tCLFlBQVlGLElBQUksRUFBRUcsT0FBTyxDQUFDO0lBQ2xDLElBQUlULE1BQU0sRUFBRTtJQUNaLE1BQU8sS0FBTTtRQUNaLElBQUlaLElBQUlrQjtRQUNSLElBQUlSLElBQUlRO1FBQ1IsSUFBSSxDQUFDUixHQUFHO1FBQ1JXLFFBQVFyQjtRQUNSLElBQUssSUFBSTFCLElBQUksR0FBR0EsSUFBSW9DLEdBQUdwQyxJQUFLO1lBQzNCc0MsSUFBSXJDLElBQUksQ0FBQzhDLE9BQU8vQztRQUNqQjtRQUNBK0MsUUFBUVgsSUFBSTtJQUNiO0lBQ0EsT0FBT0U7QUFDUjtBQUVBLFNBQVNVLG1CQUFtQkosSUFBSTtJQUMvQixPQUFPSyxpQkFBaUI7UUFDdkIsSUFBSXJCLElBQUlrQixZQUFZRjtRQUNwQixJQUFJaEIsRUFBRVMsTUFBTSxFQUFFLE9BQU9UO0lBQ3RCO0FBQ0Q7QUFFQSx5QkFBeUI7QUFDekIsU0FBU3NCLFlBQVlOLElBQUk7SUFDeEIsSUFBSU4sTUFBTSxFQUFFO0lBQ1osTUFBTyxLQUFNO1FBQ1osSUFBSWEsSUFBSVA7UUFDUixJQUFJTyxLQUFLLEdBQUc7UUFDWmIsSUFBSXJDLElBQUksQ0FBQ21ELGtCQUFrQkQsR0FBR1A7SUFDL0I7SUFDQSxNQUFPLEtBQU07UUFDWixJQUFJTyxJQUFJUCxTQUFTO1FBQ2pCLElBQUlPLElBQUksR0FBRztRQUNYYixJQUFJckMsSUFBSSxDQUFDb0QsdUJBQXVCRixHQUFHUDtJQUNwQztJQUNBLE9BQU9OLElBQUlnQixJQUFJO0FBQ2hCO0FBRUEsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QixTQUFTTCxpQkFBaUJMLElBQUk7SUFDN0IsSUFBSWhCLElBQUksRUFBRTtJQUNWLE1BQU8sS0FBTTtRQUNaLElBQUlGLElBQUlrQixLQUFLaEIsRUFBRVMsTUFBTTtRQUNyQixJQUFJLENBQUNYLEdBQUc7UUFDUkUsRUFBRTNCLElBQUksQ0FBQ3lCO0lBQ1I7SUFDQSxPQUFPRTtBQUNSO0FBRUEsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixTQUFTMkIsZ0JBQWdCbkIsQ0FBQyxFQUFFZSxDQUFDLEVBQUVQLElBQUk7SUFDbEMsSUFBSVksSUFBSVgsTUFBTVQsR0FBR3FCLElBQUksR0FBR2hDLEdBQUcsQ0FBQyxJQUFNLEVBQUU7SUFDcEMsSUFBSyxJQUFJekIsSUFBSSxHQUFHQSxJQUFJbUQsR0FBR25ELElBQUs7UUFDM0IyQyxZQUFZUCxHQUFHUSxNQUFNWCxPQUFPLENBQUMsQ0FBQ1AsR0FBR2dDLElBQU1GLENBQUMsQ0FBQ0UsRUFBRSxDQUFDekQsSUFBSSxDQUFDeUI7SUFDbEQ7SUFDQSxPQUFPOEI7QUFDUjtBQUVBLDJEQUEyRDtBQUMzRCxxREFBcUQ7QUFDckQsU0FBU0osa0JBQWtCRCxDQUFDLEVBQUVQLElBQUk7SUFDakMsSUFBSWUsS0FBSyxJQUFJZjtJQUNiLElBQUlnQixLQUFLaEI7SUFDVCxJQUFJaUIsS0FBS1osaUJBQWlCTDtJQUMxQixJQUFJWSxJQUFJRCxnQkFBZ0JNLEdBQUd4QixNQUFNLEVBQUUsSUFBRWMsR0FBR1A7SUFDeEMsT0FBT1ksRUFBRU0sT0FBTyxDQUFDLENBQUNsQyxHQUFHNUI7UUFDcEIsSUFBSSxDQUFDMEIsR0FBRyxHQUFHcUMsR0FBRyxHQUFHbkM7UUFDakIsT0FBT2lCLE1BQU1nQixFQUFFLENBQUM3RCxFQUFFLEVBQUV5RCxJQUFJLEdBQUdoQyxHQUFHLENBQUMsQ0FBQ3VDLEdBQUdOO1lBQ2xDLElBQUlPLE9BQU9QLElBQUlFO1lBQ2YsT0FBTztnQkFBQ2xDLElBQUlnQyxJQUFJQztnQkFBSUksR0FBR3RDLEdBQUcsQ0FBQ3lDLENBQUFBLElBQUtBLElBQUlEO2FBQU07UUFDM0M7SUFDRDtBQUNEO0FBRUEsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixTQUFTWix1QkFBdUJGLENBQUMsRUFBRVAsSUFBSTtJQUN0QyxJQUFJUixJQUFJLElBQUlRO0lBQ1osSUFBSVksSUFBSUQsZ0JBQWdCbkIsR0FBRyxJQUFFZSxHQUFHUDtJQUNoQyxPQUFPWSxFQUFFL0IsR0FBRyxDQUFDRyxDQUFBQSxJQUFLO1lBQUNBLENBQUMsQ0FBQyxFQUFFO1lBQUVBLEVBQUV1QyxLQUFLLENBQUM7U0FBRztBQUNyQztBQUVBLG1DQUFtQztBQUNuQyxJQUFJQyxNQUFNdkMsd0JBQXdCO0FBQ2xDLE1BQU13QyxTQUFTLElBQUlDLElBQUk7SUFBQztRQUFDO1FBQUs7S0FBYTtJQUFDO1FBQUM7UUFBSztLQUFpQjtJQUFDO1FBQUM7UUFBTTtLQUFhO0NBQUM7QUFDekYsTUFBTUMsVUFBVTtBQUVoQixTQUFTQyxPQUFPQyxFQUFFO0lBQ2pCLE9BQU9BLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO0FBQ2xEO0FBRUEsU0FBU0MsU0FBU0osRUFBRTtJQUNuQixPQUFPLENBQUMsQ0FBQyxFQUFFRCxPQUFPQyxJQUFJLENBQUMsQ0FBQyxFQUFFLDhDQUE4QztBQUN6RTtBQUVBOzs7O0FBSUEsR0FDQSxTQUFTSyxXQUFXaEQsQ0FBQztJQUNwQixJQUFJaUQsTUFBTSxFQUFFO0lBQ1osSUFBSyxJQUFJcEYsTUFBTSxHQUFHcUYsTUFBTWxELEVBQUVPLE1BQU0sRUFBRTFDLE1BQU1xRixLQUFPO1FBQzlDLElBQUlQLEtBQUszQyxFQUFFbUQsV0FBVyxDQUFDdEY7UUFDdkJBLE9BQU84RSxLQUFLLFVBQVUsSUFBSTtRQUMxQk0sSUFBSTlFLElBQUksQ0FBQ3dFO0lBQ1Y7SUFDQSxPQUFPTTtBQUNSO0FBRUEsU0FBU0csYUFBYUgsR0FBRztJQUN4QixNQUFNSSxRQUFRO0lBQ2QsSUFBSUgsTUFBTUQsSUFBSTFDLE1BQU07SUFDcEIsSUFBSTJDLE1BQU1HLE9BQU8sT0FBT0MsT0FBT0MsYUFBYSxJQUFJTjtJQUNoRCxJQUFJTyxNQUFNLEVBQUU7SUFDWixJQUFLLElBQUl0RixJQUFJLEdBQUdBLElBQUlnRixLQUFPO1FBQzFCTSxJQUFJckYsSUFBSSxDQUFDbUYsT0FBT0MsYUFBYSxJQUFJTixJQUFJWixLQUFLLENBQUNuRSxHQUFHQSxLQUFLbUY7SUFDcEQ7SUFDQSxPQUFPRyxJQUFJQyxJQUFJLENBQUM7QUFDakI7QUFFQSxTQUFTQyxlQUFlbEUsQ0FBQyxFQUFFQyxDQUFDO0lBQzNCLElBQUlhLElBQUlkLEVBQUVlLE1BQU07SUFDaEIsSUFBSUgsSUFBSUUsSUFBSWIsRUFBRWMsTUFBTTtJQUNwQixJQUFLLElBQUlyQyxJQUFJLEdBQUdrQyxLQUFLLEtBQUtsQyxJQUFJb0MsR0FBR3BDLElBQUtrQyxJQUFJWixDQUFDLENBQUN0QixFQUFFLEdBQUd1QixDQUFDLENBQUN2QixFQUFFO0lBQ3JELE9BQU9rQztBQUNSO0FBRUEsbUNBQW1DO0FBQ25DLElBQUl1RCxJQUFJNUQsd0JBQXdCO0FBRWhDLG9DQUFvQztBQUVwQyxTQUFTNkQsVUFBVUMsTUFBTTtJQUN4QixPQUFPLFVBQVcsS0FBTTtBQUN6QjtBQUNBLFNBQVNDLFVBQVVELE1BQU07SUFDeEIsT0FBT0EsU0FBUztBQUNqQjtBQUVBLE1BQU1FLGVBQWUsSUFBSXZCLElBQUl0QixtQkFBbUJ5QyxHQUFHM0IsT0FBTyxDQUFDLENBQUNsQyxHQUFHNUIsSUFBTTRCLEVBQUVILEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSztZQUFDQTtZQUFJMUIsSUFBRSxLQUFNO1NBQUcsS0FBSyxjQUFjO0FBQ25ILE1BQU04RixhQUFhLElBQUlDLElBQUlqRCxZQUFZMkM7QUFDdkMsTUFBTU8sU0FBUyxJQUFJMUI7QUFDbkIsTUFBTTJCLFNBQVMsSUFBSTNCO0FBQ25CLEtBQUssSUFBSSxDQUFDRyxJQUFJTSxJQUFJLElBQUk3QixZQUFZdUMsR0FBSTtJQUNyQyxJQUFJLENBQUNLLFdBQVdJLEdBQUcsQ0FBQ3pCLE9BQU9NLElBQUkxQyxNQUFNLElBQUksR0FBRztRQUMzQyxJQUFJLENBQUNmLEdBQUdDLEVBQUUsR0FBR3dEO1FBQ2IsSUFBSW9CLFNBQVNGLE9BQU9HLEdBQUcsQ0FBQzlFO1FBQ3hCLElBQUksQ0FBQzZFLFFBQVE7WUFDWkEsU0FBUyxJQUFJN0I7WUFDYjJCLE9BQU9JLEdBQUcsQ0FBQy9FLEdBQUc2RTtRQUNmO1FBQ0FBLE9BQU9FLEdBQUcsQ0FBQzlFLEdBQUdrRDtJQUNmO0lBQ0F1QixPQUFPSyxHQUFHLENBQUM1QixJQUFJTSxJQUFJdUIsT0FBTyxLQUFLLGtCQUFrQjtBQUNsRDtBQUVBLHFCQUFxQjtBQUNyQixxRUFBcUU7QUFDckUsTUFBTUMsS0FBSztBQUNYLE1BQU1DLEtBQUs7QUFDWCxNQUFNQyxLQUFLO0FBQ1gsTUFBTUMsS0FBSztBQUNYLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFVBQVVGLFVBQVVDO0FBQzFCLE1BQU1FLFVBQVVKLFVBQVVHO0FBQzFCLE1BQU1FLEtBQUtULEtBQUtRO0FBQ2hCLE1BQU1FLEtBQUtULEtBQUtHO0FBQ2hCLE1BQU1PLEtBQUtULEtBQUtHO0FBQ2hCLE1BQU1PLEtBQUtULEtBQUtHO0FBRWhCLFNBQVNPLFVBQVUzQyxFQUFFO0lBQ3BCLE9BQU9BLE1BQU04QixNQUFNOUIsS0FBS3VDO0FBQ3pCO0FBRUEsU0FBU0ssYUFBYS9GLENBQUMsRUFBRUMsQ0FBQztJQUN6QixJQUFJRCxLQUFLa0YsTUFBTWxGLElBQUkyRixNQUFNMUYsS0FBS2tGLE1BQU1sRixJQUFJMkYsSUFBSTtRQUMzQyxPQUFPWCxLQUFLLENBQUNqRixJQUFJa0YsRUFBQyxJQUFLTSxVQUFVLENBQUN2RixJQUFJa0YsRUFBQyxJQUFLSTtJQUM3QyxPQUFPLElBQUlPLFVBQVU5RixNQUFNQyxJQUFJbUYsTUFBTW5GLElBQUk0RixNQUFNLENBQUM3RixJQUFJaUYsRUFBQyxJQUFLTSxXQUFXLEdBQUc7UUFDdkUsT0FBT3ZGLElBQUtDLENBQUFBLElBQUltRixFQUFDO0lBQ2xCLE9BQU87UUFDTixJQUFJWSxTQUFTckIsT0FBT0csR0FBRyxDQUFDOUU7UUFDeEIsSUFBSWdHLFFBQVE7WUFDWEEsU0FBU0EsT0FBT2xCLEdBQUcsQ0FBQzdFO1lBQ3BCLElBQUkrRixRQUFRO2dCQUNYLE9BQU9BO1lBQ1I7UUFDRDtRQUNBLE9BQU8sQ0FBQztJQUNUO0FBQ0Q7QUFFQSxTQUFTQyxXQUFXeEMsR0FBRztJQUN0QixJQUFJekMsTUFBTSxFQUFFO0lBQ1osSUFBSWdELE1BQU0sRUFBRTtJQUNaLElBQUlrQyxjQUFjO0lBQ2xCLFNBQVNDLElBQUloRCxFQUFFO1FBQ2QsSUFBSWlELEtBQUs3QixhQUFhTyxHQUFHLENBQUMzQjtRQUMxQixJQUFJaUQsSUFBSTtZQUNQRixjQUFjO1lBQ2QvQyxNQUFNaUQ7UUFDUDtRQUNBcEYsSUFBSXJDLElBQUksQ0FBQ3dFO0lBQ1Y7SUFDQSxLQUFLLElBQUlBLE1BQU1NLElBQUs7UUFDbkIsTUFBTyxLQUFNO1lBQ1osSUFBSU4sS0FBSyxNQUFNO2dCQUNkbkMsSUFBSXJDLElBQUksQ0FBQ3dFO1lBQ1YsT0FBTyxJQUFJMkMsVUFBVTNDLEtBQUs7Z0JBQ3pCLElBQUlrRCxVQUFVbEQsS0FBSzhCO2dCQUNuQixJQUFJcUIsVUFBVUQsVUFBVWIsVUFBVTtnQkFDbEMsSUFBSWUsVUFBVSxVQUFXZixVQUFXRCxVQUFVO2dCQUM5QyxJQUFJaUIsVUFBVUgsVUFBVWQ7Z0JBQ3hCWSxJQUFJakIsS0FBS29CO2dCQUNUSCxJQUFJaEIsS0FBS29CO2dCQUNULElBQUlDLFVBQVUsR0FBR0wsSUFBSWYsS0FBS29CO1lBQzNCLE9BQU87Z0JBQ04sSUFBSUMsU0FBUy9CLE9BQU9JLEdBQUcsQ0FBQzNCO2dCQUN4QixJQUFJc0QsUUFBUTtvQkFDWHpDLElBQUlyRixJQUFJLElBQUk4SDtnQkFDYixPQUFPO29CQUNOTixJQUFJaEQ7Z0JBQ0w7WUFDRDtZQUNBLElBQUksQ0FBQ2EsSUFBSWpELE1BQU0sRUFBRTtZQUNqQm9DLEtBQUthLElBQUkwQyxHQUFHO1FBQ2I7SUFDRDtJQUNBLElBQUlSLGVBQWVsRixJQUFJRCxNQUFNLEdBQUcsR0FBRztRQUNsQyxJQUFJNEYsVUFBVXZDLFVBQVVwRCxHQUFHLENBQUMsRUFBRTtRQUM5QixJQUFLLElBQUl0QyxJQUFJLEdBQUdBLElBQUlzQyxJQUFJRCxNQUFNLEVBQUVyQyxJQUFLO1lBQ3BDLElBQUkwSCxLQUFLaEMsVUFBVXBELEdBQUcsQ0FBQ3RDLEVBQUU7WUFDekIsSUFBSTBILE1BQU0sS0FBS08sV0FBV1AsSUFBSTtnQkFDN0JPLFVBQVVQO2dCQUNWO1lBQ0Q7WUFDQSxJQUFJaEUsSUFBSTFELElBQUU7WUFDVixNQUFPLEtBQU07Z0JBQ1osSUFBSWtJLE1BQU01RixHQUFHLENBQUNvQixJQUFFLEVBQUU7Z0JBQ2xCcEIsR0FBRyxDQUFDb0IsSUFBRSxFQUFFLEdBQUdwQixHQUFHLENBQUNvQixFQUFFO2dCQUNqQnBCLEdBQUcsQ0FBQ29CLEVBQUUsR0FBR3dFO2dCQUNULElBQUksQ0FBQ3hFLEdBQUc7Z0JBQ1J1RSxVQUFVdkMsVUFBVXBELEdBQUcsQ0FBQyxFQUFFb0IsRUFBRTtnQkFDNUIsSUFBSXVFLFdBQVdQLElBQUk7WUFDcEI7WUFDQU8sVUFBVXZDLFVBQVVwRCxHQUFHLENBQUN0QyxFQUFFO1FBQzNCO0lBQ0Q7SUFDQSxPQUFPc0M7QUFDUjtBQUVBLFNBQVM2Rix5QkFBeUJ2RyxDQUFDO0lBQ2xDLElBQUlVLE1BQU0sRUFBRTtJQUNaLElBQUk4RixRQUFRLEVBQUU7SUFDZCxJQUFJQyxVQUFVLENBQUM7SUFDZixJQUFJSixVQUFVO0lBQ2QsS0FBSyxJQUFJdEMsVUFBVS9ELEVBQUc7UUFDckIsSUFBSThGLEtBQUtoQyxVQUFVQztRQUNuQixJQUFJbEIsS0FBS21CLFVBQVVEO1FBQ25CLElBQUkwQyxXQUFXLENBQUMsR0FBRztZQUNsQixJQUFJWCxNQUFNLEdBQUc7Z0JBQ1pXLFVBQVU1RDtZQUNYLE9BQU87Z0JBQ05uQyxJQUFJckMsSUFBSSxDQUFDd0U7WUFDVjtRQUNELE9BQU8sSUFBSXdELFVBQVUsS0FBS0EsV0FBV1AsSUFBSTtZQUN4QyxJQUFJQSxNQUFNLEdBQUc7Z0JBQ1pwRixJQUFJckMsSUFBSSxDQUFDb0ksWUFBWUQ7Z0JBQ3JCQSxNQUFNL0YsTUFBTSxHQUFHO2dCQUNmZ0csVUFBVTVEO1lBQ1gsT0FBTztnQkFDTjJELE1BQU1uSSxJQUFJLENBQUN3RTtZQUNaO1lBQ0F3RCxVQUFVUDtRQUNYLE9BQU87WUFDTixJQUFJWSxXQUFXakIsYUFBYWdCLFNBQVM1RDtZQUNyQyxJQUFJNkQsWUFBWSxHQUFHO2dCQUNsQkQsVUFBVUM7WUFDWCxPQUFPLElBQUlMLFdBQVcsS0FBS1AsTUFBTSxHQUFHO2dCQUNuQ3BGLElBQUlyQyxJQUFJLENBQUNvSTtnQkFDVEEsVUFBVTVEO1lBQ1gsT0FBTztnQkFDTjJELE1BQU1uSSxJQUFJLENBQUN3RTtnQkFDWHdELFVBQVVQO1lBQ1g7UUFDRDtJQUNEO0lBQ0EsSUFBSVcsV0FBVyxHQUFHO1FBQ2pCL0YsSUFBSXJDLElBQUksQ0FBQ29JLFlBQVlEO0lBQ3RCO0lBQ0EsT0FBTzlGO0FBQ1I7QUFFQSw0QkFBNEI7QUFDNUIsU0FBU2lHLElBQUl4RCxHQUFHO0lBQ2YsT0FBT3dDLFdBQVd4QyxLQUFLdEQsR0FBRyxDQUFDbUU7QUFDNUI7QUFDQSxTQUFTNEMsSUFBSXpELEdBQUc7SUFDZixPQUFPb0QseUJBQXlCWixXQUFXeEM7QUFDNUM7QUFFQSwrQkFBK0I7QUFFL0IsTUFBTTBELE9BQU87QUFDYixNQUFNQyxPQUFPO0FBQ2IsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLFNBQVM7QUFFZixTQUFTQztJQUNSLE9BQU8sSUFBSS9DLElBQUlqRCxZQUFZc0I7QUFDNUI7QUFDQSxNQUFNMkUsU0FBUyxJQUFJekUsSUFBSXBCLFlBQVlrQjtBQUNuQyxNQUFNNEUsVUFBVUYsWUFBWSxnRUFBZ0U7QUFDNUY7Ozs7OztBQU1BLEdBQ0EsNkRBQTZEO0FBQzdELDREQUE0RDtBQUM1RCxNQUFNRyxLQUFLSDtBQUNYLE1BQU1JLE1BQU0sSUFBSW5ELElBQUlqRCxZQUFZc0IsS0FBSzNDLEdBQUcsQ0FBQyxTQUFTekIsQ0FBQztJQUFJLE9BQU8sSUFBSSxDQUFDQSxFQUFFO0FBQUUsR0FBRztPQUFJaUo7Q0FBRztBQUNqRjs7OztBQUlBLEdBQ0EsTUFBTUUsU0FBU0wsWUFBWSx3Q0FBd0M7QUFDbkUsTUFBTU0sWUFBWU47QUFDbEIsTUFBTU8sU0FBU3JHLG1CQUFtQm9CO0FBQ2xDLFNBQVNrRjtJQUNSLDhCQUE4QjtJQUM5QixPQUFPLElBQUl2RCxJQUFJO1FBQUNqRCxZQUFZc0IsS0FBSzNDLEdBQUcsQ0FBQ3pCLENBQUFBLElBQUtxSixNQUFNLENBQUNySixFQUFFO1FBQUc4QyxZQUFZc0I7S0FBSyxDQUFDZCxJQUFJLENBQUM7QUFDOUU7QUFDQSxNQUFNaUcsZUFBZW5GO0FBQ3JCLE1BQU1vRixTQUFTdkcsaUJBQWlCakQsQ0FBQUE7SUFDL0IsMENBQTBDO0lBQzFDLGdEQUFnRDtJQUNoRCxJQUFJTyxJQUFJMEMsaUJBQWlCbUIsS0FBSzNDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsSUFBRTtJQUN6QyxJQUFJbkIsRUFBRThCLE1BQU0sRUFBRTtRQUNiLElBQUlvSCxJQUFJekosS0FBS3VKLGNBQWMseUJBQXlCO1FBQ3BEaEosQ0FBQyxDQUFDLEVBQUUsSUFBSSxJQUFJLGFBQWE7UUFDekJBLElBQUkyRSxhQUFhM0U7UUFDakIsSUFBSWtKLEdBQUdsSixJQUFFLENBQUMsV0FBVyxFQUFFQSxFQUFFLENBQUMsQ0FBQztRQUMzQixJQUFJbUosSUFBSUosZ0JBQWdCLFVBQVU7UUFDbEMsSUFBSUssSUFBSUwsZ0JBQWdCLFlBQVk7UUFDcEMsSUFBSU0sSUFBSTtlQUFJRjtlQUFNQztTQUFFLENBQUNFLElBQUksQ0FBQyxDQUFDdkksR0FBR0MsSUFBTUQsSUFBRUMsSUFBSSx1QkFBdUI7UUFDakUsa0NBQWtDO1FBQ2xDLElBQUl1SSxJQUFJLENBQUMxRixPQUFPLGlDQUFpQztRQUNqRCw4QkFBOEI7UUFDOUI7Ozs7Ozs7O0dBUUMsR0FDRCxPQUFPO1lBQUM3RDtZQUFHbUo7WUFBR0k7WUFBR0w7WUFBR0csR0FBRyxJQUFJN0QsSUFBSTZEO1FBQUU7SUFDbEM7QUFDRDtBQUNBLE1BQU1HLGNBQWNqQjtBQUNwQixNQUFNa0IsWUFBWSxJQUFJMUY7QUFDdEIsMkJBQTJCO0FBQzNCO09BQUl5RjtPQUFnQmpCO0NBQVcsQ0FBQ2UsSUFBSSxDQUFDLENBQUN2SSxHQUFHQyxJQUFNRCxJQUFFQyxHQUFHRSxHQUFHLENBQUMsQ0FBQ2dELElBQUl6RSxHQUFHNEI7SUFDL0QsSUFBSXFJLElBQUk3RjtJQUNSLElBQUlqQixJQUFJdkIsQ0FBQyxDQUFDNUIsRUFBRSxHQUFHaUssSUFBSXJJLENBQUMsQ0FBQzVCLElBQUVpSyxFQUFFLEdBQUc7UUFBQ0wsR0FBRyxFQUFFO1FBQUVFLEdBQUcsSUFBSXhGO0lBQUs7SUFDaERuQixFQUFFeUcsQ0FBQyxDQUFDM0osSUFBSSxDQUFDd0UsS0FBSyxvQkFBb0I7SUFDbEMsSUFBSSxDQUFDc0YsWUFBWTdELEdBQUcsQ0FBQ3pCLEtBQUs7UUFDekJ1RixVQUFVM0QsR0FBRyxDQUFDNUIsSUFBSXRCLElBQUssMEJBQTBCO0lBQ2xEO0FBQ0Q7QUFDQSx3Q0FBd0M7QUFDeEMsS0FBSyxJQUFJLEVBQUN5RyxDQUFDLEVBQUVFLENBQUMsRUFBQyxJQUFJLElBQUkvRCxJQUFJaUUsVUFBVUUsTUFBTSxJQUFLO0lBQy9DLG9EQUFvRDtJQUNwRCxJQUFJQyxPQUFPLEVBQUU7SUFDYixLQUFLLElBQUkxRixNQUFNbUYsRUFBRztRQUNqQixJQUFJUSxLQUFLWixPQUFPYSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVWLENBQUMsQ0FBQzFELEdBQUcsQ0FBQ3pCO1FBQ3BDLElBQUk4RixNQUFNSixLQUFLSyxJQUFJLENBQUMsQ0FBQyxFQUFDQyxDQUFDLEVBQUMsR0FBS0wsR0FBR00sSUFBSSxDQUFDSixDQUFBQSxJQUFLRyxFQUFFdkUsR0FBRyxDQUFDb0U7UUFDaEQsSUFBSSxDQUFDQyxLQUFLO1lBQ1RBLE1BQU07Z0JBQUNFLEdBQUcsSUFBSTFFO2dCQUFPNkQsR0FBRyxFQUFFO1lBQUE7WUFDMUJPLEtBQUtsSyxJQUFJLENBQUNzSztRQUNYO1FBQ0FBLElBQUlYLENBQUMsQ0FBQzNKLElBQUksQ0FBQ3dFO1FBQ1gyRixHQUFHbkksT0FBTyxDQUFDcUksQ0FBQUEsSUFBS0MsSUFBSUUsQ0FBQyxDQUFDaEQsR0FBRyxDQUFDNkM7SUFDM0I7SUFDQSxrRUFBa0U7SUFDbEUsSUFBSUssUUFBUVIsS0FBS3JHLE9BQU8sQ0FBQyxDQUFDLEVBQUMyRyxDQUFDLEVBQUMsR0FBSztlQUFJQTtTQUFFO0lBQ3hDLEtBQUssSUFBSSxFQUFDQSxDQUFDLEVBQUViLENBQUMsRUFBQyxJQUFJTyxLQUFNO1FBQ3hCLElBQUlTLGFBQWEsSUFBSTdFLElBQUk0RSxNQUFNTixNQUFNLENBQUNDLENBQUFBLElBQUssQ0FBQ0csRUFBRXZFLEdBQUcsQ0FBQ29FO1FBQ2xELEtBQUssSUFBSTdGLE1BQU1tRixFQUFHO1lBQ2pCRSxFQUFFekQsR0FBRyxDQUFDNUIsSUFBSW1HO1FBQ1g7SUFDRDtBQUNEO0FBQ0EsSUFBSUQsUUFBUSxJQUFJNUUsT0FBTyxzQkFBc0I7QUFDN0MsSUFBSThFLFFBQVEsSUFBSTlFLE9BQU8sc0JBQXNCO0FBQzdDLEtBQUssSUFBSXVFLEtBQUtkLE9BQVE7SUFDckIsS0FBSyxJQUFJL0UsTUFBTTZGLEVBQUVWLENBQUMsQ0FBRTtRQUNsQmUsQ0FBQUEsTUFBTXpFLEdBQUcsQ0FBQ3pCLE1BQU1vRyxRQUFRRixLQUFJLEVBQUdsRCxHQUFHLENBQUNoRDtJQUNyQztBQUNEO0FBQ0Esc0VBQXNFO0FBQ3RFLEtBQUssSUFBSUEsTUFBTWtHLE1BQU87SUFDckIsSUFBSSxDQUFDWCxVQUFVOUQsR0FBRyxDQUFDekIsT0FBTyxDQUFDb0csTUFBTTNFLEdBQUcsQ0FBQ3pCLEtBQUs7UUFDekN1RixVQUFVM0QsR0FBRyxDQUFDNUIsSUFBSW1FO0lBQ25CO0FBQ0Q7QUFDQSxNQUFNa0MsUUFBUSxJQUFJL0UsSUFBSTtPQUFJNEU7T0FBVXBDLElBQUlvQztDQUFPLEdBQUcsaUJBQWlCO0FBRW5FLGVBQWU7QUFDZixNQUFNSSxlQUFlakksWUFBWXNCLE1BQU0sWUFBWTtBQUNuRCxxRkFBcUY7QUFDckYsTUFBTTRHLGFBQWFDLGdCQUFnQixFQUFFO0FBQ3JDLFNBQVNBLGdCQUFnQmxHLEdBQUc7SUFDM0IsSUFBSW1HLElBQUlqSSxpQkFBaUI7UUFDeEIsSUFBSWtJLE9BQU9ySSxZQUFZc0IsS0FBSzNDLEdBQUcsQ0FBQ3pCLENBQUFBLElBQUsrSyxZQUFZLENBQUMvSyxFQUFFO1FBQ3BELElBQUltTCxLQUFLOUksTUFBTSxFQUFFLE9BQU80SSxnQkFBZ0JFO0lBQ3pDLEdBQUd0QixJQUFJLENBQUMsQ0FBQ3ZJLEdBQUdDLElBQU1BLEVBQUVvSSxDQUFDLENBQUN5QixJQUFJLEdBQUc5SixFQUFFcUksQ0FBQyxDQUFDeUIsSUFBSSxHQUFHLHFCQUFxQjtJQUM3RCxJQUFJQyxPQUFPakg7SUFDWCxJQUFJd0YsSUFBSXlCLE9BQU8sR0FBRyx5Q0FBeUM7SUFDM0RBLE9BQU8sT0FBUSxJQUFHO0lBQ2xCLElBQUlDLElBQUlELE9BQU8sR0FBRyxhQUFhO0lBQy9CQSxTQUFTO0lBQ1QsSUFBSUUsSUFBSUYsT0FBTyxHQUFHLE9BQU87SUFDekIsSUFBSUcsSUFBSUgsT0FBTyxHQUFHLFFBQVE7SUFDMUIsT0FBTztRQUFDSDtRQUFHdEI7UUFBRzBCO1FBQUdDO1FBQUdDO1FBQUc3QixHQUFHLElBQUk1RCxJQUFJaEI7SUFBSTtBQUN2QztBQUNBLHNDQUFzQztBQUV0QyxzQkFBc0I7QUFDdEIsTUFBTTBHLGNBQWM1STtJQUNuQixJQUFJNkksV0FBVztRQUFFLE9BQU87SUFBTTtBQUMvQjtBQUVBLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLDZDQUE2QztBQUM3QywyRUFBMkU7QUFDM0UsU0FBU0Msa0JBQWtCNUcsR0FBRyxFQUFFNkcsU0FBUy9HLFFBQVE7SUFDaEQseUNBQXlDO0lBQ3pDLHNFQUFzRTtJQUN0RSxJQUFJUyxNQUFNLEVBQUU7SUFDWixJQUFJdUcsa0JBQWtCOUcsR0FBRyxDQUFDLEVBQUUsR0FBR08sSUFBSXJGLElBQUksQ0FBQztJQUN4QyxJQUFJOEMsT0FBTztJQUNYLElBQUlYLElBQUkyQyxJQUFJMUMsTUFBTTtJQUNsQixJQUFLLElBQUlyQyxJQUFJLEdBQUdBLElBQUlvQyxHQUFHcEMsSUFBSztRQUMzQixJQUFJeUUsS0FBS00sR0FBRyxDQUFDL0UsRUFBRTtRQUNmLElBQUk4TCxjQUFjckgsS0FBSztZQUN0QmEsSUFBSXJGLElBQUksQ0FBQ2lGLGFBQWFILElBQUlaLEtBQUssQ0FBQ3BCLE1BQU0vQztZQUN0Q3NGLElBQUlyRixJQUFJLENBQUMyTCxPQUFPbkg7WUFDaEIxQixPQUFPL0MsSUFBSTtRQUNaO0lBQ0Q7SUFDQXNGLElBQUlyRixJQUFJLENBQUNpRixhQUFhSCxJQUFJWixLQUFLLENBQUNwQixNQUFNWDtJQUN0QyxPQUFPa0QsSUFBSUMsSUFBSSxDQUFDO0FBQ2pCO0FBRUEsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QixTQUFTd0csVUFBVXRILEVBQUU7SUFDcEIsT0FBTyxDQUFDcUgsY0FBY3JILE1BQU0sS0FBSyxDQUFDLEVBQUV1SCxRQUFRTCxrQkFBa0I7UUFBQ2xIO0tBQUcsR0FBRyxDQUFDLENBQUMsSUFBSUksU0FBU0o7QUFDckY7QUFFQSwyRUFBMkU7QUFDM0UsMEVBQTBFO0FBQzFFLHNDQUFzQztBQUN0QyxpRkFBaUY7QUFDakYsU0FBU3VILFFBQVFsSyxDQUFDO0lBQ2pCLE9BQU8sQ0FBQyxDQUFDLEVBQUVBLEVBQUUsT0FBTyxDQUFDLEVBQUUsYUFBYTtBQUNyQztBQUVBLFNBQVNtSyxzQkFBc0JsSCxHQUFHO0lBQ2pDLElBQUlBLElBQUkxQyxNQUFNLElBQUksS0FBSzBDLEdBQUcsQ0FBQyxFQUFFLElBQUk4RCxVQUFVOUQsR0FBRyxDQUFDLEVBQUUsSUFBSThELFFBQVE7UUFDNUQsTUFBTSxJQUFJcUQsTUFBTTtJQUNqQjtBQUNEO0FBQ0EsU0FBU0MseUJBQXlCcEgsR0FBRztJQUNwQyxNQUFNcUgsYUFBYTtJQUNuQixJQUFLLElBQUlwTSxJQUFJK0UsSUFBSXNILFdBQVcsQ0FBQ0QsYUFBYXBNLElBQUksR0FBSztRQUNsRCxJQUFJK0UsR0FBRyxDQUFDLEVBQUUvRSxFQUFFLEtBQUtvTSxZQUFZO1lBQzVCLE1BQU0sSUFBSUYsTUFBTTtRQUNqQjtJQUNEO0FBQ0Q7QUFDQSxpRkFBaUY7QUFDakYsU0FBU0ksYUFBYXZILEdBQUc7SUFDeEIsSUFBSU4sS0FBS00sR0FBRyxDQUFDLEVBQUU7SUFDZixJQUFJaEMsT0FBT3NCLE9BQU8rQixHQUFHLENBQUMzQjtJQUN0QixJQUFJMUIsTUFBTSxNQUFNd0osZ0JBQWdCLENBQUMsUUFBUSxFQUFFeEosS0FBSyxDQUFDO0lBQ2pELElBQUlYLElBQUkyQyxJQUFJMUMsTUFBTTtJQUNsQixJQUFJbUssT0FBTyxDQUFDLEdBQUcsa0NBQWtDO0lBQ2pELElBQUssSUFBSXhNLElBQUksR0FBR0EsSUFBSW9DLEdBQUdwQyxJQUFLO1FBQzNCeUUsS0FBS00sR0FBRyxDQUFDL0UsRUFBRTtRQUNYLElBQUl5TSxRQUFRcEksT0FBTytCLEdBQUcsQ0FBQzNCO1FBQ3ZCLElBQUlnSSxPQUFPO1lBQ1YsaURBQWlEO1lBQ2pELElBQUlELFFBQVF4TSxHQUFHLE1BQU11TSxnQkFBZ0IsQ0FBQyxFQUFFeEosS0FBSyxHQUFHLEVBQUUwSixNQUFNLENBQUM7WUFDekRELE9BQU94TSxJQUFJO1lBQ1grQyxPQUFPMEo7UUFDUjtJQUNEO0lBQ0EsSUFBSUQsUUFBUXBLLEdBQUcsTUFBTW1LLGdCQUFnQixDQUFDLFNBQVMsRUFBRXhKLEtBQUssQ0FBQztBQUN4RDtBQUVBLDhEQUE4RDtBQUM5RCxTQUFTOEksa0JBQWtCcEgsRUFBRTtJQUM1QixPQUFPd0UsR0FBRy9DLEdBQUcsQ0FBQ3pCO0FBQ2Y7QUFDQSxTQUFTcUgsY0FBY3JILEVBQUU7SUFDeEIsT0FBTzBFLE9BQU9qRCxHQUFHLENBQUN6QjtBQUNuQjtBQUVBLFNBQVNpSSx1QkFBdUJDLElBQUksRUFBRUMsU0FBUztJQUM5QyxJQUFJQyxLQUFLRCxZQUFZckUsTUFBTUM7SUFDM0IsT0FBT21FLEtBQUtHLEtBQUssQ0FBQ25FLFNBQVNsSCxHQUFHLENBQUNzTCxDQUFBQSxRQUFTN0gsYUFBYThILFFBQVFsSSxXQUFXaUksUUFBUUYsSUFBSS9JLE9BQU8sQ0FBQ3BDLENBQUFBLElBQUtBLEVBQUVnSyxRQUFRLEdBQUd1QixZQUFZdkwsS0FBS0EsS0FBSzZELElBQUksQ0FBQ29EO0FBQzFJO0FBRUEsU0FBU3VFLGNBQWNDLElBQUk7SUFDMUIsT0FBT0MsUUFBUUMsVUFBVUY7QUFDMUI7QUFFQSxTQUFTRyxhQUFhSCxJQUFJO0lBQ3pCLElBQUlMLFFBQVFPLFVBQVVGLE1BQU07SUFDNUIsdUJBQXVCO0lBQ3ZCLEtBQUssSUFBSSxFQUFDSSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFDLElBQUlYLE1BQU87UUFDeEMsSUFBSVcsT0FBTztRQUVYLGtDQUFrQztRQUNsQyxrRkFBa0Y7UUFDbEYsbUVBQW1FO1FBQ25FOzs7Ozs7OztFQVFBLEdBQ0EsaURBQWlEO1FBQ2pELG9DQUFvQztRQUVwQyx5QkFBeUI7UUFDekIsc0JBQXNCO1FBQ3RCLElBQUlGLFNBQVMsU0FBUztZQUNyQixJQUFJeEssT0FBTztZQUNYLE1BQU8sS0FBTTtnQkFDWixJQUFJSCxPQUFPNEssT0FBT0UsT0FBTyxDQUFDLE9BQU8zSztnQkFDakMsSUFBSUgsT0FBTyxHQUFHO2dCQUNkNEssTUFBTSxDQUFDNUssS0FBSyxHQUFHO2dCQUNmRyxPQUFPSCxPQUFPO1lBQ2Y7UUFDRDtJQUVBLGtGQUFrRjtJQUNsRiw0REFBNEQ7SUFDNUQsOEJBQThCO0lBQy9CO0lBQ0EsT0FBT3dLLFFBQVFOO0FBQ2hCO0FBRUEsU0FBU08sVUFBVUYsSUFBSSxFQUFFUSxjQUFjO0lBQ3RDLElBQUluTSxTQUFTO0lBQ2Isc0RBQXNEO0lBQ3RELDZEQUE2RDtJQUM3RCxPQUFPMkwsS0FBS0wsS0FBSyxDQUFDbkUsU0FBU2xILEdBQUcsQ0FBQ3NMLENBQUFBO1FBQzlCLElBQUlhLFFBQVE5SSxXQUFXaUk7UUFDdkIsSUFBSWMsT0FBTztZQUNWRDtZQUNBcE07UUFDRDtRQUNBQSxVQUFVb00sTUFBTXZMLE1BQU0sR0FBRyxHQUFHLFNBQVM7UUFDckMsSUFBSXlMO1FBQ0osSUFBSTtZQUNILDREQUE0RDtZQUM1RCxJQUFJQyxTQUFTRixLQUFLRSxNQUFNLEdBQUdmLFFBQVFZLE9BQU9wRixNQUFNLHdDQUF3QztZQUN4RixJQUFJd0YsY0FBY0QsT0FBTzFMLE1BQU07WUFDL0IsSUFBSWtMO1lBQ0osSUFBSSxDQUFDUyxhQUFhO2dCQUNqQiw2QkFBNkI7Z0JBQzdCLG9FQUFvRTtnQkFDcEUsWUFBWTtnQkFDWiwyREFBMkQ7Z0JBQzNELE1BQU0sSUFBSTlCLE1BQU0sQ0FBQyxXQUFXLENBQUM7WUFDOUIsT0FBTztnQkFDTixJQUFJK0IsUUFBUUYsTUFBTSxDQUFDLEVBQUU7Z0JBQ3JCLElBQUlHLFFBQVFGLGNBQWMsS0FBS0MsTUFBTXZDLFFBQVE7Z0JBQzdDLElBQUksQ0FBQ3dDLFNBQVNELE1BQU1FLEtBQUssQ0FBQzFKLENBQUFBLEtBQU1BLEtBQUssT0FBTztvQkFDM0NxSixPQUFPRztvQkFDUDlCLHlCQUF5QjJCO29CQUN6Qix3QkFBd0I7b0JBQ3hCLGlEQUFpRDtvQkFDakQ3QixzQkFBc0I2QjtvQkFDdEIsbUJBQW1CO29CQUNuQixlQUFlO29CQUNmLG1CQUFtQjtvQkFDbkIsK0JBQStCO29CQUMvQlAsT0FBTztnQkFDUixPQUFPO29CQUNOLElBQUlXLE9BQU87d0JBQ1ZMLEtBQUtLLEtBQUssR0FBRzt3QkFDYkQsUUFBUUYsT0FBT2pLLE9BQU8sQ0FBQ3BDLENBQUFBLElBQUtBLEVBQUVnSyxRQUFRLEdBQUcsRUFBRSxHQUFHaEssSUFBSSx3Q0FBd0M7b0JBQzNGO29CQUNBb00sT0FBT0MsT0FBT2pLLE9BQU8sQ0FBQ3BDLENBQUFBLElBQUssQ0FBQ2lNLGtCQUFrQmpNLEVBQUVnSyxRQUFRLEdBQUd1QixZQUFZdkwsS0FBS0E7b0JBQzVFeUsseUJBQXlCMkI7b0JBQ3pCLElBQUksQ0FBQ0csTUFBTTVMLE1BQU0sRUFBRTt3QkFDbEJrTCxPQUFPO29CQUNSLE9BQU87d0JBQ04sdUZBQXVGO3dCQUN2RixJQUFJdEUsR0FBRy9DLEdBQUcsQ0FBQzRILElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTXZCLGdCQUFnQjt3QkFDM0MsSUFBSyxJQUFJdk0sSUFBSSxHQUFHQSxJQUFJZ08sYUFBYWhPLElBQUs7NEJBQ3JDLElBQUkrRSxNQUFNZ0osTUFBTSxDQUFDL04sRUFBRTs0QkFDbkIsSUFBSSxDQUFDK0UsSUFBSTJHLFFBQVEsSUFBSXpDLEdBQUcvQyxHQUFHLENBQUNuQixHQUFHLENBQUMsRUFBRSxHQUFHO2dDQUNwQywwREFBMEQ7Z0NBQzFELE1BQU13SCxnQkFBZ0IsQ0FBQyx5QkFBeUIsRUFBRXJILGFBQWE2SSxNQUFNLENBQUMvTixJQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUyTCxrQkFBa0I7b0NBQUM1RyxHQUFHLENBQUMsRUFBRTtpQ0FBQyxFQUFFLENBQUMsQ0FBQzs0QkFDaEg7d0JBQ0Q7d0JBQ0F1SCxhQUFhd0I7d0JBQ2IsSUFBSU0sU0FBUzsrQkFBSSxJQUFJckksSUFBSWtJO3lCQUFPO3dCQUNoQyxJQUFJLENBQUMzRCxFQUFFLEdBQUcrRCxnQkFBZ0JELFNBQVMsdUJBQXVCO3dCQUMxRCxtREFBbUQ7d0JBQ25ELDZEQUE2RDt3QkFDN0RFLFlBQVloRSxHQUFHMkQsUUFBUSxxQkFBcUI7d0JBQzVDTSxZQUFZakUsR0FBRzhELFNBQVMsZ0ZBQWdGO3dCQUN4R2IsT0FBT2pELEVBQUUvSixDQUFDO29CQUNWLDhDQUE4QztvQkFDOUMsOENBQThDO29CQUM5QyxxQ0FBcUM7b0JBQ3JDLGtDQUFrQztvQkFDbkM7Z0JBQ0Q7WUFDRDtZQUNBc04sS0FBS04sSUFBSSxHQUFHQTtRQUNiLEVBQUUsT0FBT2lCLEtBQUs7WUFDYlgsS0FBS0osS0FBSyxHQUFHZSxLQUFLLHdCQUF3QjtRQUMzQztRQUNBWCxLQUFLTCxNQUFNLEdBQUdNO1FBQ2QsT0FBT0Q7SUFDUjtBQUNEO0FBRUEsU0FBU1UsWUFBWUUsS0FBSyxFQUFFTCxNQUFNO0lBQ2pDLElBQUlNO0lBQ0osSUFBSUMsU0FBUyxFQUFFLEVBQUUsNkJBQTZCO0lBQzlDLEtBQUssSUFBSWxLLE1BQU0ySixPQUFRO1FBQ3RCLElBQUlRLFFBQVE1RSxVQUFVNUQsR0FBRyxDQUFDM0I7UUFDMUIsSUFBSW1LLFVBQVVoRyxXQUFXLFFBQVEseUJBQXlCO1FBQzFELElBQUlnRyxPQUFPO1lBQ1YsSUFBSXZJLE1BQU11SSxNQUFNOUUsQ0FBQyxDQUFDMUQsR0FBRyxDQUFDM0IsS0FBSyw4REFBOEQ7WUFDekZpSyxRQUFRQSxRQUFRQSxNQUFNckUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLakUsSUFBSUgsR0FBRyxDQUFDb0UsTUFBTTttQkFBSWpFO2FBQUk7WUFDeEQsSUFBSSxDQUFDcUksTUFBTXJNLE1BQU0sRUFBRSxRQUFRLG1DQUFtQztRQUMvRCxPQUFPO1lBQ05zTSxPQUFPMU8sSUFBSSxDQUFDd0U7UUFDYjtJQUNEO0lBQ0EsSUFBSWlLLE9BQU87UUFDVix3QkFBd0I7UUFDeEIsc0NBQXNDO1FBQ3RDLG9DQUFvQztRQUNwQyxLQUFLLElBQUlwRSxLQUFLb0UsTUFBTztZQUNwQixJQUFJQyxPQUFPUixLQUFLLENBQUMxSixDQUFBQSxLQUFNNkYsRUFBRVYsQ0FBQyxDQUFDMUQsR0FBRyxDQUFDekIsTUFBTTtnQkFDcEMsTUFBTSxJQUFJeUgsTUFBTSxDQUFDLHlCQUF5QixFQUFFdUMsTUFBTWxPLENBQUMsQ0FBQyxDQUFDLEVBQUUrSixFQUFFL0osQ0FBQyxDQUFDLENBQUM7WUFDN0Q7UUFDRDtJQUNEO0FBQ0Q7QUFFQSw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLFNBQVM4TixnQkFBZ0JELE1BQU07SUFDOUIsSUFBSVMsU0FBU3JGO0lBQ2IsS0FBSyxJQUFJL0UsTUFBTTJKLE9BQVE7UUFDdEIsaURBQWlEO1FBQ2pELDBDQUEwQztRQUMxQyxJQUFJaEUsS0FBS3lFLE9BQU94RSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVWLENBQUMsQ0FBQzFELEdBQUcsQ0FBQ3pCO1FBQ3BDLElBQUksQ0FBQzJGLEdBQUcvSCxNQUFNLEVBQUU7WUFDZixJQUFJd00sV0FBV3JGLFFBQVE7Z0JBQ3RCLDRDQUE0QztnQkFDNUMsK0JBQStCO2dCQUMvQixNQUFNc0YsaUJBQWlCckssS0FBSyxzQkFBc0I7WUFDbkQsT0FBTztnQkFDTix1REFBdUQ7Z0JBQ3ZELHNEQUFzRDtnQkFDdEQsaUVBQWlFO2dCQUNqRSxNQUFNc0ssbUJBQW1CRixNQUFNLENBQUMsRUFBRSxFQUFFcEs7WUFDckM7UUFDRDtRQUNBb0ssU0FBU3pFO1FBQ1QsSUFBSUEsR0FBRy9ILE1BQU0sSUFBSSxHQUFHLE9BQU8sK0JBQStCO0lBQzNEO0lBQ0EsNkRBQTZEO0lBQzdELE9BQU93TTtBQUNSO0FBRUEsdUJBQXVCO0FBQ3ZCLFNBQVN6QixRQUFRTixLQUFLO0lBQ3JCLE9BQU9BLE1BQU1yTCxHQUFHLENBQUMsQ0FBQyxFQUFDbU0sS0FBSyxFQUFFSCxLQUFLLEVBQUVELE1BQU0sRUFBQztRQUN2QyxJQUFJQyxPQUFPO1lBQ1YsaURBQWlEO1lBQ2pELElBQUl1QixNQUFNdkIsTUFBTXdCLE9BQU87WUFDdkIsNENBQTRDO1lBQzVDLE1BQU0sSUFBSS9DLE1BQU1ZLE1BQU16SyxNQUFNLElBQUksSUFBSTJNLE1BQU0sQ0FBQyxjQUFjLEVBQUVoRCxRQUFRTCxrQkFBa0JpQyxRQUFRLEVBQUUsRUFBRW9CLElBQUksQ0FBQztRQUN2RztRQUNBLE9BQU85SixhQUFhc0k7SUFDckIsR0FBR2pJLElBQUksQ0FBQ29EO0FBQ1Q7QUFFQSxTQUFTbUcsaUJBQWlCckssRUFBRTtJQUMzQix5QkFBeUI7SUFDekIsT0FBTyxJQUFJeUgsTUFBTSxDQUFDLHNCQUFzQixFQUFFSCxVQUFVdEgsSUFBSSxDQUFDO0FBQzFEO0FBQ0EsU0FBU3NLLG1CQUFtQnpFLENBQUMsRUFBRTdGLEVBQUU7SUFDaEMsSUFBSXlLLFNBQVNuRCxVQUFVdEg7SUFDdkIsSUFBSTBLLEtBQUszRixPQUFPZ0IsSUFBSSxDQUFDRixDQUFBQSxJQUFLQSxFQUFFWixDQUFDLENBQUN4RCxHQUFHLENBQUN6QjtJQUNsQyxJQUFJMEssSUFBSTtRQUNQRCxTQUFTLENBQUMsRUFBRUMsR0FBRzVPLENBQUMsQ0FBQyxDQUFDLEVBQUUyTyxPQUFPLENBQUM7SUFDN0I7SUFDQSxPQUFPLElBQUloRCxNQUFNLENBQUMsaUJBQWlCLEVBQUU1QixFQUFFL0osQ0FBQyxDQUFDLEdBQUcsRUFBRTJPLE9BQU8sQ0FBQztBQUN2RDtBQUNBLFNBQVMzQyxnQkFBZ0I2QyxLQUFLO0lBQzdCLE9BQU8sSUFBSWxELE1BQU0sQ0FBQyxtQkFBbUIsRUFBRWtELE1BQU0sQ0FBQztBQUMvQztBQUVBLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsb0RBQW9EO0FBQ3BELFNBQVNkLFlBQVloRSxDQUFDLEVBQUV2RixHQUFHO0lBQzFCLElBQUksRUFBQzZFLENBQUMsRUFBRUUsQ0FBQyxFQUFDLEdBQUdRO0lBQ2IsS0FBSyxJQUFJN0YsTUFBTU0sSUFBSztRQUNuQixJQUFJLENBQUM2RSxFQUFFMUQsR0FBRyxDQUFDekIsS0FBSztZQUNmLDRGQUE0RjtZQUM1RixtRUFBbUU7WUFDbkUsbURBQW1EO1lBQ25ELG9EQUFvRDtZQUNwRCxxQkFBcUI7WUFDckIsbURBQW1EO1lBQ25ELDZDQUE2QztZQUM3QyxpREFBaUQ7WUFDakQscUVBQXFFO1lBQ3JFLG9DQUFvQztZQUNwQyxNQUFNc0ssbUJBQW1CekUsR0FBRzdGO1FBQzdCO0lBQ0Q7SUFDQSxpREFBaUQ7SUFDakQsSUFBSXFGLEdBQUc7UUFDTixJQUFJdkMsYUFBYWdCLElBQUl4RDtRQUNyQixJQUFLLElBQUkvRSxJQUFJLEdBQUdxUCxJQUFJOUgsV0FBV2xGLE1BQU0sRUFBRXJDLElBQUlxUCxHQUFHclAsSUFBSztZQUNsRCxrRUFBa0U7WUFDbEU7Ozs7Ozs7OztHQVNBLEdBQ0EsbUNBQW1DO1lBQ25DLDJEQUEyRDtZQUMzRCxJQUFJa0osSUFBSWhELEdBQUcsQ0FBQ3FCLFVBQVUsQ0FBQ3ZILEVBQUUsR0FBRztnQkFDM0IsSUFBSTBELElBQUkxRCxJQUFJO2dCQUNaLElBQUssSUFBSXlFLElBQUlmLElBQUkyTCxLQUFLbkcsSUFBSWhELEdBQUcsQ0FBQ3pCLEtBQUs4QyxVQUFVLENBQUM3RCxFQUFFLEdBQUdBLElBQUs7b0JBQ3ZELG1EQUFtRDtvQkFDbkQsSUFBSyxJQUFJNEwsSUFBSXRQLEdBQUdzUCxJQUFJNUwsR0FBRzRMLElBQUs7d0JBQzNCLElBQUkvSCxVQUFVLENBQUMrSCxFQUFFLElBQUk3SyxJQUFJOzRCQUN4QixNQUFNLElBQUl5SCxNQUFNLENBQUMsNEJBQTRCLEVBQUVILFVBQVV0SCxJQUFJLENBQUM7d0JBQy9EO29CQUNEO2dCQUNEO2dCQUNBLHlDQUF5QztnQkFDekMsd0VBQXdFO2dCQUN4RSxJQUFJZixJQUFJMUQsSUFBSXVFLFNBQVM7b0JBQ3BCLDhEQUE4RDtvQkFDOUQsTUFBTSxJQUFJMkgsTUFBTSxDQUFDLDRCQUE0QixFQUFFRixRQUFRTCxrQkFBa0JwRSxXQUFXcEQsS0FBSyxDQUFDbkUsSUFBRSxHQUFHMEQsS0FBSyxFQUFFLEVBQUVBLElBQUUxRCxFQUFFLENBQUMsRUFBRXVFLFFBQVEsQ0FBQyxDQUFDO2dCQUMxSDtnQkFDQXZFLElBQUkwRDtZQUNMO1FBQ0Q7SUFDRDtBQUNBLDJDQUEyQztBQUMzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0Q0EsR0FDRDtBQUVBLDZCQUE2QjtBQUM3QixpRkFBaUY7QUFDakYsdUVBQXVFO0FBQ3ZFLFNBQVNzSixRQUFRWSxLQUFLLEVBQUVmLEVBQUU7SUFDekIsSUFBSXZLLE1BQU0sRUFBRTtJQUNaLElBQUkyTCxRQUFRLEVBQUU7SUFDZEwsUUFBUUEsTUFBTXpKLEtBQUssR0FBR21DLE9BQU8sSUFBSSxxQkFBcUI7SUFDdEQsTUFBT3NILE1BQU12TCxNQUFNLENBQUU7UUFDcEIsSUFBSTZMLFFBQVFxQix1QkFBdUIzQjtRQUNuQyxJQUFJTSxPQUFPO1lBQ1YsSUFBSUQsTUFBTTVMLE1BQU0sRUFBRTtnQkFDakJDLElBQUlyQyxJQUFJLENBQUM0TSxHQUFHb0I7Z0JBQ1pBLFFBQVEsRUFBRTtZQUNYO1lBQ0EzTCxJQUFJckMsSUFBSSxDQUFDaU87UUFDVixPQUFPO1lBQ04sSUFBSXpKLEtBQUttSixNQUFNNUYsR0FBRztZQUNsQixJQUFJOEMsTUFBTTVFLEdBQUcsQ0FBQ3pCLEtBQUs7Z0JBQ2xCd0osTUFBTWhPLElBQUksQ0FBQ3dFO1lBQ1osT0FBTztnQkFDTixJQUFJTSxNQUFNZ0UsT0FBTzNDLEdBQUcsQ0FBQzNCO2dCQUNyQixJQUFJTSxLQUFLO29CQUNSa0osTUFBTWhPLElBQUksSUFBSThFO2dCQUNmLE9BQU8sSUFBSSxDQUFDaUUsUUFBUTlDLEdBQUcsQ0FBQ3pCLEtBQUs7b0JBQzVCLE1BQU1xSyxpQkFBaUJySztnQkFDeEI7WUFDRDtRQUNEO0lBQ0Q7SUFDQSxJQUFJd0osTUFBTTVMLE1BQU0sRUFBRTtRQUNqQkMsSUFBSXJDLElBQUksQ0FBQzRNLEdBQUdvQjtJQUNiO0lBQ0EsT0FBTzNMO0FBQ1I7QUFFQSxTQUFTMkssWUFBWWxJLEdBQUc7SUFDdkIsT0FBT0EsSUFBSXNGLE1BQU0sQ0FBQzVGLENBQUFBLEtBQU1BLE1BQU1pRTtBQUMvQjtBQUVBLDRCQUE0QjtBQUM1QixzRUFBc0U7QUFDdEUsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2QiwyQ0FBMkM7QUFDM0MsdURBQXVEO0FBQ3ZELFNBQVM2Ryx1QkFBdUJ4SyxHQUFHLEVBQUV5SyxLQUFLO0lBQ3pDLElBQUlDLE9BQU96RTtJQUNYLElBQUlrRDtJQUNKLElBQUl3QjtJQUNKLElBQUl0SCxRQUFRLEVBQUU7SUFDZCxJQUFJekksTUFBTW9GLElBQUkxQyxNQUFNO0lBQ3BCLElBQUltTixPQUFPQSxNQUFNbk4sTUFBTSxHQUFHLEdBQUcsaUNBQWlDO0lBQzlELE1BQU8xQyxJQUFLO1FBQ1gsSUFBSThFLEtBQUtNLEdBQUcsQ0FBQyxFQUFFcEYsSUFBSTtRQUNuQjhQLE9BQU9BLEtBQUt2RSxDQUFDLENBQUNWLElBQUksQ0FBQzlJLENBQUFBLElBQUtBLEVBQUVpSSxDQUFDLENBQUN6RCxHQUFHLENBQUN6QjtRQUNoQyxJQUFJLENBQUNnTCxNQUFNO1FBQ1gsSUFBSUEsS0FBS2xFLENBQUMsRUFBRTtZQUNYbUUsUUFBUWpMO1FBQ1QsT0FBTyxJQUFJZ0wsS0FBS2pFLENBQUMsRUFBRTtZQUNsQixJQUFJL0csT0FBT2lMLE9BQU87UUFDbkI7UUFDQXRILE1BQU1uSSxJQUFJLENBQUN3RTtRQUNYLElBQUlnTCxLQUFLbkUsQ0FBQyxFQUFFO1lBQ1hsRCxNQUFNbkksSUFBSSxDQUFDeUk7WUFDWCxJQUFJL0ksTUFBTSxLQUFLb0YsR0FBRyxDQUFDcEYsTUFBTSxFQUFFLElBQUkrSSxNQUFNL0ksT0FBTyx3QkFBd0I7UUFDckU7UUFDQSxJQUFJOFAsS0FBSzdGLENBQUMsRUFBRTtZQUNYc0UsUUFBUXlCLG1CQUFtQnZILE9BQU9xSDtZQUNsQyxJQUFJRCxPQUFPQSxNQUFNdlAsSUFBSSxJQUFJOEUsSUFBSVosS0FBSyxDQUFDeEUsS0FBSzJHLE9BQU8sS0FBSyx5QkFBeUI7WUFDN0V2QixJQUFJMUMsTUFBTSxHQUFHMUMsS0FBSyxXQUFXO1FBQzlCO0lBQ0Q7SUFDQTs7Ozs7Ozs7OztDQVVBLEdBQ0EsT0FBT3VPO0FBQ1I7QUFFQSwyQ0FBMkM7QUFDM0MsU0FBU3lCLG1CQUFtQjVLLEdBQUcsRUFBRTBLLElBQUk7SUFDcEMsSUFBSUcsT0FBT25FLE1BQU1vRSxJQUFJLENBQUM5SyxNQUFNLGFBQWE7SUFDekMsSUFBSTBLLEtBQUs3RixDQUFDLElBQUksR0FBR2dHLEtBQUtFLE1BQU0sQ0FBQyxHQUFHLElBQUksMkNBQTJDO0lBQy9FLE9BQU9GO0FBQ1I7QUFFQSx1REFBdUQ7QUFDdkQsd0NBQXdDO0FBQ3hDLFNBQVNHO0lBQ1IsMkNBQTJDO0lBQzNDLDBDQUEwQztJQUMxQyxJQUFJek4sTUFBTSxFQUFFO0lBQ1owTixNQUFNaEYsWUFBWSxFQUFFO0lBQ3BCLE9BQU8xSSxJQUFJdUgsSUFBSSxDQUFDckU7SUFDaEIsU0FBU3dLLE1BQU1QLElBQUksRUFBRTFLLEdBQUcsRUFBRTJLLEtBQUs7UUFDOUIsSUFBSUQsS0FBS2xFLENBQUMsRUFBRTtZQUNYbUUsUUFBUTNLLEdBQUcsQ0FBQ0EsSUFBSTFDLE1BQU0sR0FBQyxFQUFFO1FBQzFCLE9BQU8sSUFBSW9OLEtBQUtqRSxDQUFDLEVBQUU7WUFDbEIsSUFBSWtFLFVBQVUzSyxHQUFHLENBQUNBLElBQUkxQyxNQUFNLEdBQUMsRUFBRSxFQUFFO1FBQ2xDO1FBQ0EsSUFBSW9OLEtBQUtuRSxDQUFDLEVBQUV2RyxJQUFJOUUsSUFBSSxDQUFDeUk7UUFDckIsSUFBSStHLEtBQUs3RixDQUFDLEVBQUV0SCxJQUFJckMsSUFBSSxDQUFDMFAsbUJBQW1CNUssS0FBSzBLO1FBQzdDLEtBQUssSUFBSVEsTUFBTVIsS0FBS3ZFLENBQUMsQ0FBRTtZQUN0QixLQUFLLElBQUl6RyxNQUFNd0wsR0FBR3RHLENBQUMsQ0FBRTtnQkFDcEJxRyxNQUFNQyxJQUFJO3VCQUFJbEw7b0JBQUtOO2lCQUFHLEVBQUVpTDtZQUN6QjtRQUNEO0lBQ0Q7QUFDRDtBQUVBLCtEQUErRDtBQUMvRCxhQUFhO0FBRWIsTUFBTVEsV0FBVztBQUNqQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFVBQVU7QUFFaEIsU0FBU0MsYUFBYXRELElBQUksRUFBRSxFQUMzQk4sS0FBSyxJQUFJLEVBQ1QsR0FBRyxDQUFDLENBQUM7SUFDTCxJQUFJZSxRQUFROUksV0FBV3FJLE1BQU03RyxPQUFPO0lBQ3BDLElBQUlrSixRQUFRLEVBQUU7SUFDZCxJQUFJekIsU0FBUyxFQUFFO0lBQ2YsTUFBT0gsTUFBTXZMLE1BQU0sQ0FBRTtRQUNwQixJQUFJNkwsUUFBUXFCLHVCQUF1QjNCLE9BQU80QjtRQUMxQyxJQUFJdEIsT0FBTztZQUNWSCxPQUFPOU4sSUFBSSxDQUFDO2dCQUFDc04sTUFBTStDO2dCQUFVcEM7Z0JBQU9OLE9BQU80QixNQUFNckwsS0FBSztnQkFBSVksS0FBS2tJLFlBQVlpQjtZQUFNO1FBQ2xGLE9BQU87WUFDTixJQUFJekosS0FBS21KLE1BQU01RixHQUFHO1lBQ2xCLElBQUl2RCxNQUFNZ0UsTUFBTTtnQkFDZnNGLE9BQU85TixJQUFJLENBQUM7b0JBQUNzTixNQUFNaUQ7b0JBQVMvTDtnQkFBRTtZQUMvQixPQUFPLElBQUlxRyxNQUFNNUUsR0FBRyxDQUFDekIsS0FBSztnQkFDekJzSixPQUFPOU4sSUFBSSxDQUFDO29CQUFDc04sTUFBTTJDO29CQUFVbkwsS0FBSzt3QkFBQ047cUJBQUc7Z0JBQUE7WUFDdkMsT0FBTyxJQUFJdUUsUUFBUTlDLEdBQUcsQ0FBQ3pCLEtBQUs7Z0JBQzNCc0osT0FBTzlOLElBQUksQ0FBQztvQkFBQ3NOLE1BQU02QztvQkFBWTNMO2dCQUFFO1lBQ2xDLE9BQU87Z0JBQ04sSUFBSU0sTUFBTWdFLE9BQU8zQyxHQUFHLENBQUMzQjtnQkFDckIsSUFBSU0sS0FBSztvQkFDUmdKLE9BQU85TixJQUFJLENBQUM7d0JBQUNzTixNQUFNNEM7d0JBQVcxTDt3QkFBSU0sS0FBS0EsSUFBSVosS0FBSztvQkFBRTtnQkFDbkQsT0FBTztvQkFDTjRKLE9BQU85TixJQUFJLENBQUM7d0JBQUNzTixNQUFNOEM7d0JBQWU1TDtvQkFBRTtnQkFDckM7WUFDRDtRQUNEO0lBQ0Q7SUFDQSxJQUFJb0ksSUFBSTtRQUNQLElBQUssSUFBSTdNLElBQUksR0FBR21CLFFBQVEsQ0FBQyxHQUFHbkIsSUFBSStOLE9BQU8xTCxNQUFNLEVBQUVyQyxJQUFLO1lBQ25ELElBQUkwUSxRQUFRM0MsTUFBTSxDQUFDL04sRUFBRTtZQUNyQixJQUFJMlEsbUJBQW1CRCxNQUFNbkQsSUFBSSxHQUFHO2dCQUNuQyxJQUFJcUQsZUFBZUYsTUFBTTNMLEdBQUcsR0FBRztvQkFDOUIsSUFBSTNELE1BQU1wQixJQUFJO29CQUNkLElBQUssSUFBSUwsTUFBTXlCLEtBQUt6QixNQUFNb08sT0FBTzFMLE1BQU0sRUFBRTFDLE1BQU87d0JBQy9DLElBQUksRUFBQzROLElBQUksRUFBRXhJLEdBQUcsRUFBQyxHQUFHZ0osTUFBTSxDQUFDcE8sSUFBSTt3QkFDN0IsSUFBSWdSLG1CQUFtQnBELE9BQU87NEJBQzdCLElBQUksQ0FBQ3FELGVBQWU3TCxNQUFNOzRCQUMxQjNELE1BQU16QixNQUFNO3dCQUNiLE9BQU8sSUFBSTROLFNBQVM2QyxZQUFZOzRCQUMvQjt3QkFDRDtvQkFDRDtvQkFDQSxJQUFJalAsUUFBUSxHQUFHQSxRQUFRbkI7b0JBQ3ZCLElBQUltRSxRQUFRNEosT0FBTzVKLEtBQUssQ0FBQ2hELE9BQU9DO29CQUNoQyxJQUFJeVAsT0FBTzFNLE1BQU1MLE9BQU8sQ0FBQ3BDLENBQUFBLElBQUtpUCxtQkFBbUJqUCxFQUFFNkwsSUFBSSxJQUFJN0wsRUFBRXFELEdBQUcsR0FBRyxFQUFFLEdBQUcsb0JBQW9CO29CQUM1RixJQUFJQSxNQUFNeUQsSUFBSXFJO29CQUNkLElBQUlyTCxlQUFlVCxLQUFLOEwsT0FBTzt3QkFDOUI5QyxPQUFPK0IsTUFBTSxDQUFDM08sT0FBT0MsTUFBTUQsT0FBTzs0QkFDakNvTSxNQUFNZ0Q7NEJBQ04zQyxPQUFPaUQ7NEJBQ1A5TDs0QkFDQStMLFNBQVNDLHNCQUFzQjVNOzRCQUMvQjRKLFFBQVEwQyxhQUFhdkwsYUFBYUgsTUFBTTtnQ0FBQzhILElBQUk7NEJBQUs7d0JBQ25EO3dCQUNBN00sSUFBSW1CO29CQUNMLE9BQU87d0JBQ05uQixJQUFJb0IsTUFBTSxHQUFHLHVCQUF1QjtvQkFDckM7b0JBQ0FELFFBQVEsQ0FBQyxHQUFHLFFBQVE7Z0JBQ3JCLE9BQU87b0JBQ05BLFFBQVFuQixHQUFHLGdCQUFnQjtnQkFDNUI7WUFDRCxPQUFPLElBQUkwUSxNQUFNbkQsSUFBSSxLQUFLNkMsWUFBWTtnQkFDckNqUCxRQUFRLENBQUMsR0FBRyxRQUFRO1lBQ3JCO1FBQ0Q7SUFDRDtJQUNBLE9BQU80UCxzQkFBc0JoRDtBQUM5QjtBQUVBLFNBQVM0QyxtQkFBbUJwRCxJQUFJO0lBQy9CLE9BQU9BLFFBQVEyQyxZQUFZM0MsUUFBUTRDO0FBQ3BDO0FBRUEsU0FBU1MsZUFBZTdMLEdBQUc7SUFDMUIsT0FBT0EsSUFBSTJGLElBQUksQ0FBQ2pHLENBQUFBLEtBQU0yRSxVQUFVbEQsR0FBRyxDQUFDekI7QUFDckM7QUFFQSxTQUFTc00sc0JBQXNCaEQsTUFBTTtJQUNwQyxJQUFLLElBQUkvTixJQUFJLEdBQUdBLElBQUkrTixPQUFPMUwsTUFBTSxFQUFFckMsSUFBSztRQUN2QyxJQUFJK04sTUFBTSxDQUFDL04sRUFBRSxDQUFDdU4sSUFBSSxJQUFJMkMsVUFBVTtZQUMvQixJQUFJeE0sSUFBSTFELElBQUk7WUFDWixNQUFPMEQsSUFBSXFLLE9BQU8xTCxNQUFNLElBQUkwTCxNQUFNLENBQUNySyxFQUFFLENBQUM2SixJQUFJLElBQUkyQyxTQUFVeE07WUFDeERxSyxPQUFPK0IsTUFBTSxDQUFDOVAsR0FBRzBELElBQUkxRCxHQUFHO2dCQUFDdU4sTUFBTTJDO2dCQUFVbkwsS0FBS2dKLE9BQU81SixLQUFLLENBQUNuRSxHQUFHMEQsR0FBR0ksT0FBTyxDQUFDcEMsQ0FBQUEsSUFBS0EsRUFBRXFELEdBQUc7WUFBQztRQUNyRjtJQUNEO0lBQ0EsT0FBT2dKO0FBQ1I7QUFFa0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5tanM/ZGFlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XG5cbi8vIGNyZWF0ZWQgMjAyMy0wMi0yMVQwOToxODoxMy41NDlaXG52YXIgciQxID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoJ0FFZ1Nid2pFRFZZQnlRS2FBUXNCT1FEcEFUUUFuZ0RVQUhzQW9BQm9BTlFBYWdDTkFFUUFoQUJNQUhJQU93QTlBQ3NBTmdBbUFHSUFIZ0F2QUNnQUp3QVhBQzBBR2dBakFCOEFMd0FVQUNrQUVnQWVBQWtBR3dBUkFCa0FGZ0E1QUNnQUxRQXJBRGNBRlFBcEFCQUFIZ0FpQUJBQUdBQWVBQk1BRndBWEFBMEFEZ0FXQUE4QUZBQVZCRnNGMVFFWEUwbzN4QVhVQUxJQXJrQUJhQUNtQWdQR0FLNkFNREF3TUFFL3FBWUs3UDRIUUFibE1nVllCVmtBUFN3NUFmYTNFZ2ZKd2dBUEE4bWVOQUxHQ2pBQ2pxSUNodGsvajIrS0FzWE1Bb1B6QVNEZ0NnRHlyZ0ZDQWk2T0NrQ1FBT1FBNHdvV0FCalZ1c2tOREQ2ZUJCeDRBUDRDT2hpK0Qrd0tCaXJxQmdTQ2FBMGNCeTRBckFCcWt1K21uSUFBWEFhVUpBYnFBQndBUEF5VUZ2eXAvTW84SU5BSXZDb0RzaFE4QVBjdWJLUUFvbjRaQUJnRUp0Z1hBUjRBdWhuT0JQc0tJRTA0Q1pnSmlSOGNWbHBNNUlOREFCUUFEUUFXQUE5c1ZRQWlBQThBU084VzJUMzBPVm5LbHVZdkNoRWVYMDVaUGUwQUZBQU5BQllBRDJ3Z1hVQ1lBTVBzQUJ3QU9nekdGcnlwL0FIYXVRVmNCZU1DMEtBQ3hMRUtUUjJrWmhSMEdtNU05Z0M4RG1nQzRnQU1MalNLRjhxU0FvRjhBUk1jQUw0T2FBTGlBQXd1QVVsUUpwSk1Dd010L0FVcEN0aHFHSzRCMkVRQWNpd1NlQUl5RmlJREtDaTZPR3dBT3VJQjlpWUF5QTdNdGdFY1pJSUFzZ1lBQmdDSzFFb0ZITlpzR0FDb0tOSUJvZ0FBQUFBQUt5NERuQUJvQVFvYVB1NDNkUVFaR0FDckFjZ0NJZ0RnTEJKME92UlFzVE9pS0RWSkJmc29CVm9GV2JDNUJXbzdYa0lUTzFoQ21IdVVabUNoK1F3VUE4WUlKdko0SkFTa1RBSlVWQUoySEt3b0FaQ2twalpjQTBZWUJJUmlDZ0RTQnF4QU1DUUhLZ0k2WGdCc0FXSWdjZ0NFSGhvQWxnRkt1QUFvYWhnQnNNWURPQzRpUkZRQmNGb0daZ0ptQVBKS0dBTXFBZ1lBU2tJQXJBQmVBSFFBTExZR0NQVHdHbzZBQUFBS0lnQXFBTFFjU0FIU0Fkd0lEREtYZVlIcEFBc0FFZ0ExQUQ0QU9UUjNldFRCRUdBUVhRSk5Da3h0T3hVTUFxMFBwd3ZtRVJZTTBpck0wOWtBTktvSDdBTlVCK3dEVkFOVUIrd0g3QU5VQit3RFZBTlVBMVFEVkJ3TDhCdlV3UkJnRDBrRWJnV1BCWXdFMXdpRUprb1JnZ2NwQ05OVURuUWZIRWdEUmdEOUl5WkpIVHVVTXd3bFEwd05UUVFIL1RaRGJLaDlPUU5JTWF4VTlwQ2pBOHd5VURsdEFoNXlFcUVBS3c5MEhUVzJUbjk2U0hHaENreFByN1dBU1dOT2FBSy9PcWsvK1FvaUNaUnZ2SGRQQmo0UUdDZWlFUFFNTUFHeUFUZ042a3ZWQk80R09BVEdIM29aRmcvS2xaa0lvaTNhRE9vbTRDNmVnRmNqOGlxQUJlcEw4VHphQzBwUlpROVdDMklKNERwZ2dVc0RIZ0VLSW9nSzJnMDJDR29ROEFyR2FBM2lFVUlITmdQU1NaY0FvZ2IrQ3c0ZE1oV3lKZzFpcVFzR09YUUcrQnJ6QzR3bXJCTW1ldmtGMEJvZUJrb0JKaHI4QU13dTVJV3RXaTVjR1U5Y0JnQUxJaVBFRktWUUhRMGlRTFI0UlJvWUJ4SWxwZ0tPUTIxS2hGRXpIcEFoOHp3NkRXTXVFRkY1Qi9JOEFobE1DMzQ4bTBhb1JRc1J6ejZLUFVVaVJrd3BCREo4TEN3bmlBbk1ENElNdG54dkFWWUpIZ211REc0VExoRVVOOElJTmdjV0twY2hKeElJSGthU1lKY0U5SndEOEJQT0F3Z0ZQQWsrQnhBRHNod3FFeXNWSmdVS2dTSFVBdkEyMGk2d0FveFdmUUVVQmNnUEloL2NFRTFIM1E3bUNKZ0NZZ09BSmVnQUtoVWVBQlFpbUFoQVlBQmNqOVZUQWk3SUNNUnFhU054QTJRVTVGNFJjQWVPRGxRSHBCd3dGYndjM25ERlhnaUdCU2lnckFsWUFYSUpsZ0ZjQk9BSUJqVllqSjBnUG1kUWkxVVltQ0JlUVR4ZCtRSXVER0lWbkVTNmgzVUNpQTlvRWhnQk1nRndCellNL2dKMEVlb1JhQkNTQ09pR0FUV3lNL1U2SWdSTUlZQWdEZ29rQTB4c3l3c2tKdllNOVdZQm9CSmZBd2swT25mclo2aGdzeUVYK2djV01zSkJYU0h1QzQ5UHlneVpHcjRZUDFRckdlRUh2QVB3R3ZBbjUwRlVCZndEb0FBUU9rb3o2d1M2QzJZSWlBazhBRVlPb0JRSDFCaG5DbTZNelFFdWlBRzBsZ05Vam9BQ2JJd0dOQWNJQUdRSWhBVjI0Z0FhQXFRSW9BQUNBTXdEVkFBMkFxb0htZ0FXQUlJK0FUb0RKQ3dCSHVJQ2pBT1FDQzdJQVpJc0FmQW1CQmpBREJJQTlEUnVSd0xEcmdLQVoyYWZCZHBWQW9zQ1JqSUJTaUlFQWt0RVRnT3NidDRBMkFCSUJoRGNSQUVTcUVmSUYrQkFBZHhzS0FERUFQZ0FBaklIQWo0QnlnSHdhZ0MwQVZ3TExnbWZzTElCU3VZbUFJQUFFbWdCMUFLR0FOb0FNZ0I4N2dGUUFFb0ZWdllGMEFKTVJnRU9MaFVvVkY0QnVBTWNBVEFCQ2dCMkJzaUtvc1lFSEFScUI5QUNFQmdWM2dMdkt3ZXlBeUxjRThwQ3dnSzkyMUlBTWhNS05RcWtDcU5nV0Ywd0F5NXZQVTBBQ3grbFBzUS9Td1ZPTzFBN1ZUdFFPMVU3VUR0Vk8xQTdWVHRRTzFVRGxMemZ2TjhLYVY5Q1llZ01vdzNSUk1VNlJoUFlZRTVnTHhQRkxiUVV2aFhMSlZNWk9ocTVKd0lsNFZVR0R3RXQwR1l0Q0NrMGNoZTVBRHdwWllNK1k0TWVMUXBJSE9SVGpsVDFMUmdBcmt1Zk02d05xUnNTUkQwRlJIWHFZaWNXQ3dvZkFtUitBbUkvV0Vxc1dEY2RBcUgwQW1pVkFtWUdBcCtCT0JnSUFtWTRBbVlqQkdzRWZBTi9FQU4ranprRE9YUVVPWDg2SUNBQ2JCb0NNak00QndKdHhBSnRxK3lITUdSQ0tBRmtBTnNBM2dCSEFnZVZESW9BK3dpL0FBcXlBbmNzQW5hZlBBSjVTRUFDZUxjYVdkaEZxMGJ3QW53OEFuckZBbjBHQW56dFIvMUllbUFoQUNnU1NWVktXQklVU3NrQzBQNEMwTWxMSkFPSVRBT0g0MFRDa1M4QzhwNWRBQU1EcTB2TFRDb2lBTXhOU1Uyc0FvczhBb3JWdmhnRUdrQmtBclFDampRQ2psazlsSDRDanRZQ2psbDFVYkZUTWdkUzBWU0NBcFA0QXBNSkFPWUFHVlViVmF4VnpRTXNHQ21TZ3pMZWVHTkZPRFlDbDV3Qzc2OVlIcVVBVmlJQ2xvd0Nsbm1aQUtaWnFWb0dma29BT0FLV3NnS1dTMXhCWE00Q21jZ0NtV0ZjeDEwRUZnS2NtRG0vT3BvQ25CTUNuNWdDbnJXSEFCb01MaWNNQXAzdUFwNlBBTEk2WVRGaDdBS2UwQUtnYXdHbUFwNmNIQUtlUzZKanhXUWtJaWdDSjZ3Q0puc0NvUGdDb0VuVUFxWXNBcVhMQXFmOEFIb0NwKzlvZVdpdUFBQkdhaGxxemdLczRBS3Nxd0t0WkFLcy93SlhHZ0pWMlFLeDN0UURIMHRzbEFLeXVnb0NzdVVVYk4xdFlHMUZYQU1seWdLMldUZzhibzBES1VJQ3VGc0N1VVFTQXJrbmRIQXpjTjRDdlJZRExhOERNZzRDdm9WeC93TXpiZ0srRjNNZmMwd0N3OGdDd3dGemYzUklNa0owM1FNOHBBTThsd005dkFMRmVRTEdSQUxHRFlZQ3lHWk9Bc2hCQXNsTUFza3JBbVNhQXQzUGVIWmVlS3Q1SWt2TkF4aWdadjhDWWZFWjhKVWhld2hlajE2NERnTFBhQUxQYVN4SVVNL3dFSndBdzZvQ3ozQUJKdWNEVGc5K1NBSUMzQ1FDMjRjQzBrd0RVbGtEVTF3QS9nTlZpWUNHUE1nVDZsMUNjb0xMZzRvQzJzUUMyZHVFRFlSR3B6a0RocUlBTEFOa0M0WnVWdllBVWdMZllnTGV0WEIwQXVJczdSRUI4eTBrQWZTWUFmTFBoQUxyOEFMcGJYWUM2dllDNnVFQTlrUUJ0Z0x1aGdMcm1aYW5sd0FDN2p3RGhkMllkbkRkY1o0Qzh3QUFaZ09PRTVtUUF2Y1FBNUZyQTVLRUF2ZVZBdm5XQXZoam1obWFxTGcwbXhzRG5ZQUMvdmNCR0FBMm54bWZzQU1GaWdPbVp3T20xZ0RPd2dNR1o2R0ZvZ0lHQXd4R0FRd0JIQWRxQmw2MlpBSUF1QVJvdkE2SUhyQUtBQlJ5TmdBZ0F6QVNTZ09HZkFGZ0pCNEFqT3dBSGdEbW9BU2NqZ2kwQmh5Z3dnQ29CUks4Nmg0K1B4WjVCV2s0UDBFc1FpSkN0Vjl5RWwrOUFKYkdCVE1Ba0UwYW03bzdKMkF6RXJyUURqQVl4eGlLeWZjRldBVlpCVmdGV1FWa0JWa0ZXQVZaQlZnRldRVllCVmtGV0FWWlJ4WUkySVpvQXdNRENtVmU2aXdFeWdPeUJqQzh2QUM4QktpOEFPaEJLaGF6QlVjK2FqNXhRa0JDdDE5Mk9GL3BBRmdTTTZ3QWpQL01iTXY5cHVoR2V6NG5KQVVzRnlnM05uNXUzMnZCOGhuRExHb0JiTmR2TVJnRllBVnJ5Y0xKdVFqUVNsd0JBUUVLZlY1K2pMOEFORCtDQUFRVzBnYm1yaVFHQUl6RURBTUNEZ0RsWmg0K0pTQkxRckpDdlVJNUpGOG9ZRGNvT1NRSndqNEtSVDlFUG5rK2dqNXhQbklDaWtLOVNrTThYOHhQVUd0T0N5MXNWVEJyREc4Z1grRTBPeHdKYUp3S1l5UXNQUjRuUXF4Q3ZTek1Bc3Y5WDhvUElDOEtDUW9BQUNOK250OXJPeTVMR01tc3lhMEpac0xNelFwaFFXQVA1aENrRWdDVGpoNUdRaVlicW0wNnpqa0tORDlFUG5GQ1FCd0lDeDVOU0cxY0xTNWE0cndUQ243dUhpeENRQnhlQ1VzS0R6UlZSRU00QlR0RW5DMEtnaHd1UWtBYjlnbFVJeVFaTVRJQkJvOWk4RjhLY21US1lBeGdMaVJ2QUVSZ0dqb0RIQjlndEFjRGJCRm1UMkJPRWdJQVpPaGdGbUNXWUg1Z3RHQk1ZSkpwRmhnR3RnL2NWcXE4V3d0REY2d0J2Q3pPd2dNZ0ZnRWRCQjhCZWdKdE1ER1dVNEVCaXdxNVNCc0E1U1Iwand2TERxZE42d0djQW9pZFVBVkJZQUQ0QUQ0TEFUVVhXSHNNcGcwbElMdXdTQUJRRFRVQUZoTzROVlVDMHd4TFpoRWNBTmxQQm5ZRUN4OWJBRElBdHdLYktBc1djS3d6T2FBYUFWd0Jod245QTlydUVBYXJCa3NHdWdBZXkxYXFXd3E3WWhPS0N5MUFEcndCdkFFakEwaGJLU2twSVI4Z0lpMFRKd2NpRFk0QVZRSnZXSkZLbGdKdklBOXlTQUhVZFJEUFVpRWFxckZONndjU0JVMWdBUGdBUGdzQmV3QUhKVzBMaUF5bU9URXV5TEJYRGd3QVlMME1BR1JLYUZBaUloekFBRElBdHdLYktDMDhEODhDa1JoOFVMeFl5WFJ6anRpbG5BNzJtaFUrRyswUzJoSUhEeHdCeUFrN0VKUUdFU3dOTnd3QVBBQzB6d0VEQUtVQTRnQ2JpekFBRlFCY0c4Y3ZiWGNyRHNJUkF6d2xSTlRpSFI4TUczNENmQVRDQzZ2eGJRQTRPaTRPcHprdXo2SWRCN3dLQUJBN0xzOFNHZ0I5ck5zZEQ3d2JTQnpPb25jZkFUNHFZQjBDN0tBSkJFM3o1UjltREwwTSt3ZzlDajhBQmNFTFBnSk1EYndJdlEwOUNUMEt2UzdQb2lzT3ZBYVlBaHdQakJyaUJCd0x2Qlk4QUtFTFBCQzhCUmloZTkwQU8yd01QUUFDcHdtOUJSelI5UVlGQjIvTEJud0FCN3dTWEJJU3ZRRUNBT3NDQUFCMUZWd0hGc3dWL0hBWHZCZzhBQzY4QXV5b3ZBQWV2QUpXSVN1QUFBRzhBQUxrRlQwVnZDdnNvN3pKcUR3RUFwOG5UQUFDWEFEbjNobThDYVZjRDcvRkFQVWFmQWlpQlF2L2NRRGZ2S2U4R053YXZLT01lWE1HL0ttY2hBQVN2QWNiREFBRGxBQnR2QWNBQzd5blBBSWFQTHNJb3B6TER2d0h3YWs4QU9GOEw3ZHR2d05KQUFQc0FCVzhBQWI4QUFtOEFHbU1BQnE4QUE2OEF4aThqbW9WL0FBQlhBQU9iQUF1VEI4QUJyd0FGN3dJSWdBTlN3QzZ2Q2NBQTd3QURwd3E3QUN5V3dBY0hBQWJ2QUFCN0FxaUFBWEhDeFlWM0FBSG5BQkN2QUVEQUdtOEFBdDhBQjI4QUFpOENhSUFCY3NBYnFBWjFnQ1NDQ0lBQmNzQUFUd0FCOXdBSFp3SUlnQUdtd0FKZkFBYkxBQnRIQURtdklFQUNGd0FDRHdBRkx3QWFQd0pJZ0FHeXdEampBQUpQQXVpRHNYN1lBQUhQQUJ1blVCSkFFZ0FDcndGQUFNOEFBbXVBemdBQnh3QUdYd0FBZ3ltL0FBS0hBQUtQQUFKL0tmc0Jyd0FDUndBQXd3QUVEd0JBQlE4QUJGc0FBK01BQTNzQUEyOEFCa01CeFljQUJVOEFHNmNGclFCdkFDN0FCTThCQUJwTEFzQTRVd0FBandBQkZNQUYzd0ZIQUFHMFFBWXZCOEJmQ2xUQURwR0FMQUpCdzRNY3dBcEszRUJwUVlJWHdKdEpBMEFDZ2h3VEcxZ0s0b2dnUlZqTGpjRG9ncTFBQUxaQUJjQy9BUnZBWGR6U0ZNVklnTlFBaFkvQVMwR0JIUkh2bnhUZTBFQUtnQXlBdndBVkF2Y0FIeVJMUUVzQUhmbURoSXpSd0pMQUZnR0FBSlJBUWlMelFCNVBBUWhwZ0JiQU5jV0FKWnBPQ0NNQU01c3NnRFExUmNKdzNaMEhCbFhIZ3JTQVltUnJDTlVWRTVKRXozRGl2b0FnQjA0UVNvczRSS1lVQUJ6QVNvc01TbERHaEFETVZZRStNYnZBRXhtM1FCckFuSUNRQkY3T3NoNEx6WFdCaEVUSUFVVkNLNnYveFBOQUNZQUFRSWJBSVlBaVFDT05nRGpBTFFBMVFDZFBRQzdBS3NBcGdDaEFPY0Fud0RUQUp3QTRBRUJBUHdBd0FCNkFGc0F5d0ROQVB3QTF3RHJBSWtBb2dFcUFPTUEyQURWQkFJSUt6VFQwOVBUdGIvYnpNL05RakVXQVVzQlZTNUdBVk1CWWdGaEFWUUJSVXBDUkdjTUFVd1VCZ2tFTXpjTUJ3QWdEU1FtS0NzM09UazhQRHc5UGcwL0hWQlFVRkJTVWxGU0tGTlVWbFZWSEZ4Z1lGOWhZQ05sWjI5dWNYRnhjWEZ4YzNOemMzTnpjM056YzNOMWRYWjFkRnNBUGVzQVFnQ1RBSEVBS3dCZjhRQ0hBRkFBVUFBd0FtL29BSVQrOGZFQVhRQ002d0NZQUVnQVd3QmQrUGlwQUg0QWZnQmlBRThBcWdBZEFLOEFmQUk1QWp3QTlRRGdBUGNBOXdEaEFQZ0E0Z0RpQU9FQTN3QW9BblFCU2dFNUFUY0JUUUUzQVRjQk53RXlBVEVCTVFFeEFSVUJVUkFBS2drQkFFd1lDeGNFRmhjUEFJY0Fqd0NmQUVvQVl4a0NLZ0J2QUdnQWtBTU9BeUFyQXhwQ1AwZ3FBSW9DU0FEQUFsQUNuUUM1QW84Q2p3S1BBbzhDandLUEFvUUNqd0tQQW84Q2p3S1BBbzhDamdLT0FwRUNtUUtRQW84Q2p3S05BbzBDalFLTkFvc0NqZ0p1QWMwQ2tBS1lBbzhDandLT0Yzb01BUGNHQTVnQ1dnSXpHQUZORVRZQzJ4SUxMQlFCUnpnVVRwSUJkS1U5QVdKYUFQNERPa2dBL3dDU0toNFprR3NBS21FQWFnQXZBSW9EbGN5TThLK0ZXd2E3TEEvREVnS2UxblVyQ3dRa1d3R3pBTjUvZ1lCL2dYK0NnNE4vaEllRmY0YUpoNEdJZzRtRGluK0xmNHgvall1T2Y0OS9rSU9SZjVKL2szK1VmNVdFbG9tWGc1aC9BSU1sb1FDRUJEd0VPUVE3QkQ0RVBBUkNCRDhFT2dSQUJFSUVRUVE5QkQ4RVFnQ2tBNGdBeWxJQTBBSU5BUGRiQVBjQkdnRDNBUFVBOVFEMkFQWFZoU1JtdndEM0FQVUE5UUQyQVBVZEFJcGJBUGNBaWdFYUFQY0FpZ0x0QVBjQWl0V0ZKR2EvSFFENFd3RWFBUGNBOXdEMUFQVUE5Z0QxQVBnQTlRRDFBUFlBOWRXRkpHYS9IUUNLV3dFYUFQY0FpZ0QzQUlvQzdRRDNBSXJWaFNSbXZ4MENSQUUzQWtzQk9nSk13Z09mQXUwRG45V0ZKR2EvSFFDS1d3RWFBNThBaWdPZkFJb0M3UU9mQUlyVmhTUm12eDBFTVFDS0JESUFpZ2VPTW00aExRQ0tBVDl2QkNRQS9nREhXd01BVlZ2L0ZETURBSW9EUHRrQVNnTUFpZ01BbDJkQnR2L1RyZkx6YWthUGgzYXp0bUl1WlFyUjNFUjJuNVlvK3FOUjJqSy9hUC9WMDRVSzFuaklKWExna2FiOVBqT3h5SkRWYklOM1IvRlpMb1pWbDJrWUZRSVo3VjZMcFJxR0R0OU9kRG9obkpLcDV5WC9ITGowdm9QcExybmVEYU4xMXQ1VzNzU000QUxzY2dTdzhmeVdMVmtLYS9jTmNRbWpZT2dUTFpVZ09MaTJGMDVnNFRSMFJmZ1o0UEJkbnR4ZFYzcXZkeFF0OERlYU1NZ2pKTWd3VXhZTjN0VU5wVU54MjFBdndBRERBSWEwK3JhVFdhb0JYbVNoQWw1QVRocE1pMjgybytXek9LTWx4akhqN2ErREk2QU02Vkk5dyt4eWgzRXlnLzFYdlBtYnFqZWcyTUdYdWdIdDh3VzAzRFFNUlRkNWlxcU9oakx2eU9DY0t0VmlHd0FIVkx5bDg2S3F2eFZYN014U1c4SExxNktDckxwQjhTc3BBT0hPOUl1T3dDaDlwb0xvTUVoYTlDSEN4bFJBWEpORG9iZHVjV2pxaEZIcUNrempUTTJWOUNIc2x3cTRpVTE5SXhxaElGWk12ZTE1bERUaU1WWklQZEFEWEd4VHF6U1R2MGREV3lrMWh0NDMweXZhWUN5OXFZME1RM2NDNWMxdXc0bUhjVEdrTUhUQUdDOTlUa05YRkFpTFFndzlaV2h3S0pqR0NlK0o1RklhTXBZaGh5VW5FZ2ZyRjN6RXR6bjQwRGRnQ0lKVUpmWjBtbzNlWHNEd25lSjhBWUNyN1Z4MmVIRm50Mkg2WkV5QUhzOUpvUTRMemg1ekJvR09Hd0F6MzdOT1B1cVNObVpmNTFoQkVvdnRwbTJUMXdJNzlPQldEeXZDRllrT05xQUtHVllnSUwwRit1eFRjTUxTUHRGYmlORGJCUEZnaXA4TUdEbUxMSGJTeUdYZENNTzZmN3RlaVc5RUVtb3JaKzc1S3phblp3dlV5U2dqb1VRQlRmSGxPSWVySnM2WTl3TGxnRHcxOEFCMW5lMHRaUk5nR2pjcnFIYnR1YlNVb29FcHk0aFdwRHpUU3JtdnF3MEg5QW9YUUxvbE10OWVPTStsOVJpdEJCMU9CbnJkQzFYTDR5TEZ5WHFaU2daaHY3Rm5uREVYTFVlZmZiNG5WRHFZVExZNlg3Z0hWYUs0WlpsZXBqYTJPZTZPaExESS9WZTVTUVRDbUpkSDNISmViMTRjdzk5WHNCUUFsRHk1czVraWwyc0dlelpBM3RGb2sySXNOamE3UXVGZ00zMEhmZjNOR1NzU1ZGWVpMT2NUQk92bFB4OHZMaGpKclNJN3hyTk1BL0JPenBCSUpyZFIxK3Yrenc0Ulo3cnk2YXE0L3RGZnZQUXhRQ1BEc1hsY1J2SVpZbCtFNWcza0orekxNWm9uMHlFbEJ2RU9RVGg2U2FBZElPNkJ3ZHFKcWZ2Z1UrZThZNjVGUWhkaUhrWk1WdDkvMzlOMmpHZDI2SjZjTmpxOGNRSXlwNlJvblJQZ1ZuMmZsODl1UkRjUTI3R2FjYU4wTVByY055UmxiVVdlbEtmRGZ5ck5WVkdCRzVzamQzalh6VHgwNnl3eXp1V241amJ2RWZQUENUYnBDbGtnRXU5b1BMS0lDeFU1SHVEZTNqQTFYbnZVODVJWVloYUV0T1UxWVZXWWhFRnNhNC9UUWozckhkc1UyZGEyZVZiRjhZalNJMG02MTkvOGJMTVp1M3hpbGR3cU03emYxY2puNFdoeDBQU1lYY1k1YlI3d0VRZkdDN0NUT1h3WmRtc2RUTzhxM3VHbTdSaC9SZkNXd3B6QkhDQWFWZmp4Z2liTDV2VWVMMHBINmJ6RG1JOXlDWEtDL29ra21iYzI4T0p2STg3TC9iakZ6cHEwREhlcHc0a1QxT2QrZkw3Y3l1RmFSZ2ZhVVdCMisrVENGdnoxMUowbGVFdHJHa3BjY2ZYOXoyTFkzOXNwaDRQQkhDak5PT2tkMHliVW0rWnpTOEdrRmJxTXBxOHVpWDJ5SHBhMGpsbFRMZkdUREJNWVI2RlQ1RldMTERQTWtZeHQxUTBleU12eEpXenREankwbTZWdlpQdmFtckZYakhtUHBVNld4clpxSDZXVy8vSTM3Und2cVBRaFB6OEkzUlB1WEFrMUM5NFpwclFXbTlpR00vS2dpR0RPNlNWOXNqcCtKbWs0VEJhak1OSjV6eldaMWsxanJ0ZVFRQnA5QzJkT3ZtYkllZUVNRTh5NTczUThUZ0dlK1pDenV0TTQ1Z1lMQnpZbTJMTnZncTJrZWJBYk1wSFJEU3loNmRRMjdHYnNBQWRDcVFWVlhXQzFDK3pwd0JNMkxyNGVxdG9ibW11MXZKRURsSVFSMWlOOENVV3B6dHE1MHo3RkZRQm4zU0tWaVg2d1NxelZRQ29ZdkFqQnlqZVNhK2gxUFJuWVd2QmluVERCOWNIdDRlcURzUFM0amNEM0Z3WEpLVDBSUXNsOEV2c2xJMlNGYXoyT3RtWUxGVjhGd2d2V3JvWjNmS21oN2J0ZXdYOXRmTDJ1cFhzcnNxcExKenB6Tkd5TmxudVp5ZXRnN0RJT3hRVE1CUjdkcWxyVGxaNkZXaTFnNGoxTlNqQTJqMVlkN2Z6VEg2azlMeEN5VUNuZUFLWUNVNTgxYm52S2loNktKVGVUZUNYNFpobWUvUUl6N3cybytBZFNndExBa2RyTFM5bmZ3ZVlFcXJNTHNyR0dTV1h0Z1dhbUFXcDYreDZHTS9aOGpOdzNCcVBOUTM5aHJ6WUxFQ24zdFB2aC9McUtiUlNDaURHYXVES0JCai9rR2Jwbk0xQmIvbXk4aHY0TldTdGNsa3dqZmw1N3k0b05EZ3cxSkFHOVZPdGkzUVZWb1N6aU1Fc1NkZkVqYUNQSURiN1NncExYeWtRc00rbmJxYnQ5N0kwbUlseld2MHVxRm9iTE1BcThSZDlwc3pVQkt4RmhCUHdPamYvL2dWT3oycjdVUkoyT25wdmlDWHY5aXozYTRYL1lMQlliWG9Zd3hCdi9LcTBhNXM0dXRRSHpvVGVySjdQbUZXL25vL1pBc2lkL2hSSVY4MnREK1FhYmg1RjFzc0lNOFJpM2NodTBQdVBEM3NTSlJNakRveExBYndVYnJvaVBBei9WNTJlOHMzRElpeHhsTzdPcnZoTWozcWZ6QTBrS3h6d2ljcjV3Sm1ad0p4VFhncndZc3FoUnZwZ0MyTmZkeWQrVFlZeEpTWmdrK2drMmc5S3lIU2x3UVZBeVB0V1dndlZHeVZCcXNVMkxwRGxMTm9zU0F0b2xDMXVCS3Q1cFFaTGhBeFRqZUdDV0lDL0hWcGFnYzVyUndrZ3BDSEtFc2pBOGQrc2NwOGFpTWV3d1FCaHA1ZFlUVjV0L052bCtIYkRNdThGM1MwcHNQeVpiMWJTbnFsSFBGVW5NUWVRcVNxd0RCVDIzZkpPOWdPM2FWYWExaWNyWFUwUEt3bE1NNUsraUwzQVRjVnEyZkZXS2swaXJDVEY0TERWREc0Z1Vwa3lwbHE2ZWZjWlMrV0RSMXdvQXBqRDE4eCsySlFSOW9PWHp1QTd1eTRiKy85MVdzSmQvdFNkMVFjQUg4UFZQWEFwaWVBMzdCN1lYUGhEUEgxYXpQM1BLUitIZkhtT29EWUxldUtzSWkvc3NTc2RZczYycUpvMTRIdzFQMk4vNnpwcjhGM0ZUV21KNHlzQVZjbDg0SXYvdGwvLy9aOEZhQVdiQlFieU1ORFpqcloySndkUmp0ZDFqT2VOdW1Tb2RGdHI0L1pmNDVpUkpmLzhIU1crS0lCLytHbEt1OFJ2MUJQTHIvNGR1b0wra0ZQUnFyc3RFcjQxZ2ZKdXBvSlJmNGhjWURXWDkzRk9jZkVCaUlpdnh0anRWOGc3bXZPUmVpYW1ZV0tFN3ZmUGJ2M3YyTDlLd3EzY0lERkdMeWh5Zk9HdWYvOXZBNW11SDZQamc3QjRTVWoyeWREWHJhOWZTQkkrRHJzTkhBNmw1MXdmSHNzSmIrMTFUZk5rN0I4T2xlVWUzWStabUhib01GSGR2N0ZGUDJjZklTRnllQVFSMHNrL1h2NjJIQlRkVzRIbW5HU0xGay9jcXlXVlZGSmtkSUlhKzRob3MzSlJIY3FMb1JLTTVoMlF0azFSWnR6SVNNdGxYVGZUcUljNzdZc0NDZ1FEMHI2MWp0eHNrQ2N0d0pPdGpFL3BMOHdDNExCRDRBWkZqaDJ3enpGQ3JUL1BOcVcwL0RlQmJrZk1melZtOXl5MDZXaUYrMW1UZE5ORUF5dFZ0b2hCS2czYnJXZDJWUWErYUYrY1EwbVc1Q3Zid09sV0NUMDdsaVgyMjZQamlWTHdGQ1JzL0F4Mi91K1pOUGpyTkZJV0lQZjVHakh5VUtwNjBPZVhlOUYwMWY3SWFQZi9TRFR2eURBZjdMU1dXZWp0aVpjc3F0V1pqcmRuNkEyTXFCd25TZUtoclpPbFVNbWdNaW9ubWlDSXZYcUtaZm1oR1oxTXdEM3VNRjRuOUtKY2ZXTEEzY0w1cHE0OHRtNU5EWU5oM1NTL1RLVXRtRlNsUVI4OU1SNCtreGNxSmdwR2JobTlnWG5lREVMa3lxQU41bml0bUl6VHNjS2VKUlhxZDY0UmlhT0FMUjJkMjk1Tld3YmpIUk5HMkFVNW9SOU9TMm9KZy81Q1k2QkZQYzFKdkQyTXhkaHAyL01aZEk4ZExlUHhpUDRLUklwOFZYbXFmZytqcWQvUk5HN0dOdXExVTJTaUk0NzM1QmRjME1WRng2bUg1VU9XRWE1SHVoWXlrZDZ0NE0xZ1lMVlM4bTFCKzliVXFpNUR6aVFxN3FUOGQ5NGN4QjZBQjRXcU1DT0YvelBQdFJTWlVVYU1Tc3ZIT1d4R0FTdWZ5d1RYOG9neTZIZ1VmOXArWjMwd1VFb3NsOHFnbXdtNm8yQVY2bk85SEtRalJIcE42U1VlZ0k1cHZSNjFSTG5VSjFscUN0bWZjc1JRdXRFaXpWcEFhUFhON3hNcDVVUTVPU1pLNnRuaUNLOUNweU1kN0xqUjYrTXhmb01FRFBwV2RmMnAybTVOM0tPNFFNeGYrVjd2R2RZamVtUWN6USttMk1HSWtGTllETWYwWW9wMmVTeDgxc1AzNldIVWN6cUVoS3lzcDJpSlNZQXZmZ0pqaW5Ld1RvUHZSS2IrSEJpKzdjSjk2UzVuZ2ZMT1hhSEFGUkxrdWxvNFRuWFRGTzUxZ1gwVENDbzRaVUhkYnBkZ2tNRXdVWkFQamg2TStoQThEenljYnR4QWdIM3VENmkwbk4xYVRpSXVRNEJZQ0U5ZEVISHdBbUlOVSs0WUVXeDRFQzNPWndGR2ZZWk1QTFNjVmxiK0JBQUplQVJVaCtnZFdBMy9nUnFDcmYxamVjZ3FlRmYxTWR6cnJQNFNWbEdtNW1NaWhTUCt6WVlrc0FCN08rU0JQd05RcVNOTWlMbmt2aVkva2x3Z2NSbXZxdENxZVdlQTBnanVpcjRDTVpxbXcvbnRQNk0rbDBwZE44L1A5eEk1M2FQN3gvemF2SmJiS096OFZ6Ty9uWHhJcjF0anBhck1ucWQ2aVdkQnlIS3c0bEY0cC91NTdZdjA3V2VaUERuUmw3d2dtRFZaWjQ0ZlFzamRZTy9nbVhRKzk0MFBSR3N0OFVNUUFwRkM0T09WMjJlNE4rbFZPUHlGTEFPajR0OFIzUEZ3L0ZqYlNXeTBFTHVBRlJlTmtlZThPUmNCT1QyTlBEY3M3T2ZwVW16dm4vRjlDems5bzluYU15Vll5L2o4STVxVkZtUURGY3B0QnA2NUovK3NKQTN3L2o2eS9lcVVrS3hUc2YwQ1pqdE5kUlNCRW1KMnRtZmdtSmJxcGNzU2FnaytVbDlxZHlWK05ucUZCSUpaRkNCMVh3UHZXR0RCT2pWVW1wV0dIc1dBNXVEdU1nTFVOS1o0dmxxNXFmelkxTG5SaENjL21oNS9FWCtoenVHZER5NWFZWXg0QkFkd1RUZVpIY1pwbDNYMFl5dXhaRldORTZ3Rk5wcFlzM0xjRkplUE95ZktaOEtZYjdkbVJ5dkRPY09STFBIMHN5dEM2bUgxVVMzSlZqNnBhWU0xR0VyK0NVbXlIUm5hYkhQcUxsaDZLbDAvQldkM2ViemlEZnZwUlFwUG9SN04rTGtVZVlXdFE2Um41djUrTnROZUJQczIrREtEbHpFVlI1YVliVFZQclpla0pzWjlVQzlxdFZjUDk5dGhWSXQxR1JFbk44elhQOG1CZnpTK3dLWXltOGZjVzZLcXJFNzAyWmNvK2hGUUFFSVI3cWltbzdkZDd3TzhCN1IrUVpQVHVDV20xVUF3YmxEVHlVUlNiZDg1UDRQeit3QnBReUdQZUVwc0V2eHhJWmtLc3lmU09VY2ZFM1Vxek1Gd1pLWWlqYjdzT2t6cG91K3RDNGJQWGV5NUdJMUdVQWc5YzN2THdJd0FoY2RQSFJzWXZwQWZ6a1pIV1kyMHZXeHhKTzBsdktmajZzRzJnL3BKMXZkL1gyRUJaa3lFakxONG5VWk9wT083TWV3eUhDcnhRSzhkNWFGN3JDZVFsRlgrWGtzSzZsNno5NzFCUHVKcXdkamo2OFVMT2o5WlREZE9Mb3BNZE9MTDBQRlNTNzkyU1hFL0VDOUVEbklYWkdZaHI1MmFRYis5YjJ6RWRCU25wa3hBZEJVa3dKRHFHQ3Baay9Ia1JpZGpkcDB6S3YvQ201MkVlbm1mZUtYNkhrTFVKZ01iVFR4eElaa0llTC82eHVBYUFBSGJBN21PTlZkdVRITlgvVUpqMW5KRWFJN2YzSGxVeWlxS243VmZCRStiZGI0SFdsbjFIUEp4MDAxVWxxMXRPeEZmOFdaRUFSdnE1RGExK3BFN2ZQVnhMbnRHQUN6M25rb0xzS2NQZFVxZEN3d2l5V2ttWFRkNStidjNqN0hhUmVSdDNFU243ODNFdzNTV3N2a0VqS3Rib2NOa3NickxtVitHVlpuMStVbmVvMzVNVDEvNHI4Zm5nUVg1L3B0T1JmZ21XZkY2S1NCL3NzSm1VU2lqWHhRcVVwemtBTkVrU2tZZ1lqNTYwT09qSnI2dXFja0Z1TzE1VFJOZ0FCRXdORGp1czFWM3EyaHVMUFlFUk1DTFhVTm1KSnBiTXJVUXNTTzdRbnh0YTU1VHZQV0w2Z1dtTU92RmtucUVUenF6RlZPOFNWa292RWRZYXR5cExHbUR5OVZXZmdBYzBLeUlDaGlPaGJkN1VsYkFlVkxQWnlFRHA0UE9YS0J3Ti9LUDVwVDZDeXFzNnlhSTAwdlhNbjF1Yms5T1dUOVEvTzJ0L0MyNXFsbk8vek8weGNCenBNQkNBQjh2c2RzaDNVOGZuUFgxWGxQRVdmYVlKeEtWYVRVZ2ZDRVNXbDRDQ2tJeWpFNmlRNUpGY3dVNlM0L0lIMC9BZ2FjcDhkNUd6cTIrR3pQbko3K3NxazQwbWZGUXBLckRiQUt3TGxyM09ORWF0aTJrL3ljTE1TVXU3Vi83QkJrRGxOeVhvTjl0dnFYQ2JiTWM0U1NRWGdDL0RCVVk5UWp0ckN0UStzdXNFb21DcTh4Y05KTk5NV0NIMzFHdGxUdzJCZENYa0pCalQrL1FOV2xCV3dRNVNXQ2gxTGRROTlRVmlpL0R5VHhqU1I2cm1kYXAzbDNMM2FpcGxRcFBZbHJ6Tm05ZXI4OGZYZDIrYW8rWWRVTmp0cW14aVZ4bXlZUHpKeGw2N09va0RjVGV6RUdxbGRrR2dQYlJkWEErZkdjdVpWa2VtYlpCeW83SjFkTW5rR05qd3dDbnkrRk5jVmNXdldZTDltZzhvRjdqQUNWV0kzYkE2NEVYcGRNOGJTSUVWSUFzNUpKSCtMSFhnbkNzZ2NNR1BaeUFBVkJuY3ZiTGlleHpnOVlvemN5dGpQWFZsQWJRQUM3VGM0UzBDOFFONExsQUdqajRwUUFWV3J3a2FEb1VZR3h4dmtDV0tSUkhrZHpKQjV6cFJFbGVCREwxb0RLRXZBcW1rRGliVkM0a1RxRjg5WU82bGFVamd0SlBlYkJmenIxNnRnNHQxMEdtTjFzSjV2ZXprMnNVT3E4YmxDbjVtUFp5VDNsdGFEY2RkS3VwUWpxdXNOTTl3dEZWRDBBQnp2MTdmWkRuN0dQVDFua0N0ZGNnWWVqY0sxcU9jVEd0UHhuQ1gxckVyRWpWV0NuRUp2NUhhT0FVamdwaUtRalVLa1FpNjRENWcyQ09nd2FzOEZjZ0lsMFB3OTVIOWRXeEUzUUcwVmJNTmZmaDZCUGxBb2pMRGY0ZXMyLzVYZnE3aHc1TkdjT04yZzhRc3kyVVFtOTRLZGRLeXkza2RKeFdncE5hRWMxNXhjeWxiTEMzdm5UMjZ1OHFTOTBxYzJNVThMZE9KYzVWUEY1S25TcFhJaG5qMWVKSi9qc3pqWjAxb1I2SkRGSlJvZVRQTy93aDRJUEZiZEc5S2xqdVN6ZXVJOTJwOEpGL2JwZ0RFOHdHODYvVzJFQktnUHJtemRMaWp4c3NRbjhtTTQ0a3kvS0xHT0pjclN3WElwWmEvWjN2N1c2SENSazdld2RzOTlMVHNVVzFMYmVKeXR3OFEvQkZaVlp5Zk85QlVIT0NlMnN1dUVrTzhEVTRmTFgwSVFTUTJUZE9rS1hEdFBmM3NOVjl0WWhZRnVldVBSaGZRbEVFeSthWU0vTUN6N2RpRE5tRlNzd1lZbFpaUG1LcjJRNUF4THNTVkVxcUJ0bjZoVmwxQkNGT0ZFeG5xbklzbXlZL05BOGpYbkRhTnpyN1p2M2h1K0kxTWYvUEpqazBnQUxOMkc4QUJ6ZGY5Rk52V0h2WkhodjZ4SW9EQ1hmOTY0TXhHOTJ2R1p0eC9MWVU1UGVacWdseTh0VDV0R2VRR2VKek1Nc0pjNXArYTVSbjJQdEVoaVJ6by81T3dqeTFuMEx6eDNldjhHSFFtZVdiOHZhZ0c2TzVRazVuclp1UVRpS09ESTRVcUwwTExBdXNTMlZlN2oxSXZkeHF1dTFCUjlSYzRRa09pVVB3UVhKdjZkdTJFOGk1cERoVm9RcFVoeU1XR1VUMk8yWU9ESWhqQWZJNzFneGVwNXI1ekFZN0dCVVpweTUxaEF3MHBjQ0NyaE9tVThXcDZ1alFUZFpRc0NqdHE2U0hYOFFBTU5pUENJSWtveGhIRVpQZ3NCY09sUDRhRXJKWlBoRjdxdng2Z0hybjhoRXdQd1lieDhZbVQvbjdsYmNtVGlwMXY4a2dzcklqRlRBbHZMWTROdWlsMEtEbWd6M3N2WXMwWkozTzNJcy92U3g0eHB4RjFlMlZBdFpFOGRKeEdZRUloQ1N1UHZDalA1NGwvTlNORG53bEt2QVc4bUcrQVFrZ3A3YTg3SWdoMjZ1S01GR0QwUG9QSFRTdm9XeGlIdWsrc3U4WGtRaUhJamVZS2wvUmRjT0hweGhRSDN6SENORTNhQVJtODNCbDZ6R3hVL3ZNbHRsVlBRaHViY3FoVzRSWWtsNnVYazVKZFAvUXB6YUtGcHcyTTh6dnlzdjJxajd4YVFFQ3V1MmFrTTBDc3NqL3VCOSt3RFI3dUE2WE9uTE5hb2N6YWxIb01qMzNlaWl1K0RSYUZzVW1sbVVadWg5YmpEWTRJTk1OU1NBaXZTaDAzdUp2bnk0R2orRCtuZXVkb2E3aUppN2M0VkZsWi9KNWdVUjgyMzA4elNOQXQvWnJvQlhEV3cwZlYzZVZQQW4zYVgwbXRKYWJGNlJzVVptTCtFaG4rd241MS80UWlwTWpEKzZ5NjR0N2JqTDZiakVOYW4ycHJRNGg3KytoQko5Tlh2WDhDVW9jSnFNQzkzN0lhc0x6bTVLMHF3WGVGTUFpbU1Ia0VJUUlRSTJMclE5c0xCZlh1eXA2NnpXdmxzaDc0R1B2N1hwYWJqOTkzcFJOTkR1RnVkNW9JY24vOTJpc2JBRFhkcFJQYmptYkNOT3J3UmJ4R1p4MlhtWU5HTWlWNWtqRjRJS3l4Q0J2S2llcjlVNHVWb2hlQ2RtazgzcnA1RzBQaWhBbTJmQXRjekk0YjlCV3FYK25yWlRySlg1a1N3UWRkaTkzTlFyWEcrQ2wzZUJHTmtNNzdWQnNNcEVvbGhYZXgxTVZ2TWtaTjlmRzU5R0diY2lIMTFGRVhhWTFNeHJBcm92YVNqRS9sVVVxQmcyY1pCTm1pV2J2ekNIQ1BKNFJWR0ZLMmRUYk9iTTFtK2dKeUVYNTNmYTd1MytUWnBtNzRtTkV6V2JrVkw0dmpOd2ZMOXV6UkN1MWNnYnJOeDVZdjVkRHJ1TnJJT2d3SWsrVVpXd0pmZGJ1L1dIdWw2UE1tUmZsVkNJemQ3QjM3UGdtL1VwL051Q2lRVzdSWHlhZmV2TjNBTDZ5Y2NpQ2M0WlBsVFJ6RXUrYVVSR2xVQk9KYlVFc2hlWDdQUHlycmhkVXQ1SkFHMTJFRUVacFkvTjNWaGJsNXVMQWZUMENiQzJYbXBucnlGa3habUJUczVwcnZFZXVmMGJuNzNpM084MldUaVF0SldFUExzQlhuUW1kbktoQjA2TmJiaEx0bFRaWUpNeERNSnBGZWFqU05SREIydjYxQk1VSHFYZ2dVd1JKMTltNnA1emw1MXYxMXEzNFQ3NGxUWGRKVVJ1VjYrYmcyRDZxcGZHbkx5N0tHTHVMWm5nb2JNNHBJb3V6NCtuMC9VekZLeERnTE00aCtmVXdLWm96UTlVR3JIamNpZjUxUnVvbno3b0lWWjU2eFd0WlM4ejd1NXpheTZKMkxENGdDWWgyUlhvQlJMREtzVWxaODBSOGttb3hsSmlMOGFaQ3kyd0NBb25udWNGeENMVDFIS29NaGJQS3QzNEQ5N0VYUFBoMGpvTzkzaUpWRjFVcnVldzYxUW95M1pVVk5YOXVJSkR0OUFRV0tMTG8rbVN6bVRpYnlMSHEwRDZoaHpwdmdVZ0k2ZWt5VkVMM0ZEK0ZpNVIzQThNUkhQWHNwTjFWeUtrZlJsQytPR2lOZ1BDNE5SRVpwRkVUZ1ZtZFhyUTJUeENodVMzYVkrTmRjN0NpWXY1K0NtemZpcWVacldJUUpXL0M0UnZqYkdVb0pGZjFLNlpkUjJ4TC9iRzRrVnExK0k0alFXWCsyNllVaWpwcCtscE43bzVjNlpvZFhKQ0Y1NlVrRkdzcXo0NHNJZzhqcmRXdmJqUkN4aTJCazBpeU0zYTdlY0FWOTN6QjZoMUVpMzhjMHM2KzhucmJrb3BBcmNjR1A4dm50UWUxYkZlRWgybkpJRk9IWC9rMy9VSGI1UHRLR3BuemJrbW5SRVRNWCs5WC9RZHVMWld3L2Zla2xXL2tIL0puelRvSmU5S2d1OUhjdDFVR2JINUJQQ0xvNE9PdFFuWm9uVzB4bnlDY2R0S3lQUS9zYkxpU1RZSmRTeDRzSnFXTE1uZm42ZklxUEIzV0FnazAwSitmQ09rb21QSHF0UzY3cGYwbUZtS29JdFlaVWxKdTZCaWhTWjhxdmU4Ky9YK0xYMU1oUVhGOTVBc2hmVWxlQ3RtZG42bDZRRlh6TGcyc2dMbjFveVZGdVplY3Y3ZnpzSUh6b1JsQUdwMGd3WURPbjFTNHFhYld2QjV4VWFFK1N2dzRLbWpXdHhkbnVRYkkzMmR3ODdENE45NXU4cVFSSlRTUWcwd0x4T0xreFNyUE1MRW4xVUloTktqQWE5VkxzM1dMYVhHcnRDSXQ4YktZMkFRUC9aZHlSVTZ6VC9FOHFQMmx0eUJFMkNDWlBnV2dFWURvSkpPNG45Mnk2MXlsTmFTRlhLb2hKaExqa2Z2WVdtNTkyNTM5c0lwbUJOTGxEbzFiRXhGQmZtSEpKMGxGRWlDL2ZqOHY0Mk9vTUM5TW8zd2hJb1d2eUhmcTZVYWNxcTU1bXpGZi9FR0MrTlAvZ0hqaGQ2dXJjNlIwaEVTMjdWWHV4N1VZOENHS1BvaHBsV0ladFRyRlNhUFdzbENXeTc4RTIyUHc4ZnZSZVNVWngvdHhxTHRIckZxZzFEWS9FdXM2SXExaGVaZHJkY3FFMC9jOTcxQnoxSFcvWE5YSHNYcFVJYkk0a0hkT2ZDYzZUNXpIWnp2elFKQjBnZ01GTDZJR1BBaWxVOWJqL0FTZFBrNmZOdk50WnFQdXdFRGhNQnRCbmhDZXhvNkQ2VkFHSU9QdkpQUFY1MjNZOFI4YTl2Q3FaYnN3U1pLek9UMTI5MUJzVWJtVVdlaHRiYjFmZFJYOWhpSktYdndyMVFYNkdqblpNZ3lNdm53T28yRHIyNGFtcjdGcUVBYlZlSkFqUk5PY2VNMkVRMU1uYTlmSW5xUEo1bWg1WDhDelQxYURPdjA4QW4wYmx6MGZGNUdxNG1TMmN3cTVnbHdJT2xZNW56bkU4WDRqL1VkWjNGSnNWSVh0ZTFKSDBBN2lpYnVQZmF6U3RNNU8vVm8zS1hJcFhCZUdPUlYwTTlYRFhGdnNZWlVIR3ZGQ1V1Yld6VHcyNDhFSEUwY3BRTTJ6Tmc2cmphdnJlcTNOSENBV3NvWjd3dlZ5N2w1Z3Z0S1JtSWoxTW52ZldFbTB5Rm5HY3VPcTE5MjM1MGE1V2VmcGZLQ2NYM1NuK0FnSFUrcW5wc3ROdGRkYmRWZWJhZ0pVMzkwbHE5a280YUk5cnFkYVdYWUc4dHY1Ty9aUUhTcURSWUhDNnpmSDEwbDV6KytvcHNvN2FPU2FJY3psUTEzaUF6WHZMZEV1MFY3a3dOVVoxYzhZOGFxN1NlSUVlNXA5MDJGbE5rVzhEbndIeXVlSGNoYks4dlZGSmZtcjltejdQOG5VU2NjbDFVTGFvV01SU0kxbHMzMmt2bEswaDQ2aDNKMjVZZDlBemZjSmJwOXFZRi9TRXQzSDVqNjltTWRjc054WmNBelQvQTg5b3YzdGdsVFg1NHkvRXdqTWZ1b0RveFB3TEpEbTVJN3E2RjlLcDQ2OXlOeTF6U3h6ME40SGJSUkJqOXhGRnVvZ3ZCc3B2N0RYVU5Jc0d4VElORVFmbWN0YjQyWEltV0FPRGdBUk5vN2RmY1RxRktxNmFUZml2bXZ1bkxtelA5Zjh5THNKdlhEM0piY1BjREdOcmlNQWNqemVEVE5yNjV0OFlCNXRzbkZERkxhMFV3bWQyT3ZVZGtMTVg5VHNBVVlVZm9vU3Y0N3N3NUo4OGo3Q3BhaFJqak8zL1VoT1hqVFMzOVc1WVpBZWwyS1RiUWQxaDdJTk93OVAyM0dXN0dEQWU0YWdJVUZIUDQ4TVpyN3VicTBlZkZtbXR3WU15azdEMHIxb2VHL0NHT09EZ2I5VXIrSk1IeGt3elBidENYMlpuRU5RdUkwUk41U3lUSVp1b1k0WFM5UmQvdFBlM3ZOQVpHU0hNL1lZd3FzOXhra0VOeDBPK2VDMllWVzFjd09KM2NrRTg5MG5iUWVITEtsVzE1TDBQMFcyVmxpeVlyZk5yMG5ySVlkZG9SeUdhQ3RqNE9ZZDJNVDdlYkFwcVpPQVFJYVNISk00bXBoaGZqTmp0bmpnNllSeXg5cU0yRlQzeE9pWUlNcVhQRldkemhTZ0ZGOEl0b2NxVlYwOUNtSW9POGs2VS9vSkI3Kyt3U1gvWWtzeGZQWEh5alNnQUdaT2oxYUtFcTlmU3ZYQnF0cDJ3dTgvRnhFZjVBeGFwQUQwNnBQR3VMVlVZTGRnRXpIUjh3cVJHWUV3aVVPOU15WWJnc3dzdHVMWWh3WUZwU1ZLT2R6QWloWjlMdUh0RDU5OEVHaElOVTl4Yzl4aEwrUWdUTEFzdG1QSXZ2bTJ4eVJ3L1dUVVBYa1AzWkh1Nkd5UG1qNXhGSDkvUUdwa2dsS1hSVlVCZ1ZtTE9KeDh1Wk8yQXN0eFFZb2NaSDJKaE9SbHhhd2o2NkJBWFVFczdLL2dQeElOSVJBRnlLM1dMdXlxOW9CVEY5d0Vibm1Db3Q4MldqSWc3Q1BOd1lLM0tyWk1yS0F6NXlGc3pnNHdDVkxKVm5JTDgrT1lBMHhSREg4Y0hRalFVaVEyaTFtci9iZTMyay8zWGVqOXNkZjNpdUd2Wkh5TEZTSnZQU3F6L3dsdG54dW1USllLWnNyV1h0eC9SbXUzOWpqVjlsRmFKdHRmRm41Ny9ObzJoL3Vuc0ptTUhicm5aOGNzeGtwNUhRNHhSMXMwSEgrdDNJejgyYTNpUVdUVURHcS8rbDJXM1RVWUxFOHpOZEw4WSs1b1hhSUgvWTJVVWNYNjdjWGVONFd2RU5aano0KzhxN3ZqaG93T0kzclNqRmhHWjZLendtVTcrNW5GVitrR1dBWjV6MlVXdnpxMFRLMHBrMWhQd0FONGpidy8vMUNBcFJ2SWFJamhTR2hpb1k2VFVtc1RvZWs5Y0Y5WGpKZEh2TFBjeXlDVjNsYlI1Sml6L3RzNDZheTJGODIwVmpUWHZsbEVsd3JHektjTlN5dlFsV0RYZHdyVUlOWG1Ib3JBTTNmRTE5bmdMWm1nZVVhQ0pMc1NJVGYyVmNmQU91V3dYN21UUGRQOFpiLzA0S3FSbml1ZkNwd25EVWs3c1AwUlg2Y3VkL3NhbkZNYWduektJblNSVmV5MFl6bFZTT3RBL0Fqcm9mbVNINlJZYkpROGI0TkRlVGtJR2M2MjQ3K01uYmV6L3FoSjlHQXY5ZkdORmVyY1BubnJmMjg1UWdzK1VxVGhMUmdmbGNBS0Z1cVdoTHpaYVI0UXF2U3dhM3hlMExQa3FqOXhKV3ViMTk1cjdOcnJSMGU3OEZSKzBtUkJOTVBzcmFxWmN0QVVWQUpmWUtlaFREVjFNR0dRU2VEc09LOUozc2JVdUtSSVMvV2lsWC82NENCbXM5akNab2NCbHNCU1phSUFqV20vU1VaOGRhV0wyYS9jSkZ5VU9GcUUzRXBjMlJXYnRqTnlQd09HcFd0enUzMmtVb29VcXNKdWQ3SVY0RThyc3RVQlhNN3RHRXRCeDk5eDYwZzFkdWh5dnhlS0pTbDhzNUUzNEhUTW1BRFQwODM2YUVkZzVEdjlyVnlDejhpMlJFT21pejZ3dElWRk4wSHNqQW9OMzdTclkwYlYxTXM4Q1JVSUxodlp2dlJhRHpvVkNhU0kwdThFUHVUZTRiN09Qb3dnUkdPRGwyMlVCQm1IU1RVWThlNER5TCtCYzdibmdvKzJUOEh0TnZ6eUFUU0w1aUpaZ0ZQS3BtVXladjU0dlZMOTArL1JRR0FUVW1OS25ySXZjSk1ZT045Zmw4M25hVzVzZjZoUmtiYlRDOVJVRUU2WEFEd2pnQTQ2d1dmVVErUVdabDBKNFBWVFdBbG4vWWZBei9TVjNxM0o5K3lDWURsZXJ1b041dW9jL3dUMmY0WU9OR1RiNnpUR3EzViszSnF6bUNPandlYktsbitmRXhWTE43c3F0cWZNbnNLVlhXYmIyQWk1bTNEL2ZDVGdYN29LWXpUWnZqK20yOFhuRHFQYlh1UDRNeVdkbVBlemNlc2RyaDdyQ3pBN0JXZE9iaXV5REVLamp6QmJRMHFudXdqbGl6K2IrajdhUE1LbGtYeUl6blYzdEd6QWZZd0liekdHdDA5OG9oNGVxM3J1RGpkZ0h0anhmRkNqSHJqalJiSGFqb3ovWU9ZNHJhb2pQRlE5MTBHSWxCVjdocTQ3VURncHlhakJ4UVVtRDhOY3RpTFYxclRTTEFFc1FETFRlUktjbVBCTVZNRkYwU1BCQmhaNW9Yb3h0RDNsTWh1QVFYbUErNTdPY2NpY3pWVzllOXp3U0lBSFMrRkptdmZYTUpHRjFkTUJzSVVNYVBqdmdhVnFVYzNwMzJxVkNNUVlGRWlSTHpsVlNPR01DbXYvSEpJeEFIZTNtTC9Ybm9aMUlrV0xlUlpmZ3lCeWpuRGJiZVJLNUtMN2JZSFNWSlo5VUZxK3lDaU5LZVJVYVlqZ2JDM2hWVXZmSkFoeS9RTmwvSnFMS1Z2R01rOVpjZnlHaWROZW8vVlR4Szl2VXBvZHpmUUk5WjJlQXJlNG5tcmt6Z3hLU25UNUlKMUQ2OW9IdVVTNWhwN3BLOUlBV3VOckFPdE9IMG1BdXdDclk4bVhBdFZYVWVhTkszT1hyNlBSdm1XZzRWUXFGU3krYTFHWmZGWWdkc0pFTEc4TjBrdnFtenZ3WjAyUGxmNWZIOVFUeTZicjBvWS9JRHNFQStHQmY5cEVWV0NJdUJDanN1cDNMRFNEcUkrNSswSUtTVUZyN0E5NkEyZjBGYmNVOWZxbGpkcXZzZDhzRzU1S2NLbG9ISUZaZW0yV2I2cENMWHliblZTQjBzakNYemRTOElLdkUnKTtcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcbmNvbnN0IE5TTV9NQVggPSA0O1xuXG5mdW5jdGlvbiBoZXhfY3AoY3ApIHtcclxuXHRyZXR1cm4gY3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVvdGVfY3AoY3ApIHtcclxuXHRyZXR1cm4gYHske2hleF9jcChjcCl9fWA7IC8vIHJhZmZ5IGNvbnZlbnRpb246IGxpa2UgXCJcXHV7WH1cIiB3L28gdGhlIFwiXFx1XCJcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVfY3Aocykge1xyXG5cdHJldHVybiBbLi4uc10ubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7IC8vIHRoaXMgaXMgYWJvdXQgMnggZmFzdGVyXHJcblx0bGV0IGNwcyA9IFtdO1xyXG5cdGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47ICkge1xyXG5cdFx0bGV0IGNwID0gcy5jb2RlUG9pbnRBdChwb3MpO1xyXG5cdFx0cG9zICs9IGNwIDwgMHgxMDAwMCA/IDEgOiAyO1xyXG5cdFx0Y3BzLnB1c2goY3ApO1xyXG5cdH1cclxuXHRyZXR1cm4gY3BzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJfZnJvbV9jcHMoY3BzKSB7XHJcblx0Y29uc3QgY2h1bmsgPSA0MDk2O1xyXG5cdGxldCBsZW4gPSBjcHMubGVuZ3RoO1xyXG5cdGlmIChsZW4gPCBjaHVuaykgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcyk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcclxuXHRcdGJ1Zi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcy5zbGljZShpLCBpICs9IGNodW5rKSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlX2FycmF5cyhhLCBiKSB7XHJcblx0bGV0IG4gPSBhLmxlbmd0aDtcclxuXHRsZXQgYyA9IG4gLSBiLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgYyA9PSAwICYmIGkgPCBuOyBpKyspIGMgPSBhW2ldIC0gYltpXTtcclxuXHRyZXR1cm4gYztcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDItMjFUMDk6MTg6MTMuNTQ5WlxudmFyIHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZCgnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnKTtcblxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5jb25zdCBTSElGVEVEX1JBTksgPSBuZXcgTWFwKHJlYWRfc29ydGVkX2FycmF5cyhyKS5mbGF0TWFwKCh2LCBpKSA9PiB2Lm1hcCh4ID0+IFt4LCAoaSsxKSA8PCAyNF0pKSk7IC8vIHByZS1zaGlmdGVkXHJcbmNvbnN0IEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuY29uc3QgREVDT01QID0gbmV3IE1hcCgpO1xyXG5jb25zdCBSRUNPTVAgPSBuZXcgTWFwKCk7XHJcbmZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdGlmICghRVhDTFVTSU9OUy5oYXMoY3ApICYmIGNwcy5sZW5ndGggPT0gMikge1xyXG5cdFx0bGV0IFthLCBiXSA9IGNwcztcclxuXHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0YnVja2V0ID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHR9XHJcblx0XHRidWNrZXQuc2V0KGIsIGNwKTtcclxuXHR9XHJcblx0REVDT01QLnNldChjcCwgY3BzLnJldmVyc2UoKSk7IC8vIHN0b3JlZCByZXZlcnNlZFxyXG59XHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiBpc19oYW5ndWwoY3ApIHtcclxuXHRyZXR1cm4gY3AgPj0gUzAgJiYgY3AgPCBTMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZV9wYWlyKGEsIGIpIHtcclxuXHRpZiAoYSA+PSBMMCAmJiBhIDwgTDEgJiYgYiA+PSBWMCAmJiBiIDwgVjEpIHtcclxuXHRcdHJldHVybiBTMCArIChhIC0gTDApICogTl9DT1VOVCArIChiIC0gVjApICogVF9DT1VOVDtcclxuXHR9IGVsc2UgaWYgKGlzX2hhbmd1bChhKSAmJiBiID4gVDAgJiYgYiA8IFQxICYmIChhIC0gUzApICUgVF9DT1VOVCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gYSArIChiIC0gVDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsZXQgcmVjb21wID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0cmVjb21wID0gcmVjb21wLmdldChiKTtcclxuXHRcdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRcdHJldHVybiByZWNvbXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZWQoY3BzKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbi8vY29uc3QgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5cclxuZnVuY3Rpb24gcmVhZF9zZXQoKSB7XHJcblx0cmV0dXJuIG5ldyBTZXQocmVhZF9zb3J0ZWQociQxKSk7XHJcbn1cclxuY29uc3QgTUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyJDEpKTsgXHJcbmNvbnN0IElHTk9SRUQgPSByZWFkX3NldCgpOyAvLyBpZ25vcmVkIGNoYXJhY3RlcnMgYXJlIG5vdCB2YWxpZCwgc28ganVzdCByZWFkIHJhdyBjb2RlcG9pbnRzXHJcbi8qXHJcbi8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYXQgdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5jb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdGxldCBjcCA9IHIoKTtcclxuXHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG59KSk7XHJcbiovXHJcbi8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuLy8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcbmNvbnN0IENNID0gcmVhZF9zZXQoKTtcclxuY29uc3QgTlNNID0gbmV3IFNldChyZWFkX3NvcnRlZChyJDEpLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiB0aGlzW2ldOyB9LCBbLi4uQ01dKSk7XHJcbi8qXHJcbmNvbnN0IENNX1NPUlRFRCA9IHJlYWRfc29ydGVkKHIpO1xyXG5jb25zdCBOU00gPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpLm1hcChpID0+IENNX1NPUlRFRFtpXSkpO1xyXG5jb25zdCBDTSA9IG5ldyBTZXQoQ01fU09SVEVEKTtcclxuKi9cclxuY29uc3QgRVNDQVBFID0gcmVhZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5jb25zdCBORkNfQ0hFQ0sgPSByZWFkX3NldCgpO1xyXG5jb25zdCBDSFVOS1MgPSByZWFkX3NvcnRlZF9hcnJheXMociQxKTtcclxuZnVuY3Rpb24gcmVhZF9jaHVua2VkKCkge1xyXG5cdC8vIGRlZHVwbGljYXRlZCBzZXRzICsgdW5pcXVlc1xyXG5cdHJldHVybiBuZXcgU2V0KFtyZWFkX3NvcnRlZChyJDEpLm1hcChpID0+IENIVU5LU1tpXSksIHJlYWRfc29ydGVkKHIkMSldLmZsYXQoMikpO1xyXG59XHJcbmNvbnN0IFVOUkVTVFJJQ1RFRCA9IHIkMSgpO1xyXG5jb25zdCBHUk9VUFMgPSByZWFkX2FycmF5X3doaWxlKGkgPT4ge1xyXG5cdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdC8vIHNvIHRoZXNlIGFyZSBtYW51YWxseSByZW5hbWVkIHRvIHNpbmdsZSBjaGFyc1xyXG5cdGxldCBOID0gcmVhZF9hcnJheV93aGlsZShyJDEpLm1hcCh4ID0+IHgrMHg2MCk7XHJcblx0aWYgKE4ubGVuZ3RoKSB7XHJcblx0XHRsZXQgUiA9IGkgPj0gVU5SRVNUUklDVEVEOyAvLyBmaXJzdCBhcmVudCByZXN0cmljdGVkXHJcblx0XHROWzBdIC09IDMyOyAvLyBjYXBpdGFsaXplXHJcblx0XHROID0gc3RyX2Zyb21fY3BzKE4pO1xyXG5cdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0bGV0IFAgPSByZWFkX2NodW5rZWQoKTsgLy8gcHJpbWFyeVxyXG5cdFx0bGV0IFEgPSByZWFkX2NodW5rZWQoKTsgLy8gc2Vjb25kYXJ5XHJcblx0XHRsZXQgViA9IFsuLi5QLCAuLi5RXS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBkZXJpdmU6IHNvcnRlZCB2YWxpZFxyXG5cdFx0Ly9sZXQgTSA9IHIoKS0xOyAvLyBjb21iaW5pbmcgbWFya1xyXG5cdFx0bGV0IE0gPSAhciQxKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0Ly8gY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkXHJcblx0XHQvKmlmIChNIDwgMCkgeyAvLyB3aGl0ZWxpc3RlZFxyXG5cdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRsZXQgaSA9IHIoKTtcclxuXHRcdFx0XHRpZiAoaSkgcmV0dXJuIFtWW2ktMV0sIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdi5tYXAoeCA9PiB4LTEpO1xyXG5cdFx0XHRcdH0pXTtcclxuXHRcdFx0fSkpO1xyXG5cdFx0fSovXHJcblx0XHRyZXR1cm4ge04sIFAsIE0sIFIsIFY6IG5ldyBTZXQoVil9O1xyXG5cdH1cclxufSk7XHJcbmNvbnN0IFdIT0xFX1ZBTElEID0gcmVhZF9zZXQoKTtcclxuY29uc3QgV0hPTEVfTUFQID0gbmV3IE1hcCgpO1xyXG4vLyBkZWNvZGUgY29tcHJlc3NlZCB3aG9sZXNcclxuWy4uLldIT0xFX1ZBTElELCAuLi5yZWFkX3NldCgpXS5zb3J0KChhLCBiKSA9PiBhLWIpLm1hcCgoY3AsIGksIHYpID0+IHtcclxuXHRsZXQgZCA9IHIkMSgpOyBcclxuXHRsZXQgdyA9IHZbaV0gPSBkID8gdltpLWRdIDoge1Y6IFtdLCBNOiBuZXcgTWFwKCl9O1xyXG5cdHcuVi5wdXNoKGNwKTsgLy8gYWRkIHRvIG1lbWJlciBzZXRcclxuXHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFdIT0xFX01BUC5zZXQoY3AsIHcpOyAgLy8gcmVnaXN0ZXIgd2l0aCB3aG9sZSBtYXBcclxuXHR9XHJcbn0pO1xyXG4vLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcbmZvciAobGV0IHtWLCBNfSBvZiBuZXcgU2V0KFdIT0xFX01BUC52YWx1ZXMoKSkpIHtcclxuXHQvLyBjb25uZWN0IGFsbCBncm91cHMgdGhhdCBoYXZlIGVhY2ggd2hvbGUgY2hhcmFjdGVyXHJcblx0bGV0IHJlY3MgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRsZXQgZ3MgPSBHUk9VUFMuZmlsdGVyKGcgPT4gZy5WLmhhcyhjcCkpO1xyXG5cdFx0bGV0IHJlYyA9IHJlY3MuZmluZCgoe0d9KSA9PiBncy5zb21lKGcgPT4gRy5oYXMoZykpKTtcclxuXHRcdGlmICghcmVjKSB7XHJcblx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0cmVjcy5wdXNoKHJlYyk7XHJcblx0XHR9XHJcblx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdGdzLmZvckVhY2goZyA9PiByZWMuRy5hZGQoZykpO1xyXG5cdH1cclxuXHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRsZXQgdW5pb24gPSByZWNzLmZsYXRNYXAoKHtHfSkgPT4gWy4uLkddKTtcclxuXHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbmxldCB1bmlvbiA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5sZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuZm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBnLlYpIHtcclxuXHRcdCh1bmlvbi5oYXMoY3ApID8gbXVsdGkgOiB1bmlvbikuYWRkKGNwKTtcclxuXHR9XHJcbn1cclxuLy8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5mb3IgKGxldCBjcCBvZiB1bmlvbikge1xyXG5cdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0fVxyXG59XHJcbmNvbnN0IFZBTElEID0gbmV3IFNldChbLi4udW5pb24sIC4uLm5mZCh1bmlvbildKTsgLy8gcG9zc2libHkgdmFsaWRcclxuXHJcbi8vIGRlY29kZSBlbW9qaVxyXG5jb25zdCBFTU9KSV9TT1JURUQgPSByZWFkX3NvcnRlZChyJDEpOyAvLyB0ZW1wb3JhcnlcclxuLy9jb25zdCBFTU9KSV9TT0xPID0gbmV3IFNldChyZWFkX3NvcnRlZChyKS5tYXAoaSA9PiBFTU9KSV9TT1JURURbaV0pKTsgLy8gbm90IG5lZWRlZFxyXG5jb25zdCBFTU9KSV9ST09UID0gcmVhZF9lbW9qaV90cmllKFtdKTtcclxuZnVuY3Rpb24gcmVhZF9lbW9qaV90cmllKGNwcykge1xyXG5cdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQga2V5cyA9IHJlYWRfc29ydGVkKHIkMSkubWFwKGkgPT4gRU1PSklfU09SVEVEW2ldKTtcclxuXHRcdGlmIChrZXlzLmxlbmd0aCkgcmV0dXJuIHJlYWRfZW1vamlfdHJpZShrZXlzKTtcclxuXHR9KS5zb3J0KChhLCBiKSA9PiBiLlEuc2l6ZSAtIGEuUS5zaXplKTsgLy8gc29ydCBieSBsaWtlbGlob29kXHJcblx0bGV0IHRlbXAgPSByJDEoKTtcclxuXHRsZXQgViA9IHRlbXAgJSAzOyAvLyB2YWxpZCAoMCA9IGZhbHNlLCAxID0gdHJ1ZSwgMiA9IHdlaXJkKVxyXG5cdHRlbXAgPSAodGVtcCAvIDMpfDA7XHJcblx0bGV0IEYgPSB0ZW1wICYgMTsgLy8gYWxsb3cgRkUwRlxyXG5cdHRlbXAgPj49IDE7XHJcblx0bGV0IFMgPSB0ZW1wICYgMTsgLy8gc2F2ZVxyXG5cdGxldCBDID0gdGVtcCAmIDI7IC8vIGNoZWNrXHJcblx0cmV0dXJuIHtCLCBWLCBGLCBTLCBDLCBROiBuZXcgU2V0KGNwcyl9O1xyXG59XHJcbi8vY29uc29sZS5sb2cocGVyZm9ybWFuY2Uubm93KCkgLSB0MCk7XHJcblxyXG4vLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH1cclxufVxyXG5cclxuLy8gY3JlYXRlIGEgc2FmZSB0byBwcmludCBzdHJpbmcgXHJcbi8vIGludmlzaWJsZXMgYXJlIGVzY2FwZWRcclxuLy8gbGVhZGluZyBjbSB1c2VzIHBsYWNlaG9sZGVyXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIHF1b3RlciA9IHF1b3RlX2NwKSB7XHJcblx0Ly9pZiAoTnVtYmVyLmlzSW50ZWdlcihjcHMpKSBjcHMgPSBbY3BzXTtcclxuXHQvL2lmICghQXJyYXkuaXNBcnJheShjcHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBjb2RlcG9pbnRzYCk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGlmIChpc19jb21iaW5pbmdfbWFyayhjcHNbMF0pKSBidWYucHVzaCgn4peMJyk7XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIGlmIGVzY2FwZWQ6IHtIRVh9XHJcbi8vICAgICAgIGVsc2U6IFwieFwiIHtIRVh9XHJcbmZ1bmN0aW9uIHF1b3RlZF9jcChjcCkge1xyXG5cdHJldHVybiAoc2hvdWxkX2VzY2FwZShjcCkgPyAnJyA6IGAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoW2NwXSkpfSBgKSArIHF1b3RlX2NwKGNwKTtcclxufVxyXG5cclxuLy8gMjAyMzAyMTE6IHNvbWUgbWVzc2FnZXMgY2FuIGJlIG1peGVkLWRpcmVjdGlvbmFsIGFuZCByZXN1bHQgaW4gc3BpbGxvdmVyXHJcbi8vIHVzZSAyMDBFIGFmdGVyIGEgcXVvdGVkIHN0cmluZyB0byBmb3JjZSB0aGUgcmVtYWluZGVyIG9mIGEgc3RyaW5nIGZyb20gXHJcbi8vIGFjcXVyaW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHF1b3RlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1iaWRpLXVuaWNvZGUtY29udHJvbHMjZXhjZXB0aW9uc1xyXG5mdW5jdGlvbiBiaWRpX3FxKHMpIHtcclxuXHRyZXR1cm4gYFwiJHtzfVwiXFx1MjAwRWA7IC8vIHN0cm9uZyBMVFJcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfbGFiZWxfZXh0ZW5zaW9uKGNwcykge1xyXG5cdGlmIChjcHMubGVuZ3RoID49IDQgJiYgY3BzWzJdID09IEhZUEhFTiAmJiBjcHNbM10gPT0gSFlQSEVOKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGFiZWwgZXh0ZW5zaW9uJyk7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbmZ1bmN0aW9uIGlzX2NvbWJpbmluZ19tYXJrKGNwKSB7XHJcblx0cmV0dXJuIENNLmhhcyhjcCk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkX2VzY2FwZShjcCkge1xyXG5cdHJldHVybiBFU0NBUEUuaGFzKGNwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZV9mcmFnbWVudChmcmFnLCBkZWNvbXBvc2UpIHtcclxuXHRsZXQgbmYgPSBkZWNvbXBvc2UgPyBuZmQgOiBuZmM7XHJcblx0cmV0dXJuIGZyYWcuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHN0cl9mcm9tX2Nwcyhwcm9jZXNzKGV4cGxvZGVfY3AobGFiZWwpLCBuZikuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBmaWx0ZXJfZmUwZih4KSA6IHgpKSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XHJcblx0cmV0dXJuIGZsYXR0ZW4oZW5zX3NwbGl0KG5hbWUpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX2JlYXV0aWZ5KG5hbWUpIHtcclxuXHRsZXQgc3BsaXQgPSBlbnNfc3BsaXQobmFtZSwgdHJ1ZSk7XHJcblx0Ly8gdGhpcyBpcyBleHBlcmltZW50YWxcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2Ygc3BsaXQpIHtcclxuXHRcdGlmIChlcnJvcikgY29udGludWU7XHJcblxyXG5cdFx0Ly8gcmVwbGFjZSBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlblxyXG5cdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGJlYXV0aWZpbmcgYWxsIG9yIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuIHRvIHVuaWNvZGUgdmFyaWFudFxyXG5cdFx0Ly8gbm90IGV4YWN0bHkgdGhlIHNhbWUgaW4gZXZlcnkgZm9udCwgYnV0IHZlcnkgc2ltaWxhcjogXCItXCIgdnMgXCLigJBcIlxyXG5cdFx0LypcclxuXHRcdGNvbnN0IFVOSUNPREVfSFlQSEVOID0gMHgyMDEwO1xyXG5cdFx0Ly8gbWF5YmUgdGhpcyBzaG91bGQgcmVwbGFjZSBhbGwgZm9yIHZpc3VhbCBjb25zaXN0YW5jeT9cclxuXHRcdC8vIGBub2RlIHRvb2xzL3JlZy1jb3VudC5qcyByZWdleCBeLVxcezIsXFx9YCA9PiA1OTJcclxuXHRcdC8vZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIGlmIChvdXRwdXRbaV0gPT0gMHgyRCkgb3V0cHV0W2ldID0gMHgyMDEwO1xyXG5cdFx0aWYgKG91dHB1dFswXSA9PSBIWVBIRU4pIG91dHB1dFswXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0bGV0IGVuZCA9IG91dHB1dC5sZW5ndGgtMTtcclxuXHRcdGlmIChvdXRwdXRbZW5kXSA9PSBIWVBIRU4pIG91dHB1dFtlbmRdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHQqL1xyXG5cdFx0Ly8gMjAyMzAxMjM6IFdIQVRXRyBVUkwgdXNlcyBcIkNoZWNrSHlwaGVuc1wiIGZhbHNlXHJcblx0XHQvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lkbmFcclxuXHJcblx0XHQvLyB1cGRhdGUgZXRoZXJldW0gc3ltYm9sXHJcblx0XHQvLyDOviA9PiDOniBpZiBub3QgZ3JlZWtcclxuXHRcdGlmICh0eXBlICE9PSAnR3JlZWsnKSB7IFxyXG5cdFx0XHRsZXQgcHJldiA9IDA7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IG5leHQgPSBvdXRwdXQuaW5kZXhPZigweDNCRSwgcHJldik7XHJcblx0XHRcdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdFx0XHRvdXRwdXRbbmV4dF0gPSAweDM5RTsgXHJcblx0XHRcdFx0cHJldiA9IG5leHQgKyAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4oc3BsaXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdGxldCBub3JtO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gMS4pIFwiVGhlIGxhYmVsIG11c3QgYmUgaW4gVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gTkZDXCJcclxuXHRcdFx0bGV0IHRva2VucyA9IGluZm8udG9rZW5zID0gcHJvY2VzcyhpbnB1dCwgbmZjKTsgLy8gaWYgd2UgcGFyc2UsIHdlIGdldCBbbm9ybSBhbmQgbWFwcGVkXVxyXG5cdFx0XHRsZXQgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHRsZXQgdHlwZTtcclxuXHRcdFx0aWYgKCF0b2tlbl9jb3VudCkgeyAvLyB0aGUgbGFiZWwgd2FzIGVmZmVjdGl2ZWx5IGVtcHR5IChjb3VsZCBvZiBoYWQgaWdub3JlZCBjaGFyYWN0ZXJzKVxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBlbXB0eSBsYWJlbGApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vuc1swXTtcclxuXHRcdFx0XHRsZXQgZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgY2hhcnMuaXNfZW1vamk7XHJcblx0XHRcdFx0aWYgKCFlbW9qaSAmJiBjaGFycy5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHRcdG5vcm0gPSBjaGFycztcclxuXHRcdFx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0XHRcdC8vIG9ubHkgbmVlZGVkIGZvciBhc2NpaVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pO1xyXG5cdFx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0XHQvLyBjYW50IGhhdmUgd2hvbGVzXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoZW1vamkpIHsgLy8gdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVtb2ppXHJcblx0XHRcdFx0XHRcdGluZm8uZW1vamkgPSB0cnVlOyBcclxuXHRcdFx0XHRcdFx0Y2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRub3JtID0gdG9rZW5zLmZsYXRNYXAoeCA9PiAhcHJlc2VydmVfZW1vamkgJiYgeC5pc19lbW9qaSA/IGZpbHRlcl9mZTBmKHgpIDogeCk7XHJcblx0XHRcdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0XHR0eXBlID0gJ0Vtb2ppJztcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIDUuIFwiVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczogR2VuZXJhbF9DYXRlZ29yeT1NYXJrLlwiXHJcblx0XHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRcdGxldCBjcHMgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHRcdHRocm93IGVycm9yX3BsYWNlbWVudChgZW1vamkgKyBjb21iaW5pbmcgbWFyazogXCIke3N0cl9mcm9tX2Nwcyh0b2tlbnNbaS0xXSl9ICsgJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3BzWzBdXSl9XCJgKTsgXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGNoZWNrX2ZlbmNlZChub3JtKTtcclxuXHRcdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IFsuLi5uZXcgU2V0KGNoYXJzKV07XHJcblx0XHRcdFx0XHRcdGxldCBbZ10gPSBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKTsgLy8gdGFrZSB0aGUgZmlyc3QgbWF0Y2hcclxuXHRcdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdFx0Y2hlY2tfZ3JvdXAoZywgY2hhcnMpOyAvLyBuZWVkIHRleHQgaW4gb3JkZXJcclxuXHRcdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGV4cG9zaW5nIHJlc3RyaWN0ZWQgZmxhZ1xyXG5cdFx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdFx0Ly9pZiAoZy5SKSBpbmZvLnJlc3RyaWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGluZm8uZXJyb3IgPSBlcnI7IC8vIHVzZSBmdWxsIGVycm9yIG9iamVjdFxyXG5cdFx0fVxyXG5cdFx0aW5mby5vdXRwdXQgPSBub3JtO1xyXG5cdFx0cmV0dXJuIGluZm87XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX3dob2xlKGdyb3VwLCB1bmlxdWUpIHtcclxuXHRsZXQgbWFrZXI7XHJcblx0bGV0IHNoYXJlZCA9IFtdOyAvLyBUT0RPOiBjYW4gdGhpcyBiZSBhdm9pZGVkP1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0bGV0IHdob2xlID0gV0hPTEVfTUFQLmdldChjcCk7XHJcblx0XHRpZiAod2hvbGUgPT09IFVOSVFVRV9QSCkgcmV0dXJuOyAvLyB1bmlxdWUsIG5vbi1jb25mdXNhYmxlXHJcblx0XHRpZiAod2hvbGUpIHtcclxuXHRcdFx0bGV0IHNldCA9IHdob2xlLk0uZ2V0KGNwKTsgLy8gZ3JvdXBzIHdoaWNoIGhhdmUgYSBjaGFyYWN0ZXIgdGhhdCBsb29rLWxpa2UgdGhpcyBjaGFyYWN0ZXJcclxuXHRcdFx0bWFrZXIgPSBtYWtlciA/IG1ha2VyLmZpbHRlcihnID0+IHNldC5oYXMoZykpIDogWy4uLnNldF07XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1hbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGcuVi5oYXMoY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZy5WLmhhcyhjcCkpO1xyXG5cdFx0aWYgKCFncy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKGdyb3VwcyA9PT0gR1JPVVBTKSB7XHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQpKX06ICR7bXNnfWApOyBcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHJfZnJvbV9jcHMob3V0cHV0KTtcclxuXHR9KS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcnJvcl9kaXNhbGxvd2VkKGNwKSB7XHJcblx0Ly8gVE9ETzogYWRkIGNwIHRvIGVycm9yP1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZF9jcChjcCl9YCk7IFxyXG59XHJcbmZ1bmN0aW9uIGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCkge1xyXG5cdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdGxldCBnZyA9IEdST1VQUy5maW5kKGcgPT4gZy5QLmhhcyhjcCkpO1xyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRsZXQge1YsIE19ID0gZztcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghVi5oYXMoY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5WXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChNKSB7IC8vIHdlIG5lZWQgdG8gY2hlY2sgZm9yIE5TTVxyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gc2VlOiBhc3N1bXB0aW9uXHJcblx0XHRcdC8vIDIwMjMwMjEwOiBidWdmaXg6IHVzaW5nIGNwcyBpbnN0ZWFkIG9mIGRlY29tcG9zZWQgaC90IENhcmJvbjIyNVxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6ICR7Zy5OfSAke2JpZGlfcXEoc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHRcdCovXHJcblx0XHRcdC8vIDIwMjMwMjE3OiBzd2l0Y2ggdG8gTlNNIGNvdW50aW5nXHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jT3B0aW9uYWxfRGV0ZWN0aW9uXHJcblx0XHRcdGlmIChOU00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHRmb3IgKGxldCBjcDsgaiA8IGUgJiYgTlNNLmhhcyhjcCA9IGRlY29tcG9zZWRbal0pOyBqKyspIHtcclxuXHRcdFx0XHRcdC8vIGEuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbm9uc3BhY2luZyBtYXJrLlxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgayA9IGk7IGsgPCBqOyBrKyspIHsgLy8gTyhuXjIpIGJ1dCBuIDwgMTAwXHJcblx0XHRcdFx0XHRcdGlmIChkZWNvbXBvc2VkW2tdID09IGNwKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBub24tc3BhY2luZyBtYXJrczogcmVwZWF0ZWQgJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbm9uLXNwYWNpbmcgbWFya3M6IHRvbyBtYW55ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG5mdW5jdGlvbiBwcm9jZXNzKGlucHV0LCBuZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVtb2ppKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICghSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGFsbG93cyBvcHRpb25hbCBGRTBGXHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBzYXZlZDtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcG9zID0gY3BzLmxlbmd0aDtcclxuXHRpZiAoZWF0ZW4pIGVhdGVuLmxlbmd0aCA9IDA7IC8vIGNsZWFyIGlucHV0IGJ1ZmZlciAoaWYgbmVlZGVkKVxyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdGxldCBjcCA9IGNwc1stLXBvc107XHJcblx0XHRub2RlID0gbm9kZS5CLmZpbmQoeCA9PiB4LlEuaGFzKGNwKSk7XHJcblx0XHRpZiAoIW5vZGUpIGJyZWFrO1xyXG5cdFx0aWYgKG5vZGUuUykgeyAvLyByZW1lbWJlclxyXG5cdFx0XHRzYXZlZCA9IGNwO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLkMpIHsgLy8gY2hlY2sgZXhjbHVzaW9uXHJcblx0XHRcdGlmIChjcCA9PT0gc2F2ZWQpIGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRpZiAobm9kZS5GKSB7XHJcblx0XHRcdHN0YWNrLnB1c2goRkUwRik7XHJcblx0XHRcdGlmIChwb3MgPiAwICYmIGNwc1twb3MgLSAxXSA9PSBGRTBGKSBwb3MtLTsgLy8gY29uc3VtZSBvcHRpb25hbCBGRTBGXHJcblx0XHR9XHJcblx0XHRpZiAobm9kZS5WKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IGNvbmZvcm1fZW1vamlfY29weShzdGFjaywgbm9kZSk7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyBjb3B5IGlucHV0IChpZiBuZWVkZWQpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdC8qXHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdGlmICghZW1vamkpIHtcclxuXHRcdGxldCBjcCA9IGNwc1tjcHMubGVuZ3RoLTFdO1xyXG5cdFx0aWYgKEVNT0pJX1NPTE8uaGFzKGNwKSkge1xyXG5cdFx0XHRpZiAoZWF0ZW4pIGVhdGVuLnB1c2goY3ApO1xyXG5cdFx0XHRlbW9qaSA9IEVtb2ppLm9mKGNwKTtcclxuXHRcdFx0Y3BzLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQqL1xyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gY3JlYXRlIGEgY29weSBhbmQgZml4IGFueSB1bmljb2RlIHF1aXJrc1xyXG5mdW5jdGlvbiBjb25mb3JtX2Vtb2ppX2NvcHkoY3BzLCBub2RlKSB7XHJcblx0bGV0IGNvcHkgPSBFbW9qaS5mcm9tKGNwcyk7IC8vIGNvcHkgc3RhY2tcclxuXHRpZiAobm9kZS5WID09IDIpIGNvcHkuc3BsaWNlKDEsIDEpOyAvLyBkZWxldGUgRkUwRiBhdCBwb3NpdGlvbiAxIChzZWU6IG1ha2UuanMpXHJcblx0cmV0dXJuIGNvcHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhbGwgc3VwcG9ydGVkIGVtb2ppIGFzIGZ1bGx5LXF1YWxpZmllZCBlbW9qaSBcclxuLy8gb3JkZXJlZCBieSBsZW5ndGggdGhlbiBsZXhpY29ncmFwaGljIFxyXG5mdW5jdGlvbiBlbnNfZW1vamkoKSB7XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8vbGV0IHJldCA9IFsuLi5FTU9KSV9TT0xPXS5tYXAoeCA9PiBbeF0pO1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRidWlsZChFTU9KSV9ST09ULCBbXSk7XHJcblx0cmV0dXJuIHJldC5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRmdW5jdGlvbiBidWlsZChub2RlLCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAobm9kZS5TKSB7IFxyXG5cdFx0XHRzYXZlZCA9IGNwc1tjcHMubGVuZ3RoLTFdO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLkMpIHsgXHJcblx0XHRcdGlmIChzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmIChub2RlLkYpIGNwcy5wdXNoKEZFMEYpO1xyXG5cdFx0aWYgKG5vZGUuVikgcmV0LnB1c2goY29uZm9ybV9lbW9qaV9jb3B5KGNwcywgbm9kZSkpO1xyXG5cdFx0Zm9yIChsZXQgYnIgb2Ygbm9kZS5CKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRidWlsZChiciwgWy4uLmNwcywgY3BdLCBzYXZlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyB0b2tlbml6ZXIgXHJcblxyXG5jb25zdCBUWV9WQUxJRCA9ICd2YWxpZCc7XHJcbmNvbnN0IFRZX01BUFBFRCA9ICdtYXBwZWQnO1xyXG5jb25zdCBUWV9JR05PUkVEID0gJ2lnbm9yZWQnO1xyXG5jb25zdCBUWV9ESVNBTExPV0VEID0gJ2Rpc2FsbG93ZWQnO1xyXG5jb25zdCBUWV9FTU9KSSA9ICdlbW9qaSc7XHJcbmNvbnN0IFRZX05GQyA9ICduZmMnO1xyXG5jb25zdCBUWV9TVE9QID0gJ3N0b3AnO1xyXG5cclxuZnVuY3Rpb24gZW5zX3Rva2VuaXplKG5hbWUsIHtcclxuXHRuZiA9IHRydWUsIC8vIGNvbGxhcHNlIHVubm9ybWFsaXplZCBydW5zIGludG8gYSBzaW5nbGUgdG9rZW5cclxufSA9IHt9KSB7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcdFx0XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0LCBlYXRlbik7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0VNT0pJLCBlbW9qaSwgaW5wdXQ6IGVhdGVuLnNsaWNlKCksIGNwczogZmlsdGVyX2ZlMGYoZW1vamkpfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0IHsgZW5zX2JlYXV0aWZ5LCBlbnNfZW1vamksIGVuc19ub3JtYWxpemUsIGVuc19ub3JtYWxpemVfZnJhZ21lbnQsIGVuc19zcGxpdCwgZW5zX3Rva2VuaXplLCBpc19jb21iaW5pbmdfbWFyaywgbmZjLCBuZmQsIHNhZmVfc3RyX2Zyb21fY3BzLCBzaG91bGRfZXNjYXBlIH07XG4iXSwibmFtZXMiOlsiZGVjb2RlX2FyaXRobWV0aWMiLCJieXRlcyIsInBvcyIsInUxNiIsInN5bWJvbF9jb3VudCIsInRvdGFsIiwiYWNjIiwiaSIsInB1c2giLCJza2lwIiwicG9zX3BheWxvYWQiLCJyZWFkX3dpZHRoIiwicmVhZF9idWZmZXIiLCJyZWFkX2JpdCIsIk4iLCJGVUxMIiwiSEFMRiIsIlFSVFIiLCJNQVNLIiwicmVnaXN0ZXIiLCJzeW1ib2xzIiwibG93IiwicmFuZ2UiLCJ2YWx1ZSIsIk1hdGgiLCJmbG9vciIsInN0YXJ0IiwiZW5kIiwibWlkIiwiYSIsImIiLCJvZmZzZXQiLCJtYXAiLCJ4IiwicmVhZF9wYXlsb2FkIiwidiIsInJlYWRfY29tcHJlc3NlZF9wYXlsb2FkIiwicyIsInVuc2FmZV9hdG9iIiwibG9va3VwIiwiZm9yRWFjaCIsImMiLCJjaGFyQ29kZUF0IiwibiIsImxlbmd0aCIsInJldCIsIlVpbnQ4QXJyYXkiLCJ3aWR0aCIsImNhcnJ5Iiwic2lnbmVkIiwicmVhZF9kZWx0YXMiLCJuZXh0IiwiQXJyYXkiLCJyZWFkX3NvcnRlZCIsInByZXYiLCJyZWFkX3NvcnRlZF9hcnJheXMiLCJyZWFkX2FycmF5X3doaWxlIiwicmVhZF9tYXBwZWQiLCJ3IiwicmVhZF9saW5lYXJfdGFibGUiLCJyZWFkX3JlcGxhY2VtZW50X3RhYmxlIiwiZmxhdCIsInJlYWRfdHJhbnNwb3NlZCIsIm0iLCJmaWxsIiwiaiIsImR4IiwiZHkiLCJ2TiIsImZsYXRNYXAiLCJ5cyIsIl8iLCJqX2R5IiwieSIsInNsaWNlIiwiciQxIiwiRkVOQ0VEIiwiTWFwIiwiTlNNX01BWCIsImhleF9jcCIsImNwIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInBhZFN0YXJ0IiwicXVvdGVfY3AiLCJleHBsb2RlX2NwIiwiY3BzIiwibGVuIiwiY29kZVBvaW50QXQiLCJzdHJfZnJvbV9jcHMiLCJjaHVuayIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJidWYiLCJqb2luIiwiY29tcGFyZV9hcnJheXMiLCJyIiwidW5wYWNrX2NjIiwicGFja2VkIiwidW5wYWNrX2NwIiwiU0hJRlRFRF9SQU5LIiwiRVhDTFVTSU9OUyIsIlNldCIsIkRFQ09NUCIsIlJFQ09NUCIsImhhcyIsImJ1Y2tldCIsImdldCIsInNldCIsInJldmVyc2UiLCJTMCIsIkwwIiwiVjAiLCJUMCIsIkxfQ09VTlQiLCJWX0NPVU5UIiwiVF9DT1VOVCIsIk5fQ09VTlQiLCJTX0NPVU5UIiwiUzEiLCJMMSIsIlYxIiwiVDEiLCJpc19oYW5ndWwiLCJjb21wb3NlX3BhaXIiLCJyZWNvbXAiLCJkZWNvbXBvc2VkIiwiY2hlY2tfb3JkZXIiLCJhZGQiLCJjYyIsInNfaW5kZXgiLCJsX2luZGV4Iiwidl9pbmRleCIsInRfaW5kZXgiLCJtYXBwZWQiLCJwb3AiLCJwcmV2X2NjIiwidG1wIiwiY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkIiwic3RhY2siLCJwcmV2X2NwIiwiY29tcG9zZWQiLCJuZmQiLCJuZmMiLCJTVE9QIiwiRkUwRiIsIlNUT1BfQ0giLCJVTklRVUVfUEgiLCJIWVBIRU4iLCJyZWFkX3NldCIsIk1BUFBFRCIsIklHTk9SRUQiLCJDTSIsIk5TTSIsIkVTQ0FQRSIsIk5GQ19DSEVDSyIsIkNIVU5LUyIsInJlYWRfY2h1bmtlZCIsIlVOUkVTVFJJQ1RFRCIsIkdST1VQUyIsIlIiLCJQIiwiUSIsIlYiLCJzb3J0IiwiTSIsIldIT0xFX1ZBTElEIiwiV0hPTEVfTUFQIiwiZCIsInZhbHVlcyIsInJlY3MiLCJncyIsImZpbHRlciIsImciLCJyZWMiLCJmaW5kIiwiRyIsInNvbWUiLCJ1bmlvbiIsImNvbXBsZW1lbnQiLCJtdWx0aSIsIlZBTElEIiwiRU1PSklfU09SVEVEIiwiRU1PSklfUk9PVCIsInJlYWRfZW1vamlfdHJpZSIsIkIiLCJrZXlzIiwic2l6ZSIsInRlbXAiLCJGIiwiUyIsIkMiLCJFbW9qaSIsImlzX2Vtb2ppIiwic2FmZV9zdHJfZnJvbV9jcHMiLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsInNob3VsZF9lc2NhcGUiLCJxdW90ZWRfY3AiLCJiaWRpX3FxIiwiY2hlY2tfbGFiZWxfZXh0ZW5zaW9uIiwiRXJyb3IiLCJjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUiLCJVTkRFUlNDT1JFIiwibGFzdEluZGV4T2YiLCJjaGVja19mZW5jZWQiLCJlcnJvcl9wbGFjZW1lbnQiLCJsYXN0IiwibWF0Y2giLCJlbnNfbm9ybWFsaXplX2ZyYWdtZW50IiwiZnJhZyIsImRlY29tcG9zZSIsIm5mIiwic3BsaXQiLCJsYWJlbCIsInByb2Nlc3MiLCJmaWx0ZXJfZmUwZiIsImVuc19ub3JtYWxpemUiLCJuYW1lIiwiZmxhdHRlbiIsImVuc19zcGxpdCIsImVuc19iZWF1dGlmeSIsInR5cGUiLCJvdXRwdXQiLCJlcnJvciIsImluZGV4T2YiLCJwcmVzZXJ2ZV9lbW9qaSIsImlucHV0IiwiaW5mbyIsIm5vcm0iLCJ0b2tlbnMiLCJ0b2tlbl9jb3VudCIsImNoYXJzIiwiZW1vamkiLCJldmVyeSIsInVuaXF1ZSIsImRldGVybWluZV9ncm91cCIsImNoZWNrX2dyb3VwIiwiY2hlY2tfd2hvbGUiLCJlcnIiLCJncm91cCIsIm1ha2VyIiwic2hhcmVkIiwid2hvbGUiLCJncm91cHMiLCJlcnJvcl9kaXNhbGxvd2VkIiwiZXJyb3JfZ3JvdXBfbWVtYmVyIiwibXNnIiwibWVzc2FnZSIsInF1b3RlZCIsImdnIiwid2hlcmUiLCJlIiwiayIsImNvbnN1bWVfZW1vamlfcmV2ZXJzZWQiLCJlYXRlbiIsIm5vZGUiLCJzYXZlZCIsImNvbmZvcm1fZW1vamlfY29weSIsImNvcHkiLCJmcm9tIiwic3BsaWNlIiwiZW5zX2Vtb2ppIiwiYnVpbGQiLCJiciIsIlRZX1ZBTElEIiwiVFlfTUFQUEVEIiwiVFlfSUdOT1JFRCIsIlRZX0RJU0FMTE9XRUQiLCJUWV9FTU9KSSIsIlRZX05GQyIsIlRZX1NUT1AiLCJlbnNfdG9rZW5pemUiLCJ0b2tlbiIsImlzX3ZhbGlkX29yX21hcHBlZCIsInJlcXVpcmVzX2NoZWNrIiwiY3BzMCIsInRva2VuczAiLCJjb2xsYXBzZV92YWxpZF90b2tlbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@adraffy/ens-normalize/dist/index.mjs\n");

/***/ })

};
;