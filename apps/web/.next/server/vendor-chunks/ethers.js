"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(rsc)/../../node_modules/ethers/lib.esm/_version.js":
/*!*****************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/_version.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.7.1\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBaUUsR0FDakU7O0NBRUMsR0FDTSxNQUFNQSxVQUFVLFFBQVEsQ0FDL0Isb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcz9mZDg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi43LjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/array.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/boolean.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/string.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/tuple.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragments.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_3__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(param.components.map((c)=>this.#getCoder(c)), param.name);\n        }\n        switch(param.baseType){\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_5__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_7__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Reader(data, loose));\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n} //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9hYmktY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxtRUFBbUU7QUFDSztBQUNaO0FBQ1Q7QUFDSjtBQUNJO0FBQ0o7QUFDVztBQUNiO0FBQ0k7QUFDQTtBQUNGO0FBQ0o7QUFDTTtBQUNnQjtBQUNqRSxtRUFBbUU7QUFDbkUsTUFBTWtCLGVBQWUsSUFBSUM7QUFDekJELGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCLE1BQU1DLGlCQUFpQixJQUFJQyxPQUFPO0FBQ2xDLE1BQU1DLGtCQUFrQixJQUFJRCxPQUFPO0FBQ25DLElBQUlFLGVBQWU7QUFDbkIsU0FBU0Msd0JBQXdCQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ3ZELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsYUFBYTtJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUwsTUFBTTtRQUNORSxVQUFVO1FBQ1YsTUFBTUksUUFBUW5CLHlEQUFRQSxDQUFDYTtRQUN2QkEsT0FBT1osd0RBQU9BLENBQUNZO1FBQ2YsSUFBSU0sTUFBTUMsTUFBTSxLQUFLLEdBQUc7WUFDcEJMLFdBQVc7WUFDWEMsU0FBUztRQUNiLE9BQ0ssSUFBSUcsTUFBTUMsTUFBTSxHQUFH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QVMsSUFBSXhELHdEQUFVQSxDQUFDdUQsUUFBUTtRQUN0QyxNQUFNSyxTQUFTLElBQUlyRSw4REFBTUE7UUFDekJpRSxNQUFNRSxNQUFNLENBQUNFLFFBQVFEO1FBQ3JCLE9BQU9DLE9BQU81QyxJQUFJO0lBQ3RCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RTLE9BQU82QixLQUFLLEVBQUV0QyxJQUFJLEVBQUU2QyxLQUFLLEVBQUU7UUFDdkIsTUFBTU4sU0FBU0QsTUFBTVIsR0FBRyxDQUFDLENBQUNJLE9BQVMsSUFBSSxDQUFDLENBQUNYLFFBQVEsQ0FBQ3RDLHFEQUFTQSxDQUFDb0MsSUFBSSxDQUFDYTtRQUNqRSxNQUFNTSxRQUFRLElBQUl4RCx3REFBVUEsQ0FBQ3VELFFBQVE7UUFDckMsT0FBT0MsTUFBTS9CLE1BQU0sQ0FBQyxJQUFJbkMsOERBQU1BLENBQUMwQixNQUFNNkM7SUFDekM7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT0Msa0JBQWtCO1FBQ3JCLElBQUlsRCxnQkFBZ0IsTUFBTTtZQUN0QkEsZUFBZSxJQUFJMEI7UUFDdkI7UUFDQSxPQUFPMUI7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPQyx3QkFBd0JDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUU7UUFDN0MsT0FBT0gsd0JBQXdCQyxRQUFRQyxJQUFJQyxNQUFNc0IsU0FBU3dCLGVBQWU7SUFDN0U7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcz84YjY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFdoZW4gc2VuZGluZyB2YWx1ZXMgdG8gb3IgcmVjZWl2aW5nIHZhbHVlcyBmcm9tIGEgW1tDb250cmFjdF1dLCB0aGVcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cbiAqXG4gKiAgVGhlIEFiaUNvZGVyIHByb3ZpZGVzIGEgdXRpbGl0eSB0byBlbmNvZGUgdmFsdWVzIHRvIEFCSSBkYXRhIGFuZFxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cbiAqXG4gKiAgTW9zdCBvZiB0aGUgdGltZSwgZGV2ZWxvcGVycyBzaG91bGQgZmF2b3VyIHRoZSBbW0NvbnRyYWN0XV0gY2xhc3MsXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpBQkkgRW5jb2RpbmdcbiAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheS5qc1wiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXG4gICAgfTtcbiAgICBpZiAodHguZnJvbSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuI2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBgYHVpbnRgYCBpcyBieSBkZWZhdWx0IGBgMGBgIGFuZCBgYGJvb2xgYFxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydEFyZ3VtZW50Q291bnQiLCJhc3NlcnRBcmd1bWVudCIsIlJlYWRlciIsIldyaXRlciIsIkFkZHJlc3NDb2RlciIsIkFycmF5Q29kZXIiLCJCb29sZWFuQ29kZXIiLCJCeXRlc0NvZGVyIiwiRml4ZWRCeXRlc0NvZGVyIiwiTnVsbENvZGVyIiwiTnVtYmVyQ29kZXIiLCJTdHJpbmdDb2RlciIsIlR1cGxlQ29kZXIiLCJQYXJhbVR5cGUiLCJnZXRBZGRyZXNzIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibWFrZUVycm9yIiwiUGFuaWNSZWFzb25zIiwiTWFwIiwic2V0IiwicGFyYW1UeXBlQnl0ZXMiLCJSZWdFeHAiLCJwYXJhbVR5cGVOdW1iZXIiLCJkZWZhdWx0Q29kZXIiLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImFjdGlvbiIsInR4IiwiZGF0YSIsImFiaUNvZGVyIiwibWVzc2FnZSIsInJlYXNvbiIsImludm9jYXRpb24iLCJyZXZlcnQiLCJieXRlcyIsImxlbmd0aCIsInNsaWNlIiwiZGVjb2RlIiwic2lnbmF0dXJlIiwibmFtZSIsImFyZ3MiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb2RlIiwiTnVtYmVyIiwiZ2V0IiwidHJhbnNhY3Rpb24iLCJ0byIsImZyb20iLCJBYmlDb2RlciIsImdldENvZGVyIiwicGFyYW0iLCJpc0FycmF5IiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiaXNUdXBsZSIsImNvbXBvbmVudHMiLCJtYXAiLCJjIiwiYmFzZVR5cGUiLCJtYXRjaCIsInR5cGUiLCJzaXplIiwicGFyc2VJbnQiLCJnZXREZWZhdWx0VmFsdWUiLCJ0eXBlcyIsImNvZGVycyIsImNvZGVyIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwidmFsdWVzIiwid3JpdGVyIiwibG9vc2UiLCJkZWZhdWx0QWJpQ29kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n * @_ignore:\n */ const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    #names;\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(...args) {\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray() {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject() {\n        return this.#names.reduce((accum, name, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n            return accum;\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = this.#names.indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            Padding.slice(bytes.length % WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    constructor(name, type, localName, dynamic){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */ class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor(){\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)(this.#data);\n    }\n    get length() {\n        return this.#dataLength;\n    }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value)=>{\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */ class Reader {\n    #data;\n    #offset;\n    constructor(data, allowLoose){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(data);\n        this.#offset = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(this.#data);\n    }\n    get dataLength() {\n        return this.#data.length;\n    }\n    get consumed() {\n        return this.#offset;\n    }\n    get bytes() {\n        return new Uint8Array(this.#data);\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n} //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF5SjtBQUN6Sjs7Q0FFQyxHQUNNLE1BQU1VLFdBQVcsR0FBRztBQUMzQixNQUFNQyxVQUFVLElBQUlDLFdBQVdGO0FBQy9CLHFFQUFxRTtBQUNyRSxpRUFBaUU7QUFDakUsTUFBTUcsaUJBQWlCO0lBQUM7Q0FBTztBQUMvQixNQUFNQyxTQUFTLENBQUM7QUFDaEIsU0FBU0MsV0FBV0MsSUFBSSxFQUFFQyxLQUFLO0lBQzNCLE1BQU1DLFVBQVUsSUFBSUMsTUFBTSxDQUFDLHVEQUF1RCxFQUFFSCxLQUFLLENBQUM7SUFDMUZFLFFBQVFELEtBQUssR0FBR0E7SUFDaEIsTUFBTUM7QUFDVjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1FLGVBQWVDO0lBQ3hCLENBQUNDLEtBQUssQ0FBQztJQUNQOztLQUVDLEdBQ0RDLFlBQVksR0FBR0MsSUFBSSxDQUFFO1FBQ2pCLG9EQUFvRDtRQUNwRCx1REFBdUQ7UUFDdkQsd0RBQXdEO1FBQ3hELHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsMkVBQTJFO1FBQzNFLE1BQU1DLFFBQVFELElBQUksQ0FBQyxFQUFFO1FBQ3JCLElBQUlFLFFBQVFGLElBQUksQ0FBQyxFQUFFO1FBQ25CLElBQUlGLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUVHLEtBQUs7UUFDakMsSUFBSUMsT0FBTztRQUNYLElBQUlILFVBQVVYLFFBQVE7WUFDbEJZLFFBQVFGO1lBQ1JGLFFBQVEsRUFBRTtZQUNWTSxPQUFPO1FBQ1g7UUFDQSx5REFBeUQ7UUFDekQsa0NBQWtDO1FBQ2xDLEtBQUssQ0FBQ0YsTUFBTUcsTUFBTTtRQUNsQkgsTUFBTUksT0FBTyxDQUFDLENBQUNDLE1BQU1DO1lBQVksSUFBSSxDQUFDQSxNQUFNLEdBQUdEO1FBQU07UUFDckQsdUJB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Q0EsYUFBYTtJQUNiUSxVQUFVOUUsTUFBTSxFQUFFeUUsS0FBSyxFQUFFO1FBQ3JCLElBQUl2QixRQUFRLElBQUksQ0FBQyxDQUFDc0IsU0FBUyxDQUFDLEdBQUd4RSxRQUFRLENBQUMsQ0FBQ3lFO1FBQ3pDLElBQUksQ0FBQyxDQUFDckIsTUFBTSxJQUFJRixNQUFNbEQsTUFBTTtRQUM1QixvREFBb0Q7UUFDcEQsT0FBT2tELE1BQU1wRCxLQUFLLENBQUMsR0FBR0U7SUFDMUI7SUFDQSx3QkFBd0I7SUFDeEIrRSxZQUFZO1FBQ1IsT0FBT3RHLHlEQUFRQSxDQUFDLElBQUksQ0FBQ3FHLFNBQVMsQ0FBQ2pHO0lBQ25DO0lBQ0FtRyxZQUFZO1FBQ1IsT0FBT3RHLHlEQUFRQSxDQUFDLElBQUksQ0FBQ29HLFNBQVMsQ0FBQ2pHO0lBQ25DO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanM/YzAyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmRTaXplID0gMzI7XG5jb25zdCBQYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5leHBvcnQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgICNuYW1lcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cbiAgICAgICAgLy8gZnVuY3Rpb25zIHdvcmssIHRoZSBjb25zdHJ1Y3RvciBoYXMgdG8gYmVoYXZlIGZhaXJseVxuICAgICAgICAvLyB3ZWxsLiBTbywgaW4gdGhlIGV2ZW50IHdlIGFyZSBjcmVhdGVkIHZpYSBmcm9tSXRlbXMoKVxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXG4gICAgICAgIC8vIGFueSBvdGhlciBpbnB1dCwgd2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKGd1YXJkOiBhbnksIGl0ZW1zOiBBcnJheTxhbnk+LCBrZXlzPzogQXJyYXk8bnVsbCB8IHN0cmluZz4pO1xuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBpdGVtcyA9IGFyZ3NbMV07XG4gICAgICAgIGxldCBuYW1lcyA9IChhcmdzWzJdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XG4gICAgICAgIGlmIChndWFyZCAhPT0gX2d1YXJkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGFyZ3M7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd3JhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBpcyBhIHNwZWNpYWwgY2FzZSBpbiB0aGUgc3VwZXIuXG4gICAgICAgIHN1cGVyKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBrZXlzXG4gICAgICAgIGNvbnN0IG5hbWVDb3VudHMgPSBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtLnNldChuYW1lLCAoYWNjdW0uZ2V0KG5hbWUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIChuZXcgTWFwKCkpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBrZXkgdGhhdHMgbm90IHVuaXF1ZVxuICAgICAgICB0aGlzLiNuYW1lcyA9IE9iamVjdC5mcmVlemUoaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgbmFtZUNvdW50cy5nZXQobmFtZSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IGluZGljZXMgYW5kIG5hbWVzIHNvIHdlIGNhbiB0cmFwIGRlZmVycmVkIGVycm9yc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleCBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIocHJvcCwgXCIlaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9ucyB3b3JrIHdpdGggcHJpdmF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRWYWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBcInZhbHVlIGF0IGluZGV4ICR7IGluZGV4IH0gdW5uYW1lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvT2JqZWN0KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWVzIGZvciBuYW1lcyB0aGF0IGRvbid0IGNvbmZsaWN0XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5nZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKHRoaXMuI25hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHRoaXMuI25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBtYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGZvciAlJW5hbWUlJS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcbiAgICAgKiAgYSBtZXRob2Qgb24gYSBbW1Jlc3VsdF1dIG9yIGl0cyBzdXBlcmNsYXNzIEFycmF5LCBvciBhbnlcbiAgICAgKiAgSmF2YVNjcmlwdCBrZXl3b3JkLCB0aGlzIGVuc3VyZXMgYWxsIG5hbWVkIHZhbHVlcyBhcmUgc3RpbGxcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhbHVlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNuYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbUmVzdWx0XV0gZm9yICUlaXRlbXMlJSB3aXRoIGVhY2ggZW50cnlcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JdGVtcyhpdGVtcywga2V5cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gV29yZFNpemUpIHtcbiAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgLy8gVGhlIGNvZGVyIG5hbWU6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlLCBhcnJheSwgZXRjLlxuICAgIG5hbWU7XG4gICAgLy8gVGhlIGZ1bGx5IGV4cGFuZGVkIHR5cGUsIGluY2x1ZGluZyBjb21wb3NpdGUgdHlwZXM6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlKGFkZHJlc3MsYnl0ZXMpLCB1aW50MjU2WzNdWzRdW10sICBldGMuXG4gICAgdHlwZTtcbiAgICAvLyBUaGUgbG9jYWxOYW1lIGJvdW5kIGluIHRoZSBzaWduYXR1cmUsIGluIHRoaXMgZXhhbXBsZSBpdCBpcyBcImJhelwiOlxuICAgIC8vICAgLSB0dXBsZShhZGRyZXNzIGZvbywgdWludCBiYXIpIGJhelxuICAgIGxvY2FsTmFtZTtcbiAgICAvLyBXaGV0aGVyIHRoaXMgdHlwZSBpcyBkeW5hbWljOlxuICAgIC8vICAtIER5bmFtaWM6IGJ5dGVzLCBzdHJpbmcsIGFkZHJlc3NbXSwgdHVwbGUoYm9vbGVhbltdKSwgZXRjLlxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcbiAgICBkeW5hbWljO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRCeXRlc0NvcHkod3JpdGVyLmRhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbTsgcGFkIG9uIHRoZSByaWdodCB0byAqbmVhcmVzdCogV29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbGxvd0xvb3NlOiAhIWFsbG93TG9vc2UgfSk7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNwZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIFdvcmRTaXplKSAqIFdvcmRTaXplO1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCA+IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuI29mZnNldCArIGxlbmd0aCA8PSB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsaWduZWRMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLiNkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0LCB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgc3ViLXJlYWRlciB3aXRoIHRoZSBzYW1lIHVuZGVybHlpbmcgZGF0YSwgYnV0IG9mZnNldFxuICAgIHN1YlJlYWRlcihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UpO1xuICAgIH1cbiAgICAvLyBSZWFkIGJ5dGVzXG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnSW50KHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJjb25jYXQiLCJnZXRCeXRlc0NvcHkiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwidG9CaWdJbnQiLCJ0b051bWJlciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiV29yZFNpemUiLCJQYWRkaW5nIiwiVWludDhBcnJheSIsInBhc3NQcm9wZXJ0aWVzIiwiX2d1YXJkIiwidGhyb3dFcnJvciIsIm5hbWUiLCJlcnJvciIsIndyYXBwZWQiLCJFcnJvciIsIlJlc3VsdCIsIkFycmF5IiwibmFtZXMiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJndWFyZCIsIml0ZW1zIiwic2xpY2UiLCJ3cmFwIiwibGVuZ3RoIiwiZm9yRWFjaCIsIml0ZW0iLCJpbmRleCIsIm5hbWVDb3VudHMiLCJyZWR1Y2UiLCJhY2N1bSIsInNldCIsImdldCIsIk1hcCIsIk9iamVjdCIsImZyZWV6ZSIsIm1hcCIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiaW5kZXhPZiIsIlJlZmxlY3QiLCJ2YWx1ZSIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJnZXRWYWx1ZSIsInRvQXJyYXkiLCJyZXN1bHQiLCJwdXNoIiwidG9PYmplY3QiLCJvcGVyYXRpb24iLCJzdGFydCIsImVuZCIsImkiLCJmaWx0ZXIiLCJjYWxsYmFjayIsInRoaXNBcmciLCJjYWxsIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImZyb21JdGVtcyIsImtleXMiLCJjaGVja1Jlc3VsdEVycm9ycyIsImVycm9ycyIsImNoZWNrRXJyb3JzIiwicGF0aCIsIm9iamVjdCIsImlzQXJyYXkiLCJrZXkiLCJjaGlsZFBhdGgiLCJieXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsIkNvZGVyIiwidHlwZSIsImxvY2FsTmFtZSIsImR5bmFtaWMiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJXcml0ZXIiLCJkYXRhIiwiZGF0YUxlbmd0aCIsIndyaXRlRGF0YSIsImFwcGVuZFdyaXRlciIsIndyaXRlciIsIndyaXRlQnl0ZXMiLCJwYWRkaW5nT2Zmc2V0Iiwid3JpdGVWYWx1ZSIsIndyaXRlVXBkYXRhYmxlVmFsdWUiLCJSZWFkZXIiLCJhbGxvd0xvb3NlIiwiY29uc3VtZWQiLCJwZWVrQnl0ZXMiLCJsb29zZSIsImFsaWduZWRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsInN1YlJlYWRlciIsInJlYWRCeXRlcyIsInJlYWRWYWx1ZSIsInJlYWRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNMO0FBQ1g7QUFDUTtBQUM1Qzs7Q0FFQyxHQUNNLE1BQU1JLHFCQUFxQkQscURBQUtBO0lBQ25DRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFdBQVcsV0FBV0EsV0FBVztJQUMzQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLFFBQVFULDRDQUFLQSxDQUFDVSxXQUFXLENBQUNGLFFBQVE7UUFDdEMsSUFBSTtZQUNBQyxRQUFRWCw2REFBVUEsQ0FBQ1c7UUFDdkIsRUFDQSxPQUFPRSxPQUFPO1lBQ1YsT0FBTyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0QsTUFBTUUsT0FBTyxFQUFFTDtRQUMzQztRQUNBLE9BQU9ELE9BQU9PLFVBQVUsQ0FBQ0w7SUFDN0I7SUFDQU0sT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT2xCLDZEQUFVQSxDQUFDQyx3REFBT0EsQ0FBQ2lCLE9BQU9DLFNBQVMsSUFBSTtJQUNsRDtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanM/NTI2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsInRvQmVIZXgiLCJUeXBlZCIsIkNvZGVyIiwiQWRkcmVzc0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwiZXJyb3IiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/address.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDOzs7O0NBSUMsR0FDTSxNQUFNQyx1QkFBdUJELHFEQUFLQTtJQUVyQ0UsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsS0FBSyxDQUFDQSxNQUFNQyxJQUFJLEVBQUVELE1BQU1FLElBQUksRUFBRSxLQUFLRixNQUFNRyxPQUFPO1FBQ2hELElBQUksQ0FBQ0gsS0FBSyxHQUFHQTtJQUNqQjtJQUNBSSxlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksWUFBWTtJQUNsQztJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ1AsS0FBSyxDQUFDSyxNQUFNLENBQUNDLFFBQVFDO0lBQ3JDO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDVCxLQUFLLENBQUNRLE1BQU0sQ0FBQ0M7SUFDN0I7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanM/ZGQ5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG4gKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJBbm9ueW1vdXNDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXIiLCJuYW1lIiwidHlwZSIsImR5bmFtaWMiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anonymous.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */ class ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_4__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBOEc7QUFDMUU7QUFDa0M7QUFDdEI7QUFDaEQ7O0NBRUMsR0FDTSxTQUFTVyxLQUFLQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtJQUN2QyxJQUFJQyxjQUFjLEVBQUU7SUFDcEIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxTQUFTO1FBQ3ZCQyxjQUFjRDtJQUNsQixPQUNLLElBQUlBLFVBQVUsT0FBUUEsV0FBWSxVQUFVO1FBQzdDLElBQUlJLFNBQVMsQ0FBQztRQUNkSCxjQUFjRixPQUFPTSxHQUFHLENBQUMsQ0FBQ0M7WUFDdEIsTUFBTUMsT0FBT0QsTUFBTUUsU0FBUztZQUM1QnBCLHVEQUFNQSxDQUFDbUIsTUFBTSx5REFBeUQsb0JBQW9CO2dCQUFFRSxVQUFVO2dCQUFVQyxNQUFNO29CQUFFSjtnQkFBTTtnQkFBR0ssT0FBT1g7WUFBTztZQUMvSVosdURBQU1BLENBQUMsQ0FBQ2dCLE1BQU0sQ0FBQ0csS0FBSyxFQUFFLDJEQUEyRCxvQkFBb0I7Z0JBQUVFLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVKO2dCQUFNO2dCQUFHSyxPQUFPWDtZQUFPO1lBQzFKSSxNQUFNLENBQUNHLEtBQUssR0FBRztZQUNmLE9BQU9QLE1BQU0sQ0FBQ08sS0FBSztRQUN2QjtJQUNKLE9BQ0s7UUFDRGxCLCtEQUFjQSxDQUFDLE9BQU8sdUJBQXVCLFNBQVNXO0lBQzFEO0lBQ0FYLCtEQUFjQSxDQUFDVSxPQUFPYSxNQUFNLEtBQUtYLFlBQVlXLE1BQU0sRUFBRSwrQkFBK0IsU0FBU1o7SUFDN0YsSUFBSWEsZUFBZSxJQUFJbEIsc0RBQU1BO0lBQzdCLElBQUltQixnQkFBZ0IsSUFBSW5CLHNEQUFNQTtJQUM5QixJQUFJb0IsY0FBYyxFQUFFO0lBQ3BCaEIsT0FBT2lCLE9BQU8sQ0FBQyxDQUFDVixPQUFPVztRQUNuQixJ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QUFDK0QsUUFBUXpELHdEQUFRQSxJQUFJa0MsT0FBT3lCLFVBQVUsRUFBRSw0QkFBNEIsa0JBQWtCO2dCQUFFQyxRQUFRMUIsT0FBTzJCLEtBQUs7Z0JBQUV2QixRQUFRbUIsUUFBUXpELHdEQUFRQTtnQkFBRWtCLFFBQVFnQixPQUFPeUIsVUFBVTtZQUFDO1FBQzVLO1FBQ0EsSUFBSXRELFNBQVMsRUFBRTtRQUNmLElBQUssSUFBSWdELElBQUksR0FBR0EsSUFBSUksT0FBT0osSUFBSztZQUM1QmhELE9BQU93QixJQUFJLENBQUMsSUFBSTNCLHlEQUFjQSxDQUFDLElBQUksQ0FBQ1UsS0FBSztRQUM3QztRQUNBLE9BQU9xQixPQUFPQyxRQUFRN0I7SUFDMUI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcz9kYWQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGlzRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydEFyZ3VtZW50Q291bnQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgUmVzdWx0LCBXb3JkU2l6ZSwgV3JpdGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFub255bW91c0NvZGVyIH0gZnJvbSBcIi4vYW5vbnltb3VzLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgYXNzZXJ0KCF1bmlxdWVbbmFtZV0sIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvZGVycy5sZW5ndGggPT09IGFycmF5VmFsdWVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIGxldCBzdGF0aWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcbiAgICBsZXQgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmVzdGlnYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAga2V5cy5wdXNoKGNvZGVyLmxvY2FsTmFtZSB8fCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5Q29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgbGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyLCBsZW5ndGggfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgYXNzZXJ0KGNvdW50ICogV29yZFNpemUgPD0gcmVhZGVyLmRhdGFMZW5ndGgsIFwiaW5zdWZmaWNpZW50IGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IHJlYWRlci5ieXRlcywgb2Zmc2V0OiBjb3VudCAqIFdvcmRTaXplLCBsZW5ndGg6IHJlYWRlci5kYXRhTGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCBjb2RlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiaXNFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0QXJndW1lbnRDb3VudCIsIlR5cGVkIiwiQ29kZXIiLCJSZXN1bHQiLCJXb3JkU2l6ZSIsIldyaXRlciIsIkFub255bW91c0NvZGVyIiwicGFjayIsIndyaXRlciIsImNvZGVycyIsInZhbHVlcyIsImFycmF5VmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidW5pcXVlIiwibWFwIiwiY29kZXIiLCJuYW1lIiwibG9jYWxOYW1lIiwiYXJndW1lbnQiLCJpbmZvIiwidmFsdWUiLCJsZW5ndGgiLCJzdGF0aWNXcml0ZXIiLCJkeW5hbWljV3JpdGVyIiwidXBkYXRlRnVuY3MiLCJmb3JFYWNoIiwiaW5kZXgiLCJkeW5hbWljIiwiZHluYW1pY09mZnNldCIsImVuY29kZSIsInVwZGF0ZUZ1bmMiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwicHVzaCIsImJhc2VPZmZzZXQiLCJmdW5jIiwiYXBwZW5kV3JpdGVyIiwidW5wYWNrIiwicmVhZGVyIiwia2V5cyIsImJhc2VSZWFkZXIiLCJzdWJSZWFkZXIiLCJvZmZzZXQiLCJyZWFkSW5kZXgiLCJvZmZzZXRSZWFkZXIiLCJkZWNvZGUiLCJlcnJvciIsImJhc2VUeXBlIiwidHlwZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiZnJvbUl0ZW1zIiwiQXJyYXlDb2RlciIsImNvbnN0cnVjdG9yIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoaWxkIiwicmVzdWx0IiwiaSIsIl92YWx1ZSIsImRlcmVmZXJlbmNlIiwiX3Rocm93RXJyb3IiLCJjb3VudCIsIndyaXRlVmFsdWUiLCJkYXRhTGVuZ3RoIiwiYnVmZmVyIiwiYnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/array.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDUTtBQUM1Qzs7Q0FFQyxHQUNNLE1BQU1FLHFCQUFxQkQscURBQUtBO0lBQ25DRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFFBQVEsUUFBUUEsV0FBVztJQUNyQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLE1BQU1DLFFBQVFULDRDQUFLQSxDQUFDVSxXQUFXLENBQUNGLFFBQVE7UUFDeEMsT0FBT0QsT0FBT0ksVUFBVSxDQUFDRixRQUFRLElBQUk7SUFDekM7SUFDQUcsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxDQUFDLENBQUNBLE9BQU9DLFNBQVM7SUFDN0I7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzPzczZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYm9vbFwiKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAhIXJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCJdLCJuYW1lcyI6WyJUeXBlZCIsIkNvZGVyIiwiQm9vbGVhbkNvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/boolean.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2RDtBQUNqQjtBQUM1Qzs7Q0FFQyxHQUNNLE1BQU1HLDBCQUEwQkQscURBQUtBO0lBQ3hDRSxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsQ0FBRTtRQUN6QixLQUFLLENBQUNELE1BQU1BLE1BQU1DLFdBQVc7SUFDakM7SUFDQUMsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNsQkEsUUFBUVYsNkRBQVlBLENBQUNVO1FBQ3JCLElBQUlDLFNBQVNGLE9BQU9HLFVBQVUsQ0FBQ0YsTUFBTUMsTUFBTTtRQUMzQ0EsVUFBVUYsT0FBT0ksVUFBVSxDQUFDSDtRQUM1QixPQUFPQztJQUNYO0lBQ0FHLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9BLE9BQU9DLFNBQVMsQ0FBQ0QsT0FBT0UsU0FBUyxJQUFJO0lBQ2hEO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLG1CQUFtQmY7SUFDNUJDLFlBQVlFLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsU0FBU0E7SUFDbkI7SUFDQVEsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT2Qsd0RBQU9BLENBQUMsS0FBSyxDQUFDYSxPQUFPQztJQUNoQztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzPzU4ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiQ29kZXIiLCJEeW5hbWljQnl0ZXNDb2RlciIsImNvbnN0cnVjdG9yIiwidHlwZSIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwibGVuZ3RoIiwid3JpdGVWYWx1ZSIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiLCJyZWFkSW5kZXgiLCJCeXRlc0NvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/bytes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */ class FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(reader.readBytes(this.size));\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0U7QUFDM0M7QUFDUTtBQUM1Qzs7Q0FFQyxHQUNNLE1BQU1LLHdCQUF3QkQscURBQUtBO0lBRXRDRSxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsQ0FBRTtRQUN6QixJQUFJQyxPQUFPLFVBQVVDLE9BQU9IO1FBQzVCLEtBQUssQ0FBQ0UsTUFBTUEsTUFBTUQsV0FBVztRQUM3QlIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFTztRQUFLLEdBQUc7WUFBRUEsTUFBTTtRQUFTO0lBQ3REO0lBQ0FJLGVBQWU7UUFDWCxPQUFPLHFFQUF1RUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUNMLElBQUksR0FBRztJQUMvRztJQUNBTSxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixJQUFJQyxPQUFPZiw2REFBWUEsQ0FBQ0UsNENBQUtBLENBQUNjLFdBQVcsQ0FBQ0YsUUFBUSxJQUFJLENBQUNHLElBQUk7UUFDM0QsSUFBSUYsS0FBS0csTUFBTSxLQUFLLElBQUksQ0FBQ1osSUFBSSxFQUFFO1lBQzNCLElBQUksQ0FBQ2EsV0FBVyxDQUFDLHlCQUF5Qkw7UUFDOUM7UUFDQSxPQUFPRCxPQUFPTyxVQUFVLENBQUNMO0lBQzdCO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9yQix3REFBT0EsQ0FBQ3FCLE9BQU9DLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixJQUFJO0lBQzdDO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/MGUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXNDb3B5KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiVHlwZWQiLCJDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsImxvY2FsTmFtZSIsIm5hbWUiLCJTdHJpbmciLCJkZWZhdWx0VmFsdWUiLCJzdWJzdHJpbmciLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkYXRhIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibGVuZ3RoIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/null.js":
/*!************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVsbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM1QyxNQUFNQyxRQUFRLElBQUlDLFdBQVcsRUFBRTtBQUMvQjs7Q0FFQyxHQUNNLE1BQU1DLGtCQUFrQkgscURBQUtBO0lBQ2hDSSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFFBQVEsSUFBSUEsV0FBVztJQUNqQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLElBQUlBLFNBQVMsTUFBTTtZQUNmLElBQUksQ0FBQ0MsV0FBVyxDQUFDLFlBQVlEO1FBQ2pDO1FBQ0EsT0FBT0QsT0FBT0csVUFBVSxDQUFDVjtJQUM3QjtJQUNBVyxPQUFPQyxNQUFNLEVBQUU7UUFDWEEsT0FBT0MsU0FBUyxDQUFDO1FBQ2pCLE9BQU87SUFDWDtBQUNKLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanM/N2U4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKEVtcHR5KTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlciIsIkVtcHR5IiwiVWludDhBcnJheSIsIk51bGxDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJfdGhyb3dFcnJvciIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/null.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        } else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJGO0FBQ3ZEO0FBQ2tCO0FBQ3RELE1BQU1RLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxpQkFBaUJGLE9BQU87QUFDOUI7O0NBRUMsR0FDTSxNQUFNRyxvQkFBb0JOLHFEQUFLQTtJQUdsQ08sWUFBWUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsQ0FBRTtRQUNqQyxNQUFNQyxPQUFRLENBQUNGLFNBQVMsUUFBUSxNQUFLLElBQU1ELE9BQU87UUFDbEQsS0FBSyxDQUFDRyxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCaEIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFYztZQUFNQztRQUFPLEdBQUc7WUFBRUQsTUFBTTtZQUFVQyxRQUFRO1FBQVU7SUFDakY7SUFDQUcsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixJQUFJQyxRQUFRcEIsMERBQVNBLENBQUNHLDRDQUFLQSxDQUFDa0IsV0FBVyxDQUFDRixRQUFRLElBQUksQ0FBQ0csSUFBSTtRQUN6RCxxQ0FBcUM7UUFDckMsSUFBSUMsZUFBZXRCLHFEQUFJQSxDQUFDUSxnQkFBZ0JKLHdEQUFRQSxHQUFHO1FBQ25ELElBQUksSUFBSSxDQUFDUSxNQUFNLEVBQUU7WUFDYixJQUFJVyxTQUFTdkIscURBQUlBLENBQUNzQixjQUFjLElBQUssQ0FBQ1gsSUFBSSxHQUFHLElBQUs7WUFDbEQsSUFBSVEsUUFBUUksVUFBVUosUUFBUSxDQUFFSSxDQUFBQSxTQUFTaEIsSUFBRyxHQUFJO2dCQUM1QyxJQUFJLENBQUNpQixXQUFXLENBQUMsdUJBQXVCTjtZQUM1QztZQUNBQyxRQUFRbEIsdURBQU1BLENBQUNrQixPQUFPLElBQUlmLHdEQUFRQTtRQUN0QyxPQUNLLElBQUllLFFBQVFkLFFBQVFjLFFBQVFuQixxREFBSUEsQ0FBQ3NCLGNBQWMsSUFBSSxDQUFDWCxJQUFJLEdBQUcsSUFBSTtZQUNoRSxJQUFJLENBQUNhLFdBQVcsQ0FBQyx1QkFBdUJOO1FBQzVDO1FBQ0EsT0FBT0QsT0FBT1EsVUFBVSxDQUFDTjtJQUM3QjtJQUNBTyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxJQUFJUixRQUFRbkIscURBQUlBLENBQUMyQixPQUFPQyxTQUFTLElBQUksSUFBSSxDQUFDakIsSUFBSSxHQUFHO1FBQ2pELElBQUksSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDYk8sUUFBUXJCLHlEQUFRQSxDQUFDcUIsT0FBTyxJQUFJLENBQUNSLElBQUksR0FBRztRQUN4QztRQUNBLE9BQU9RO0lBQ1g7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanM/MjE2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBmcm9tVHdvcywgZ2V0QmlnSW50LCBtYXNrLCB0b1R3b3MgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgV29yZFNpemUgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdW1iZXJDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIHNpZ25lZDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBzaWduZWQsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSwgc2lnbmVkIH0sIHsgc2l6ZTogXCJudW1iZXJcIiwgc2lnbmVkOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBXb3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXNrKG1heFVpbnRWYWx1ZSwgKHRoaXMuc2l6ZSAqIDgpIC0gMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBib3VuZHMgfHwgdmFsdWUgPCAtKGJvdW5kcyArIEJOXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdG9Ud29zKHZhbHVlLCA4ICogV29yZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgQk5fMCB8fCB2YWx1ZSA+IG1hc2sobWF4VWludFZhbHVlLCB0aGlzLnNpemUgKiA4KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hc2socmVhZGVyLnJlYWRWYWx1ZSgpLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21Ud29zKHZhbHVlLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZnJvbVR3b3MiLCJnZXRCaWdJbnQiLCJtYXNrIiwidG9Ud29zIiwiVHlwZWQiLCJDb2RlciIsIldvcmRTaXplIiwiQk5fMCIsIkJpZ0ludCIsIkJOXzEiLCJCTl9NQVhfVUlOVDI1NiIsIk51bWJlckNvZGVyIiwiY29uc3RydWN0b3IiLCJzaXplIiwic2lnbmVkIiwibG9jYWxOYW1lIiwibmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibWF4VWludFZhbHVlIiwiYm91bmRzIiwiX3Rocm93RXJyb3IiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/number.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */ class StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0U7QUFDNUI7QUFDVztBQUMvQzs7Q0FFQyxHQUNNLE1BQU1JLG9CQUFvQkQsd0RBQWlCQTtJQUM5Q0UsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxVQUFVQTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLE9BQU8sS0FBSyxDQUFDRixPQUFPQyxRQUFRVCwyREFBV0EsQ0FBQ0UsNENBQUtBLENBQUNTLFdBQVcsQ0FBQ0QsUUFBUTtJQUN0RTtJQUNBRSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPWiw0REFBWUEsQ0FBQyxLQUFLLENBQUNXLE9BQU9DO0lBQ3JDO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzPzRlOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlscy91dGY4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgRHluYW1pY0J5dGVzQ29kZXIgfSBmcm9tIFwiLi9ieXRlcy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcInN0cmluZ1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIikpKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwiVHlwZWQiLCJEeW5hbWljQnl0ZXNDb2RlciIsIlN0cmluZ0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/string.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvdHVwbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNkQ7QUFDekI7QUFDUTtBQUNGO0FBQzFDOztDQUVDLEdBQ00sTUFBTUssbUJBQW1CSCxxREFBS0E7SUFFakNJLFlBQVlDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQzNCLElBQUlDLFVBQVU7UUFDZCxNQUFNQyxRQUFRLEVBQUU7UUFDaEJILE9BQU9JLE9BQU8sQ0FBQyxDQUFDQztZQUNaLElBQUlBLE1BQU1ILE9BQU8sRUFBRTtnQkFDZkEsVUFBVTtZQUNkO1lBQ0FDLE1BQU1HLElBQUksQ0FBQ0QsTUFBTUUsSUFBSTtRQUN6QjtRQUNBLE1BQU1BLE9BQVEsV0FBV0osTUFBTUssSUFBSSxDQUFDLE9BQU87UUFDM0MsS0FBSyxDQUFDLFNBQVNELE1BQU1OLFdBQVdDO1FBQ2hDVCxzRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVPLFFBQVFTLE9BQU9DLE1BQU0sQ0FBQ1YsT0FBT1csS0FBSztRQUFJO0lBQ25FO0lBQ0FDLGVBQWU7UUFDWCxNQUFNQyxTQUFTLEVBQUU7UUFDakIsSUFBSSxDQUFDYixNQUFNLENBQUNJLE9BQU8sQ0FBQyxDQUFDQztZQUNqQlEsT0FBT1AsSUFBSSxDQUFDRCxNQUFNTyxZQUFZO1FBQ2xDO1FBQ0EsNERBQTREO1FBQzVELE1BQU1FLGNBQWMsSUFBSSxDQUFDZCxNQUFNLENBQUNlLE1BQU0sQ0FBQyxDQUFDQyxPQUFPWDtZQUMzQyxNQUFNWSxPQUFPWixNQUFNSixTQUFTO1lBQzVCLElBQUlnQixNQUFNO2dCQUNOLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxLQUFLLEVBQUU7b0JBQ2RELEtBQUssQ0FBQ0MsS0FBSyxHQUFHO2dCQUNsQjtnQkFDQUQsS0FBSyxDQUFDQyxLQUFLO1lBQ2Y7WUFDQSxPQUFPRDtRQUNYLEdBQUcsQ0FBQztRQUNKLG1CQUFtQjtRQUNuQixJQUFJLENBQUNoQixNQUFNLENBQUNJLE9BQU8sQ0FBQyxDQUFDQyxPQUFPYTtZQUN4QixJQUFJRCxPQUFPWixNQUFNSixTQUFTO1lBQzFCLElBQUksQ0FBQ2dCLFFBQVFILFdBQVcsQ0FBQ0csS0FBSyxLQUFLLEdBQUc7Z0JBQ2xDO1lBQ0o7WUFDQSxJQUFJQSxTQUFTLFVBQVU7Z0JBQ25CQSxPQUFPO1lBQ1g7WUFDQSxJQUFJSixNQUFNLENBQUNJLEtBQUssSUFBSSxNQUFNO2dCQUN0QjtZQUNKO1lBQ0FKLE1BQU0sQ0FBQ0ksS0FBSyxHQUFHSixNQUFNLENBQUNLLE1BQU07UUFDaEM7UUFDQSxPQUFPVCxPQUFPQyxNQUFNLENBQUNHO0lBQ3pCO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLE1BQU1DLFFBQVE1Qiw0Q0FBS0EsQ0FBQzZCLFdBQVcsQ0FBQ0YsUUFBUTtRQUN4QyxPQUFPekIsK0NBQUlBLENBQUN3QixRQUFRLElBQUksQ0FBQ3BCLE1BQU0sRUFBRXNCO0lBQ3JDO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU81QixpREFBTUEsQ0FBQzRCLFFBQVEsSUFBSSxDQUFDekIsTUFBTTtJQUNyQztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzPzRmOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIlR5cGVkIiwiQ29kZXIiLCJwYWNrIiwidW5wYWNrIiwiVHVwbGVDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXJzIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsInR5cGVzIiwiZm9yRWFjaCIsImNvZGVyIiwicHVzaCIsInR5cGUiLCJqb2luIiwiT2JqZWN0IiwiZnJlZXplIiwic2xpY2UiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZXMiLCJ1bmlxdWVOYW1lcyIsInJlZHVjZSIsImFjY3VtIiwibmFtZSIsImluZGV4IiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/coders/tuple.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/fragments.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/fragments.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ \n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() {\n        return this.#offset;\n    }\n    get length() {\n        return this.#tokens.length - this.#offset;\n    }\n    constructor(tokens){\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() {\n        return new TokenString(this.#tokens);\n    }\n    reset() {\n        this.#offset = 0;\n    }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t)=>{\n            return Object.freeze(Object.assign({}, t, {\n                match: t.match - from,\n                linkBack: t.linkBack - from,\n                linkNext: t.linkNext - from\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while(this.#offset < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = this.#offset; i < this.#tokens.length; i++){\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        } else {\n            if (this.isTuple()) {\n                if (format !== \"sighash\") {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index)=>{\n                childType.#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            } else {\n                if (value == null || typeof value !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param)=>{\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index)=>{\n                components[index].#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push(async function() {\n                setValue(await result);\n            }());\n        } else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        this.#walkAsync(promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = `tuple(${comps.map((c)=>c.format()).join(\",\")})`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            anonymous\n        });\n    }\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            `constructor${joinParams(format, this.inputs)}`\n        ];\n        result.push(this.payable ? \"payable\" : \"nonpayable\");\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable\n        });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDaUg7QUFDNUU7O0FBRXRDLHFDQUFxQztBQUNyQyxTQUFTTyxPQUFPQyxLQUFLO0lBQ2pCLE1BQU1DLFNBQVMsSUFBSUM7SUFDbkJGLE1BQU1HLE9BQU8sQ0FBQyxDQUFDQyxJQUFNSCxPQUFPSSxHQUFHLENBQUNEO0lBQ2hDLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ047QUFDekI7QUFDQSxNQUFNTyxpQkFBaUI7QUFDdkIsTUFBTUMsZ0JBQWdCVixPQUFPUyxlQUFlRSxLQUFLLENBQUM7QUFDbEQsc0JBQXNCO0FBQ3RCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsVUFBVWIsT0FBT1ksU0FBU0QsS0FBSyxDQUFDO0FBQ3RDLE1BQU1HLFdBQVc7QUFDakIsTUFBTUMsVUFBVWYsT0FBT2MsU0FBU0gsS0FBSyxDQUFDO0FBQ3RDLE1BQU1LLGVBQWU7QUFDckIsTUFBTUMsY0FBY2pCLE9BQU9nQixhQUFhTCxLQUFLLENBQUM7QUFDOUMsTUFBTU8sV0FBVztBQUNqQixlQUFlO0FBQ2YsTUFBTUMsWUFBWTtJQUFDTDtJQUFVRTtJQUFjRTtJQUFVTjtDQUFTLENBQUNRLElBQUksQ0FBQztBQUNwRSxNQUFNQyxXQUFXckIsT0FBT21CLFVBQVVSLEtBQUssQ0FBQztBQUN4QywwQkFBMEI7QUFDMUIsTUFBTVcsZUFBZTtJQUNqQixLQUFLO0lBQWMsS0FBSztJQUN4QixLQUFLO0lBQWdCLEtBQUs7SUFDMUIsS0FBSztJQUFTLEtBQUs7QUFDdkI7QUFDQSwyQ0FBMkM7QUFDM0MsTUFBTUMsd0JBQXdCLElBQUlDLE9BQU87QUFDekMsTUFBTUMsb0JBQW9CLElBQUlELE9BQU87QUFDckMsTUFBTUUsZ0JBQWdCLElBQUlGLE9BQU87QUFDakMsa0NBQWtDO0FBQ2xDLE1BQU1HLFVBQVUsSUFBSUgs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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9mcmFnbWVudHMuanM/OWYyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGZyYWdtZW50IGlzIGEgc2luZ2xlIGl0ZW0gZnJvbSBhbiBBQkksIHdoaWNoIG1heSByZXByZXNlbnQgYW55IG9mOlxuICpcbiAqICAtIFtGdW5jdGlvbnNdKEZ1bmN0aW9uRnJhZ21lbnQpXG4gKiAgLSBbRXZlbnRzXShFdmVudEZyYWdtZW50KVxuICogIC0gW0NvbnN0cnVjdG9yc10oQ29uc3RydWN0b3JGcmFnbWVudClcbiAqICAtIEN1c3RvbSBbRXJyb3JzXShFcnJvckZyYWdtZW50KVxuICogIC0gW0ZhbGxiYWNrIG9yIFJlY2VpdmVdKEZhbGxiYWNrRnJhZ21lbnQpIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6RnJhZ21lbnRzICBbYWJvdXQtZnJhZ21lbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgYXNzZXJ0LCBhc3NlcnRQcml2YXRlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuO1xuLy8gWyBcImFcIiwgXCJiXCIgXSA9PiB7IFwiYVwiOiAxLCBcImJcIjogMSB9XG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgaXRlbXMuZm9yRWFjaCgoaykgPT4gcmVzdWx0LmFkZChrKSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbn1cbmNvbnN0IF9rd1Zpc2liRGVwbG95ID0gXCJleHRlcm5hbCBwdWJsaWMgcGF5YWJsZVwiO1xuY29uc3QgS3dWaXNpYkRlcGxveSA9IHNldGlmeShfa3dWaXNpYkRlcGxveS5zcGxpdChcIiBcIikpO1xuLy8gVmlzaWJpbGl0eSBLZXl3b3Jkc1xuY29uc3QgX2t3VmlzaWIgPSBcImNvbnN0YW50IGV4dGVybmFsIGludGVybmFsIHBheWFibGUgcHJpdmF0ZSBwdWJsaWMgcHVyZSB2aWV3XCI7XG5jb25zdCBLd1Zpc2liID0gc2V0aWZ5KF9rd1Zpc2liLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dUeXBlcyA9IFwiY29uc3RydWN0b3IgZXJyb3IgZXZlbnQgZmFsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZSBzdHJ1Y3RcIjtcbmNvbnN0IEt3VHlwZXMgPSBzZXRpZnkoX2t3VHlwZXMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd01vZGlmaWVycyA9IFwiY2FsbGRhdGEgbWVtb3J5IHN0b3JhZ2UgcGF5YWJsZSBpbmRleGVkXCI7XG5jb25zdCBLd01vZGlmaWVycyA9IHNldGlmeShfa3dNb2RpZmllcnMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd090aGVyID0gXCJ0dXBsZSByZXR1cm5zXCI7XG4vLyBBbGwgS2V5d29yZHNcbmNvbnN0IF9rZXl3b3JkcyA9IFtfa3dUeXBlcywgX2t3TW9kaWZpZXJzLCBfa3dPdGhlciwgX2t3VmlzaWJdLmpvaW4oXCIgXCIpO1xuY29uc3QgS2V5d29yZHMgPSBzZXRpZnkoX2tleXdvcmRzLnNwbGl0KFwiIFwiKSk7XG4vLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xuY29uc3QgU2ltcGxlVG9rZW5zID0ge1xuICAgIFwiKFwiOiBcIk9QRU5fUEFSRU5cIiwgXCIpXCI6IFwiQ0xPU0VfUEFSRU5cIixcbiAgICBcIltcIjogXCJPUEVOX0JSQUNLRVRcIiwgXCJdXCI6IFwiQ0xPU0VfQlJBQ0tFVFwiLFxuICAgIFwiLFwiOiBcIkNPTU1BXCIsIFwiQFwiOiBcIkFUXCJcbn07XG4vLyBQYXJzZXIgcmVnZXhlcyB0byBjb25zdW1lIHRoZSBuZXh0IHRva2VuXG5jb25zdCByZWdleFdoaXRlc3BhY2VQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIpO1xuY29uc3QgcmVnZXhOdW1iZXJQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbMC05XSspXCIpO1xuY29uc3QgcmVnZXhJZFByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcIik7XG4vLyBQYXJzZXIgcmVnZXhzIHRvIGNoZWNrIHZhbGlkaXR5XG5jb25zdCByZWdleElkID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKSRcIik7XG5jb25zdCByZWdleFR5cGUgPSBuZXcgUmVnRXhwKFwiXihhZGRyZXNzfGJvb2x8Ynl0ZXMoWzAtOV0qKXxzdHJpbmd8dT9pbnQoWzAtOV0qKSkkXCIpO1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICAgICNvZmZzZXQ7XG4gICAgI3Rva2VucztcbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3Rva2Vucy5sZW5ndGggLSB0aGlzLiNvZmZzZXQ7IH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy4jdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7XG4gICAgfVxuICAgIGNsb25lKCkgeyByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucyk7IH1cbiAgICByZXNldCgpIHsgdGhpcy4jb2Zmc2V0ID0gMDsgfVxuICAgICNzdWJUb2tlblN0cmluZyhmcm9tID0gMCwgdG8gPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zLnNsaWNlKGZyb20sIHRvKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICAgICAgICAgICAgICBtYXRjaDogKHQubWF0Y2ggLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rQmFjazogKHQubGlua0JhY2sgLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rTmV4dDogKHQubGlua05leHQgLSBmcm9tKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGFsbG93ZWQ7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiS0VZV09SRFwiIHx8ICFhbGxvd2VkLmhhcyh0b3AudGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5d29yZCAke3RvcC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfTsgZ290ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5wZWVrKCkpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgYSBcIihcIiBUT0tFTlMgXCIpXCJcbiAgICBwb3BQYXJlbigpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCB0b3AubWF0Y2ggKyAxKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgd2l0aGluIFwiKFwiIElURU0xIFwiLFwiIElURU0yIFwiLFwiIC4uLiBcIilcIlxuICAgIHBvcFBhcmFtcygpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuI29mZnNldCA8IHRvcC5tYXRjaCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnBlZWsoKS5saW5rTmV4dDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIGxpbmspKTtcbiAgICAgICAgICAgIHRoaXMuI29mZnNldCA9IGxpbms7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdG9wIFRva2VuLCB0aHJvd2luZyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCA+PSB0aGlzLiN0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN0b2tlbnNbdGhpcy4jb2Zmc2V0XTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB2YWx1ZSwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGBhbGxvd2VkYFxuICAgIHBlZWtLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIHJldHVybiAodG9wICE9IG51bGwgJiYgYWxsb3dlZC5oYXModG9wKSkgPyB0b3AgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWBcbiAgICBwZWVrVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHJldHVybiAodG9wLnR5cGUgPT09IHR5cGUpID8gdG9wLnRleHQgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHRva2VuOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHRoaXMuI29mZnNldCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNvZmZzZXQ7IGkgPCB0aGlzLiN0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy4jdG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goYCR7dG9rZW4udHlwZX06JHt0b2tlbi50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPFRva2VuU3RyaW5nICR7dG9rZW5zLmpvaW4oXCIgXCIpfT5gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gKG9mZnNldCA8IHRleHQubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KHRleHRbb2Zmc2V0XSkgOiBcIiRFT0lcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRva2VuICR7dG9rZW59IGF0ICR7b2Zmc2V0fTogJHttZXNzYWdlfWApO1xuICAgIH07XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgbGV0IGNvbW1hcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgYW55IGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICBsZXQgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgbGV0IG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4V2hpdGVzcGFjZVByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB7IGRlcHRoOiBicmFja2V0cy5sZW5ndGgsIGxpbmtCYWNrOiAtMSwgbGlua05leHQ6IC0xLCBtYXRjaDogLTEsIHR5cGU6IFwiXCIsIHRleHQ6IFwiXCIsIG9mZnNldCwgdmFsdWU6IC0xIH07XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgbGV0IHR5cGUgPSAoU2ltcGxlVG9rZW5zW2N1clswXV0gfHwgXCJcIik7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBjdXJbMF07XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJDTE9TRV9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwibm8gbWF0Y2hpbmcgb3BlbiBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaCA9IGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubWF0Y2hdKS5tYXRjaCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHRva2VuLmRlcHRoLS07XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNPTU1BXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIk9QRU5fQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiQlJBQ0tFVFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDTE9TRV9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIENMT1NFX0JSQUNLRVRcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJOVU1CRVJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB2YWx1ZSArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnZhbHVlID0gZ2V0TnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSBcIkJSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG9wZW5pbmcgYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnRleHQgKz0gc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhJZFByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKEtleXdvcmRzLmhhcyh0b2tlbi50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIktFWVdPUkRcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50ZXh0Lm1hdGNoKHJlZ2V4VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJUWVBFXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhOdW1iZXJQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIk5VTUJFUlwiO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuICR7SlNPTi5zdHJpbmdpZnkoY3VyWzBdKX0gYXQgcG9zaXRpb24gJHtvZmZzZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodG9rZW5zLm1hcCgodCkgPT4gT2JqZWN0LmZyZWV6ZSh0KSkpO1xufVxuLy8gQ2hlY2sgb25seSBvbmUgb2YgYGFsbG93ZWRgIGlzIGluIGBzZXRgXG5mdW5jdGlvbiBhbGxvd1NpbmdsZShzZXQsIGFsbG93ZWQpIHtcbiAgICBsZXQgaW5jbHVkZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxvd2VkLmtleXMoKSkge1xuICAgICAgICBpZiAoc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBpbmNsdWRlZC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluY2x1ZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25mbGljdGluZyB0eXBlczogJHtpbmNsdWRlZC5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuLy8gRnVuY3Rpb25zIHRvIHByb2Nlc3MgYSBTb2xpZGl0eSBTaWduYXR1cmUgVG9rZW5TdHJpbmcgZnJvbSBsZWZ0LXRvLXJpZ2h0IGZvci4uLlxuLy8gLi4udGhlIG5hbWUgd2l0aCBhbiBvcHRpb25hbCB0eXBlLCByZXR1cm5pbmcgdGhlIG5hbWVcbmZ1bmN0aW9uIGNvbnN1bWVOYW1lKHR5cGUsIHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla0tleXdvcmQoS3dUeXBlcykpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICBpZiAoa2V5d29yZCAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9LCBnb3QgJHtrZXl3b3JkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnMucG9wVHlwZShcIklEXCIpO1xufVxuLy8gLi4uYWxsIGtleXdvcmRzIG1hdGNoaW5nIGFsbG93ZWQsIHJldHVybmluZyB0aGUga2V5d29yZHNcbmZ1bmN0aW9uIGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIGFsbG93ZWQpIHtcbiAgICBjb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgaWYgKGtleXdvcmQgPT0gbnVsbCB8fCAoYWxsb3dlZCAmJiAhYWxsb3dlZC5oYXMoa2V5d29yZCkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoa2V5d29yZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIGtleXdvcmRzOiAke0pTT04uc3RyaW5naWZ5KGtleXdvcmQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRzLmFkZChrZXl3b3JkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoa2V5d29yZHMpO1xufVxuLy8gLi4uYWxsIHZpc2liaWxpdHkga2V5d29yZHMsIHJldHVybmluZyB0aGUgY29hbGVzY2VkIG11dGFiaWxpdHlcbmZ1bmN0aW9uIGNvbnN1bWVNdXRhYmlsaXR5KHRva2Vucykge1xuICAgIGxldCBtb2RpZmllcnMgPSBjb25zdW1lS2V5d29yZHModG9rZW5zLCBLd1Zpc2liKTtcbiAgICAvLyBEZXRlY3QgY29uZmxpY3RpbmcgbW9kaWZpZXJzXG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJjb25zdGFudCBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcInB1cmUgdmlldyBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICAvLyBQcm9jZXNzIG11dGFiaWxpdHkgc3RhdGVzXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJ2aWV3XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwdXJlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInB1cmVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInBheWFibGVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJub25wYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBsZWdhY3kgYGNvbnN0YW50YCBsYXN0XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJjb25zdGFudFwiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbn1cbi8vIC4uLmEgcGFyYW1ldGVyIGxpc3QsIHJldHVybmluZyB0aGUgUGFyYW1UeXBlIGxpc3RcbmZ1bmN0aW9uIGNvbnN1bWVQYXJhbXModG9rZW5zLCBhbGxvd0luZGV4ZWQpIHtcbiAgICByZXR1cm4gdG9rZW5zLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCwgYWxsb3dJbmRleGVkKSk7XG59XG4vLyAuLi5hIGdhcyBsaW1pdCwgcmV0dXJuaW5nIGEgQmlnTnVtYmVyIG9yIG51bGwgaWYgbm9uZVxuZnVuY3Rpb24gY29uc3VtZUdhcyh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiQVRcIikpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiTlVNQkVSXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHRva2Vucy5wb3AoKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGdhc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb25zdW1lRW9pKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbnM6ICR7dG9rZW5zLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxufVxuY29uc3QgcmVnZXhBcnJheVR5cGUgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuZnVuY3Rpb24gdmVyaWZ5QmFzaWNUeXBlKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhUeXBlKTtcbiAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcInVpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJ1aW50MjU2XCI7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBcImludDI1NlwiO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgLy8gYnl0ZXNYWFxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAvLyBpbnRYWCBvciB1aW50WFhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuLy8gTWFrZSB0aGUgRnJhZ21lbnQgY29uc3RydWN0b3JzIGVmZmVjdGl2ZWx5IHByaXZhdGVcbmNvbnN0IF9ndWFyZCA9IHt9O1xuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc19pbnRlcm5hbFwiKTtcbmNvbnN0IFBhcmFtVHlwZUludGVybmFsID0gXCJfUGFyYW1UeXBlSW50ZXJuYWxcIjtcbmNvbnN0IEVycm9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Vycm9ySW50ZXJuYWxcIjtcbmNvbnN0IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCA9IFwiX0V2ZW50SW50ZXJuYWxcIjtcbmNvbnN0IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0NvbnN0cnVjdG9ySW50ZXJuYWxcIjtcbmNvbnN0IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0ZhbGxiYWNrSW50ZXJuYWxcIjtcbmNvbnN0IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Z1bmN0aW9uSW50ZXJuYWxcIjtcbmNvbnN0IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgPSBcIl9TdHJ1Y3RJbnRlcm5hbFwiO1xuLyoqXG4gKiAgRWFjaCBpbnB1dCBhbmQgb3V0cHV0IG9mIGEgW1tGcmFnbWVudF1dIGlzIGFuIEFycmF5IG9mICoqUGFyYW1UeXBlKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9jYWwgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIChvciBgYFwiXCJgYCBpZiB1bmJvdW5kKVxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxseSBxdWFsaWZpZWQgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZShhZGRyZXNzKVwiYGAsXG4gICAgICogIGBgXCJ1aW50MjU2WzNdW11cImBgKVxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGVcImBgLCBgYFwiYXJyYXlcImBgKVxuICAgICAqL1xuICAgIGJhc2VUeXBlO1xuICAgIC8qKlxuICAgICAqICBUcnVlIGlmIHRoZSBwYXJhbWV0ZXJzIGlzIGluZGV4ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1pbmRleGFibGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBpbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcG9uZW50cyBmb3IgdGhlIHR1cGxlLlxuICAgICAqXG4gICAgICogIEZvciBub24tdHVwbGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJyYXkgbGVuZ3RoLCBvciBgYC0xYGAgZm9yIGR5bmFtaWMtbGVuZ3RoZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUxlbmd0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgZWFjaCBjaGlsZCBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5Q2hpbGRyZW47XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiUGFyYW1UeXBlXCIpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFBhcmFtVHlwZUludGVybmFsIH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IE9iamVjdC5mcmVlemUoY29tcG9uZW50cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoID09IG51bGwgfHwgYXJyYXlDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5TGVuZ3RoICE9IG51bGwgfHwgYXJyYXlDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLFxuICAgICAqXG4gICAgICogIGBgc2lnaGFzaFwiID0+IFwiKHVpbnQyNTYsYWRkcmVzcylcImBgXG4gICAgICpcbiAgICAgKiAgYGBcIm1pbmltYWxcIiA9PiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiYGBcbiAgICAgKlxuICAgICAqICBgYFwiZnVsbFwiID0+IFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiYGBcbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXhlZCA9IHRoaXMuaW5kZXhlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoYykgPT4gSlNPTi5wYXJzZShjLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiZnVsbFwiICYmIHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEFycmF5IHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2FycmF5Q2hpbGRyZW5dXVxuICAgICAqICBhbmQgW1thcnJheUxlbmd0aF1dIGFyZSBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0FycmF5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYSBUdXBsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tjb21wb25lbnRzXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNUdXBsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEluZGV4YWJsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tpbmRleGVkXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNJbmRleGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleGVkICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGNhbGxpbmcgJSVwcm9jZXNzJSVcbiAgICAgKiAgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqL1xuICAgIHdhbGsodmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiAoX3RoaXMuYXJyYXlDaGlsZHJlbi53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiAoX3RoaXMuY29tcG9uZW50c1tpXS53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgICN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCBzZXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IHRoaXMuYXJyYXlDaGlsZHJlbjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRUeXBlLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cztcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiAodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudHMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2Ugb2JqZWN0IHZhbHVlIHdpdGggdW5uYW1lZCBjb21wb25lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtLm5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGNvbXBvbmVudCAke3BhcmFtLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3BhcmFtLm5hbWVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpbmRleF0uI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHNldFZhbHVlKGF3YWl0IHJlc3VsdCk7IH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGFzeW5jaHJvbm91c2x5IGNhbGxpbmdcbiAgICAgKiAgJSVwcm9jZXNzJSUgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBFTlMgbmFlcyBieSB3YWxraW5nIGFuZCByZXNvbHZpbmcgZWFjaFxuICAgICAqICBgYFwiYWRkcmVzc1wiYGAgdHlwZS5cbiAgICAgKi9cbiAgICBhc3luYyB3YWxrQXN5bmModmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3ZhbHVlXTtcbiAgICAgICAgdGhpcy4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlBhcmFtVHlwZSoqIGZvciAlJW9iaiUlLlxuICAgICAqXG4gICAgICogIElmICUlYWxsb3dJbmRleGVkJSUgdGhlbiB0aGUgYGBpbmRleGVkYGAga2V5d29yZCBpcyBwZXJtaXR0ZWQsXG4gICAgICogIG90aGVyd2lzZSB0aGUgYGBpbmRleGVkYGAga2V5d29yZCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaiwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbShsZXgob2JqKSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgcGFyYW0gdHlwZVwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IFwiXCIsIGJhc2VUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIGxldCBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInR1cGxlXCJdKSkuaGFzKFwidHVwbGVcIikgfHwgb2JqLnBlZWtUeXBlKFwiT1BFTl9QQVJFTlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcInR1cGxlXCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBvYmoucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0KSk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGB0dXBsZSgke2NvbXBzLm1hcCgoYykgPT4gYy5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxcbiAgICAgICAgICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai5wb3BUeXBlKFwiVFlQRVwiKSk7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEFycmF5XG4gICAgICAgICAgICBsZXQgYXJyYXlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyYXlMZW5ndGggPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKG9iai5sZW5ndGggJiYgb2JqLnBlZWtUeXBlKFwiQlJBQ0tFVFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXQgPSBvYmoucG9wKCk7IC8vYXJyYXlzW2ldO1xuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW4gPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgXCJcIiwgdHlwZSwgYmFzZVR5cGUsIG51bGwsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggPSBicmFja2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gYnJhY2tldC50ZXh0O1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRleGVkID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzID0gY29uc3VtZUtleXdvcmRzKG9iaiwgS3dNb2RpZmllcnMpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhcImluZGV4ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IChvYmoucGVla1R5cGUoXCJJRFwiKSA/IG9iai5wb3AoKS50ZXh0IDogXCJcIik7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxlZnRvdmVyIHRva2Vuc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IG9iai5uYW1lO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCghbmFtZSB8fCAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpKSwgXCJpbnZhbGlkIG5hbWVcIiwgXCJvYmoubmFtZVwiLCBuYW1lKTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSBvYmouaW5kZXhlZDtcbiAgICAgICAgaWYgKGluZGV4ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWxsb3dJbmRleGVkLCBcInBhcmFtZXRlciBjYW5ub3QgYmUgaW5kZXhlZFwiLCBcIm9iai5pbmRleGVkXCIsIG9iai5pbmRleGVkKTtcbiAgICAgICAgICAgIGluZGV4ZWQgPSAhIWluZGV4ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSBvYmoudHlwZTtcbiAgICAgICAgbGV0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXlUeXBlKTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcGFyc2VJbnQoYXJyYXlNYXRjaFsyXSB8fCBcIi0xXCIpO1xuICAgICAgICAgICAgY29uc3QgYXJyYXlDaGlsZHJlbiA9IFBhcmFtVHlwZS5mcm9tKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcnJheU1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9iai5jb21wb25lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcImFycmF5XCIsIGluZGV4ZWQsIG51bGwsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHR5cGUuc3RhcnRzV2l0aChcInR1cGxlKFwiIC8qIGZpeDogKSAqLykgfHwgdHlwZS5zdGFydHNXaXRoKFwiKFwiIC8qIGZpeDogKSAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG9iai5jb21wb25lbnRzICE9IG51bGwpID8gb2JqLmNvbXBvbmVudHMubWFwKChjKSA9PiBQYXJhbVR5cGUuZnJvbShjKSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdHVwbGUgPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcInR1cGxlXCIsIGluZGV4ZWQsIGNvbXBzLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB1c2UgbGV4ZXIgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdHVwbGU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoudHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCB0eXBlLCBpbmRleGVkLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSAqKlBhcmFtVHlwZSoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gUGFyYW1UeXBlSW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50IGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5wdXRzIGZvciB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgaW5wdXRzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMpIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkZyYWdtZW50XCIpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHR5cGUsIGlucHV0cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGcmFnbWVudCoqIGZvciAlJW9iaiUlLCB3aWNoIGNhbiBiZSBhbnkgc3VwcG9ydGVkXG4gICAgICogIEFCSSBmcmdhbWVudCB0eXBlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBUcnkgcGFyc2luZyBKU09OLi4uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEZyYWdtZW50LmZyb20oSlNPTi5wYXJzZShvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSwgdXNlIHRoZSBodW1hbi1yZWFkYWJsZSBsZXhlclxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgLy8gSHVtYW4tcmVhZGFibGUgQUJJIChhbHJlYWR5IGxleGVkKVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wZWVrS2V5d29yZChLd1R5cGVzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iaikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIEpTT04gQUJJXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHtvYmoudHlwZX1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkZyYWdtZW50LmZyb21cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgZnJnYW1lbnQgb2JqZWN0XCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tDb25zdHJ1Y3RvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzQ29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXJyb3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0V2ZW50RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0Z1bmN0aW9uRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW1N0cnVjdEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzU3RydWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudFxuICogIHdoaWNoIGhhcyBhIG5hbWUgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSwgXCJpbnZhbGlkIGlkZW50aWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pblBhcmFtcyhmb3JtYXQsIHBhcmFtcykge1xuICAgIHJldHVybiBcIihcIiArIHBhcmFtcy5tYXAoKHApID0+IHAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSAvL0N1c3RvbSBFcnJvci8vLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXJyb3JcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFcnJvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQ3VzdG9tIEVycm9yIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkVycm9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJlcnJvclwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFcnJvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEVycm9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGFuIEV2ZW50LlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoaXMgZXZlbnQgaXMgYW5vbnltb3VzLlxuICAgICAqL1xuICAgIGFub255bW91cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXZlbnRcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFdmVudEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbm9ueW1vdXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRXZlbnQgdG9waWMgaGFzaC5cbiAgICAgKi9cbiAgICBnZXQgdG9waWNIYXNoKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXZlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiICYmIHRoaXMuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImFub255bW91c1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0b3BpYyBoYXNoIGZvciBhbiBldmVudCB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUb3BpY0hhc2gobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgcGFyYW1zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXZlbnRGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXZlbnQgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXZlbnRcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFub255bW91cyA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImFub255bW91c1wiXSkpLmhhcyhcImFub255bW91c1wiKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwLCB0cnVlKSkgOiBbXSwgISFvYmouYW5vbnltb3VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFdmVudEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBjb25zdHJ1Y3RvciBjYW4gcmVjZWl2ZSBhbiBlbmRvd21lbnQuXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCBmb3IgZGVwbG95bWVudCBvciBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cywgcGF5YWJsZSwgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUsIGdhcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3RvciBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgYXNzZXJ0KGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIsIFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiIH0pO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcInVuZGVmaW5lZFwiKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW2Bjb25zdHJ1Y3RvciR7am9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKX1gXTtcbiAgICAgICAgcmVzdWx0LnB1c2goKHRoaXMucGF5YWJsZSkgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU11dGFiaWxpdHkgPSAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3R5cGV9KCkke3RoaXMucGF5YWJsZSA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGYWxsYmFja0ZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGYWxsYmFja0ZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjaygpIFtwYXlhYmxlXVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBwYXlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLm91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2VsZWN0b3IgZm9yIGEgZnVuY3Rpb24gd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJhc3NlcnQiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0QXJndW1lbnQiLCJpZCIsInNldGlmeSIsIml0ZW1zIiwicmVzdWx0IiwiU2V0IiwiZm9yRWFjaCIsImsiLCJhZGQiLCJPYmplY3QiLCJmcmVlemUiLCJfa3dWaXNpYkRlcGxveSIsIkt3VmlzaWJEZXBsb3kiLCJzcGxpdCIsIl9rd1Zpc2liIiwiS3dWaXNpYiIsIl9rd1R5cGVzIiwiS3dUeXBlcyIsIl9rd01vZGlmaWVycyIsIkt3TW9kaWZpZXJzIiwiX2t3T3RoZXIiLCJfa2V5d29yZHMiLCJqb2luIiwiS2V5d29yZHMiLCJTaW1wbGVUb2tlbnMiLCJyZWdleFdoaXRlc3BhY2VQcmVmaXgiLCJSZWdFeHAiLCJyZWdleE51bWJlclByZWZpeCIsInJlZ2V4SWRQcmVmaXgiLCJyZWdleElkIiwicmVnZXhUeXBlIiwiVG9rZW5TdHJpbmciLCJvZmZzZXQiLCJ0b2tlbnMiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsInNsaWNlIiwiY2xvbmUiLCJyZXNldCIsInN1YlRva2VuU3RyaW5nIiwiZnJvbSIsInRvIiwibWFwIiwidCIsImFzc2lnbiIsIm1hdGNoIiwibGlua0JhY2siLCJsaW5rTmV4dCIsInBvcEtleXdvcmQiLCJhbGxvd2VkIiwidG9wIiwicGVlayIsInR5cGUiLCJoYXMiLCJ0ZXh0IiwiRXJyb3IiLCJwb3AiLCJwb3BUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInBvcFBhcmVuIiwicG9wUGFyYW1zIiwibGluayIsInB1c2giLCJwZWVrS2V5d29yZCIsInBlZWtUeXBlIiwidG9TdHJpbmciLCJpIiwidG9rZW4iLCJsZXgiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsImJyYWNrZXRzIiwiY29tbWFzIiwiY3VyIiwic3Vic3RyaW5nIiwiZGVwdGgiLCJ2YWx1ZSIsInN1ZmZpeCIsImFsbG93U2luZ2xlIiwic2V0IiwiaW5jbHVkZWQiLCJrZXkiLCJrZXlzIiwiY29uc3VtZU5hbWUiLCJrZXl3b3JkIiwiY29uc3VtZUtleXdvcmRzIiwia2V5d29yZHMiLCJjb25zdW1lTXV0YWJpbGl0eSIsIm1vZGlmaWVycyIsImNvbnN1bWVQYXJhbXMiLCJhbGxvd0luZGV4ZWQiLCJQYXJhbVR5cGUiLCJjb25zdW1lR2FzIiwiY29uc3VtZUVvaSIsInJlZ2V4QXJyYXlUeXBlIiwidmVyaWZ5QmFzaWNUeXBlIiwicGFyc2VJbnQiLCJzaXplIiwiX2d1YXJkIiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmb3IiLCJQYXJhbVR5cGVJbnRlcm5hbCIsIkVycm9yRnJhZ21lbnRJbnRlcm5hbCIsIkV2ZW50RnJhZ21lbnRJbnRlcm5hbCIsIkNvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCIsIkZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCIsIkZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCIsIlN0cnVjdEZyYWdtZW50SW50ZXJuYWwiLCJndWFyZCIsIm5hbWUiLCJiYXNlVHlwZSIsImluZGV4ZWQiLCJjb21wb25lbnRzIiwiYXJyYXlMZW5ndGgiLCJhcnJheUNoaWxkcmVuIiwiZGVmaW5lUHJvcGVydHkiLCJmb3JtYXQiLCJpc0FycmF5IiwicGFyc2UiLCJTdHJpbmciLCJpc1R1cGxlIiwiYyIsImNvbXAiLCJpc0luZGV4YWJsZSIsIndhbGsiLCJwcm9jZXNzIiwiQXJyYXkiLCJfdGhpcyIsInYiLCJ3YWxrQXN5bmMiLCJwcm9taXNlcyIsInNldFZhbHVlIiwiY2hpbGRUeXBlIiwiaW5kZXgiLCJwYXJhbSIsInRoZW4iLCJQcm9taXNlIiwiYWxsIiwib2JqIiwiaXNQYXJhbVR5cGUiLCJlcnJvciIsImNvbXBzIiwiYnJhY2tldCIsImFycmF5TWF0Y2giLCJzdGFydHNXaXRoIiwidHVwbGUiLCJGcmFnbWVudCIsImlucHV0cyIsImUiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGYWxsYmFja0ZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIlN0cnVjdEZyYWdtZW50Iiwib3BlcmF0aW9uIiwiaXNDb25zdHJ1Y3RvciIsImlzRnJhZ21lbnQiLCJpc0Vycm9yIiwiaXNFdmVudCIsImlzRnVuY3Rpb24iLCJpc1N0cnVjdCIsIk5hbWVkRnJhZ21lbnQiLCJqb2luUGFyYW1zIiwicGFyYW1zIiwicCIsInNlbGVjdG9yIiwiaW5wdXQiLCJhbm9ueW1vdXMiLCJ0b3BpY0hhc2giLCJnZXRUb3BpY0hhc2giLCJmcmFnbWVudCIsInBheWFibGUiLCJnYXMiLCJzdGF0ZU11dGFiaWxpdHkiLCJ1bmRlZmluZWQiLCJlcnJvck9iaiIsInRvcElzVmFsaWQiLCJtdXRhYmlsaXR5Iiwib3V0cHV0cyIsImNvbnN0YW50IiwibyIsImdldFNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/fragments.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/interface.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/interface.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abi-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typed.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ \n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = values.length > 0 ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#functions.get(name), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()){\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for(let i = matching.length - 1; i >= 0; i--){\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#events.get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#errors.get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n} //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQzhDO0FBQ1Q7QUFDd0o7QUFDcEo7QUFDNkI7QUFDbUQ7QUFDdkY7QUFDRTtBQUNyQzs7O0NBR0MsR0FDTSxNQUFNeUI7SUFxQlQ7O0tBRUMsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksQ0FBRTtRQUMvQixNQUFNQyxPQUFPSCxTQUFTRyxJQUFJLEVBQUVDLFlBQVlKLFNBQVNLLE1BQU07UUFDdkRyQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQ25CZ0I7WUFBVUc7WUFBTUM7WUFBV0g7WUFBT0M7UUFDdEM7SUFDSjtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1JO0lBeUJUOztLQUVDLEdBQ0RQLFlBQVlDLFFBQVEsRUFBRU8sUUFBUSxFQUFFTCxJQUFJLEVBQUVNLEtBQUssQ0FBRTtRQUN6QyxNQUFNTCxPQUFPSCxTQUFTRyxJQUFJLEVBQUVDLFlBQVlKLFNBQVNLLE1BQU07UUFDdkRyQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQ25CZ0I7WUFBVUc7WUFBTUQ7WUFBTUU7WUFBV0c7WUFBVUM7UUFDL0M7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUM7SUFxQlQ7O0tBRUMsR0FDRFYsWUFBWUMsUUFBUSxFQUFFTyxRQUFRLEVBQUVMLElBQUksQ0FBRTtRQUNsQyxNQUFNQyxPQUFPSCxTQUFTRyxJQUFJLEVBQUVDLFlBQVlKLFNBQVNLLE1BQU07UUFDdkRyQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQ25CZ0I7WUFBVUc7WUFBTUQ7WUFBTUU7WUFBV0c7UUFDckM7SUFDSjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNRztJQVNUOzs7O0tBSUMsR0FDRCxPQUFPQyxVQUFVSCxLQUFLLEVBQUU7UUFDcEIsT0FB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cUIsV0FBV3BELElBQUksRUFBRTtRQUNiLE1BQU1xRCxVQUFVOUssd0RBQU9BLENBQUN5SDtRQUN4QixNQUFNckcsV0FBVyxJQUFJLENBQUNpRyxRQUFRLENBQUN6SCwwREFBU0EsQ0FBQ2tMLFNBQVMsR0FBRztRQUNyRCxJQUFJLENBQUMxSixVQUFVO1lBQ1gsT0FBTztRQUNYO1FBQ0EsTUFBTUUsT0FBTyxJQUFJLENBQUMsQ0FBQ3lCLFFBQVEsQ0FBQzJFLE1BQU0sQ0FBQ3RHLFNBQVNnQixNQUFNLEVBQUV4QywwREFBU0EsQ0FBQ2tMLFNBQVM7UUFDdkUsT0FBTyxJQUFJakosaUJBQWlCVCxVQUFVQSxTQUFTTyxRQUFRLEVBQUVMO0lBQzdEO0lBQ0E7Ozs7O0tBS0MsR0FDRCxPQUFPaUMsS0FBSzNCLEtBQUssRUFBRTtRQUNmLDJDQUEyQztRQUMzQyxJQUFJQSxpQkFBaUJlLFdBQVc7WUFDNUIsT0FBT2Y7UUFDWDtRQUNBLE9BQU87UUFDUCxJQUFJLE9BQVFBLFVBQVcsVUFBVTtZQUM3QixPQUFPLElBQUllLFVBQVVKLEtBQUtXLEtBQUssQ0FBQ3RCO1FBQ3BDO1FBQ0EscUVBQXFFO1FBQ3JFLElBQUksT0FBUUEsTUFBTUgsTUFBTSxLQUFNLFlBQVk7WUFDdEMsT0FBTyxJQUFJa0IsVUFBVWYsTUFBTUgsTUFBTSxDQUFDO1FBQ3RDO1FBQ0EscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSWtCLFVBQVVmO0lBQ3pCO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9pbnRlcmZhY2UuanM/YTBmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgSW50ZXJmYWNlIGNsYXNzIGlzIGEgbG93LWxldmVsIGNsYXNzIHRoYXQgYWNjZXB0cyBhblxuICogIEFCSSBhbmQgcHJvdmlkZXMgYWxsIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25hbGl0eSB0byBlbmNvZGVcbiAqICBhbmQgZGVjb2RlIHBhcmFtYXRlcnMgdG8gYW5kIHJlc3VsdHMgZnJvbSBtZXRob2RzLCBldmVudHNcbiAqICBhbmQgZXJyb3JzLlxuICpcbiAqICBJdCBhbHNvIHByb3ZpZGVzIHNldmVyYWwgY29udmVuaWVuY2UgbWV0aG9kcyB0byBhdXRvbWF0aWNhbGx5XG4gKiAgc2VhcmNoIGFuZCBmaW5kIG1hdGNoaW5nIHRyYW5zYWN0aW9ucyBhbmQgZXZlbnRzIHRvIHBhcnNlIHRoZW0uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpOkludGVyZmFjZXMgIFtpbnRlcmZhY2VzXVxuICovXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB6ZXJvUGFkQnl0ZXMsIHplcm9QYWRWYWx1ZSwgaXNIZXhTdHJpbmcsIGRlZmluZVByb3BlcnRpZXMsIGFzc2VydEFyZ3VtZW50LCB0b0JlSGV4LCBhc3NlcnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFcnJvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuL3R5cGVkLmpzXCI7XG5leHBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH07XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUxvZ11dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYSBMb2cgdG8gaXRzIGV2ZW50XG4gKiAgZm9yIHBhcnNpbmcsIGEgKipMb2dEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoZSBgYHRvcGljMGBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvcGljIGhhc2ggZm9yIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICB0b3BpYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgRXZlbnQgd2l0aCBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgdG9waWMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBzaWduYXR1cmUsIHRvcGljLCBhcmdzXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlVHJhbnNhY3Rpb25dXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoXG4gKiAgYSB0cmFuc2FjdGlvbiBkYXRhIHRvIGl0cyBmdW5jdGlvbiBmb3IgcGFyc2luZyxcbiAqICBhICoqVHJhbnNhY3Rpb25EZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBGdW5jdGlvbiBzaWduYXR1cmUgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmFsdWVgYCAoaW4gd2VpKSBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3IsIHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlRXJyb3JdXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGFuXG4gKiAgZXJyb3IgZm9yIGEgY2FsbCByZXN1bHQgZm9yIHBhcnNpbmcsIGFuICoqRXJyb3JEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBFcnJvciB3aXRoIGBgcmV2ZXJ0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXJyb3Igc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipJbmRleGVkKiogaXMgdXNlZCBhcyBhIHZhbHVlIHdoZW4gYSB2YWx1ZSB0aGF0IGRvZXMgbm90XG4gKiAgZml0IHdpdGhpbiBhIHRvcGljIChpLmUuIG5vdCBhIGZpeGVkLWxlbmd0aCwgMzItYnl0ZSB0eXBlKS4gSXRcbiAqICBpcyB0aGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUsIGFuZCB1c2VkIGZvciB0eXBlcyBzdWNoIGFzXG4gKiAgYXJyYXlzLCB0dXBsZXMsIGJ5dGVzIGFuZCBzdHJpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSBsb2dnZWQuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX2lzSW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJXZhbHVlJSUgaXMgYW4gKipJbmRleGVkKiouXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgZm9yIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc2gpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGhhc2gsIF9pc0luZGV4ZWQ6IHRydWUgfSk7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xMy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbD9oaWdobGlnaHQ9cGFuaWMjcGFuaWMtdmlhLWFzc2VydC1hbmQtZXJyb3ItdmlhLXJlcXVpcmVcbmNvbnN0IFBhbmljUmVhc29ucyA9IHtcbiAgICBcIjBcIjogXCJnZW5lcmljIHBhbmljXCIsXG4gICAgXCIxXCI6IFwiYXNzZXJ0KGZhbHNlKVwiLFxuICAgIFwiMTdcIjogXCJhcml0aG1ldGljIG92ZXJmbG93XCIsXG4gICAgXCIxOFwiOiBcImRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIsXG4gICAgXCIzM1wiOiBcImVudW0gb3ZlcmZsb3dcIixcbiAgICBcIjM0XCI6IFwiaW52YWxpZCBlbmNvZGVkIHN0b3JhZ2UgYnl0ZSBhcnJheSBhY2Nlc3NlZFwiLFxuICAgIFwiNDlcIjogXCJvdXQtb2YtYm91bmRzIGFycmF5IGFjY2VzczsgcG9wcGluZyBvbiBhbiBlbXB0eSBhcnJheVwiLFxuICAgIFwiNTBcIjogXCJvdXQtb2YtYm91bmRzIGFjY2VzcyBvZiBhbiBhcnJheSBvciBieXRlc05cIixcbiAgICBcIjY1XCI6IFwib3V0IG9mIG1lbW9yeVwiLFxuICAgIFwiODFcIjogXCJ1bmluaXRpYWxpemVkIGZ1bmN0aW9uXCIsXG59O1xuY29uc3QgQnVpbHRpbkVycm9ycyA9IHtcbiAgICBcIjB4MDhjMzc5YTBcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxuICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgIGlucHV0czogW1wic3RyaW5nXCJdLFxuICAgICAgICByZWFzb246IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpfWA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiMHg0ZTQ4N2I3MVwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxuICAgICAgICBuYW1lOiBcIlBhbmljXCIsXG4gICAgICAgIGlucHV0czogW1widWludDI1NlwiXSxcbiAgICAgICAgcmVhc29uOiAoY29kZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwidW5rbm93biBwYW5pYyBjb2RlXCI7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSAwICYmIGNvZGUgPD0gMHhmZiAmJiBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXSkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHBhbmljIGNvZGUgMHgke2NvZGUudG9TdHJpbmcoMTYpfSAoJHtyZWFzb259KWA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiAgQW4gSW50ZXJmYWNlIGFic3RyYWN0cyBtYW55IG9mIHRoZSBsb3ctbGV2ZWwgZGV0YWlscyBmb3JcbiAqICBlbmNvZGluZyBhbmQgZGVjb2RpbmcgdGhlIGRhdGEgb24gdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogIEFuIEFCSSBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZW5jb2RlIGRhdGEgdG8gc2VuZCB0b1xuICogIGEgQ29udHJhY3QsIGhvdyB0byBkZWNvZGUgdGhlIHJlc3VsdHMgYW5kIGV2ZW50cyBhbmQgaG93IHRvXG4gKiAgaW50ZXJwcmV0IHJldmVydCBlcnJvcnMuXG4gKlxuICogIFRoZSBBQkkgY2FuIGJlIHNwZWNpZmllZCBieSBbYW55IHN1cHBvcnRlZCBmb3JtYXRdKEludGVyZmFjZUFiaSkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIENvbnRyYWN0IEFCSSBtZW1iZXJzIChpLmUuIG1ldGhvZHMsIGV2ZW50cywgZXJyb3JzLCBldGMpLlxuICAgICAqL1xuICAgIGZyYWdtZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGRlcGxveTtcbiAgICAvKipcbiAgICAgKiAgVGhlIEZhbGxiYWNrIG1ldGhvZCwgaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBJZiByZWNlaXZpbmcgZXRoZXIgaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHJlY2VpdmU7XG4gICAgI2Vycm9ycztcbiAgICAjZXZlbnRzO1xuICAgICNmdW5jdGlvbnM7XG4gICAgLy8gICAgI3N0cnVjdHM6IE1hcDxzdHJpbmcsIFN0cnVjdEZyYWdtZW50PjtcbiAgICAjYWJpQ29kZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBJbnRlcmZhY2UgZm9yIHRoZSAlJWZyYWdtZW50cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICBsZXQgYWJpID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50cykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFiaSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Vycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAgICAgICAgdGhpcy4jc3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZnJhZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIGFiaSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFncy5wdXNoKEZyYWdtZW50LmZyb20oYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRVwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIGFuIGludGVyZmFjZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIG9yIGZyb20gYSBzeW1saW5rZWQgY29weVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGZyYWdtZW50c1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJpZCIsImNvbmNhdCIsImRhdGFTbGljZSIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsInplcm9QYWRCeXRlcyIsInplcm9QYWRWYWx1ZSIsImlzSGV4U3RyaW5nIiwiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydEFyZ3VtZW50IiwidG9CZUhleCIsImFzc2VydCIsIkFiaUNvZGVyIiwiY2hlY2tSZXN1bHRFcnJvcnMiLCJSZXN1bHQiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJQYXJhbVR5cGUiLCJUeXBlZCIsIkxvZ0Rlc2NyaXB0aW9uIiwiY29uc3RydWN0b3IiLCJmcmFnbWVudCIsInRvcGljIiwiYXJncyIsIm5hbWUiLCJzaWduYXR1cmUiLCJmb3JtYXQiLCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIiwic2VsZWN0b3IiLCJ2YWx1ZSIsIkVycm9yRGVzY3JpcHRpb24iLCJJbmRleGVkIiwiaXNJbmRleGVkIiwiX2lzSW5kZXhlZCIsImhhc2giLCJQYW5pY1JlYXNvbnMiLCJCdWlsdGluRXJyb3JzIiwiaW5wdXRzIiwicmVhc29uIiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb2RlIiwidG9TdHJpbmciLCJJbnRlcmZhY2UiLCJlcnJvcnMiLCJldmVudHMiLCJmdW5jdGlvbnMiLCJhYmlDb2RlciIsImZyYWdtZW50cyIsImFiaSIsInBhcnNlIiwiTWFwIiwiZnJhZ3MiLCJhIiwicHVzaCIsImZyb20iLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJmcmVlemUiLCJmYWxsYmFjayIsInJlY2VpdmUiLCJnZXRBYmlDb2RlciIsImZvckVhY2giLCJpbmRleCIsImJ1Y2tldCIsInR5cGUiLCJkZXBsb3kiLCJsZW5ndGgiLCJwYXlhYmxlIiwiaGFzIiwic2V0IiwibWluaW1hbCIsIm1hcCIsImYiLCJmb3JtYXRKc29uIiwiaiIsImRlZmF1bHRBYmlDb2RlciIsImdldEZ1bmN0aW9uIiwia2V5IiwidmFsdWVzIiwiZm9yY2VVbmlxdWUiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJtYXRjaGluZyIsInNwbGl0IiwibGFzdFZhbHVlIiwidmFsdWVMZW5ndGgiLCJhbGxvd09wdGlvbnMiLCJpc1R5cGVkIiwiaSIsInNwbGljZSIsImJhc2VUeXBlIiwibGFzdEFyZyIsIkFycmF5IiwiaXNBcnJheSIsIm1hdGNoU3RyIiwibSIsImpvaW4iLCJyZXN1bHQiLCJnZXQiLCJnZXRGdW5jdGlvbk5hbWUiLCJoYXNGdW5jdGlvbiIsImZvckVhY2hGdW5jdGlvbiIsImNhbGxiYWNrIiwibmFtZXMiLCJrZXlzIiwic29ydCIsImIiLCJsb2NhbGVDb21wYXJlIiwiZ2V0RXZlbnQiLCJldmVudFRvcGljIiwidG9waWNIYXNoIiwiZ2V0RXZlbnROYW1lIiwiaGFzRXZlbnQiLCJmb3JFYWNoRXZlbnQiLCJnZXRFcnJvciIsImZvckVhY2hFcnJvciIsIl9kZWNvZGVQYXJhbXMiLCJwYXJhbXMiLCJkYXRhIiwiZGVjb2RlIiwiX2VuY29kZVBhcmFtcyIsImVuY29kZSIsImVuY29kZURlcGxveSIsImRlY29kZUVycm9yUmVzdWx0IiwiZW5jb2RlRXJyb3JSZXN1bHQiLCJkZWNvZGVGdW5jdGlvbkRhdGEiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJkZWNvZGVGdW5jdGlvblJlc3VsdCIsImJ5dGVzIiwib3V0cHV0cyIsImluZm8iLCJtZXRob2QiLCJtYWtlRXJyb3IiLCJfZGF0YSIsInR4IiwiZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24iLCJjdXN0b21QcmVmaXgiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJlZiIsInJldmVydCIsImUiLCJwYXJzZWQiLCJwYXJzZVRyYW5zYWN0aW9uIiwiaW52b2NhdGlvbiIsImVuY29kZUZ1bmN0aW9uUmVzdWx0IiwiZW5jb2RlRmlsdGVyVG9waWNzIiwiY291bnQiLCJleHBlY3RlZENvdW50IiwidG9waWNzIiwiYW5vbnltb3VzIiwiZW5jb2RlVG9waWMiLCJwYXJhbSIsIm1hdGNoIiwiaW5kZXhlZCIsInBvcCIsImVuY29kZUV2ZW50TG9nIiwiZGF0YVR5cGVzIiwiZGF0YVZhbHVlcyIsIkVycm9yIiwiZGVjb2RlRXZlbnRMb2ciLCJub25JbmRleGVkIiwiZHluYW1pYyIsInJlc3VsdEluZGV4ZWQiLCJyZXN1bHROb25JbmRleGVkIiwibm9uSW5kZXhlZEluZGV4IiwiaW5kZXhlZEluZGV4IiwiZnJvbUl0ZW1zIiwicGFyc2VDYWxsUmVzdWx0IiwicGFyc2VMb2ciLCJwYXJzZUVycm9yIiwiaGV4RGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/interface.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js":
/*!******************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/abi/typed.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ \nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    #options;\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v)=>v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n} //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS90eXBlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ21FO0FBQ3BFLE1BQU1FLFNBQVMsQ0FBQztBQUNoQixTQUFTQyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDbkIsSUFBSUMsU0FBUztJQUNiLElBQUlELFFBQVEsR0FBRztRQUNYQyxTQUFTO1FBQ1RELFNBQVMsQ0FBQztJQUNkO0lBQ0Esd0NBQXdDO0lBQ3hDLE9BQU8sSUFBSUUsTUFBTUwsUUFBUSxDQUFDLEVBQUVJLFNBQVMsS0FBSyxJQUFJLEdBQUcsRUFBRUQsTUFBTSxDQUFDLEVBQUVELE9BQU87UUFBRUU7UUFBUUQ7SUFBTTtBQUN2RjtBQUNBLFNBQVNHLEVBQUVKLEtBQUssRUFBRUssSUFBSTtJQUNsQix3Q0FBd0M7SUFDeEMsT0FBTyxJQUFJRixNQUFNTCxRQUFRLENBQUMsS0FBSyxFQUFFLE9BQVNPLE9BQU8sR0FBRyxDQUFDLEVBQUVMLE9BQU87UUFBRUs7SUFBSztBQUN6RTtBQUNBLE1BQU1DLGVBQWVDLE9BQU9DLEdBQUcsQ0FBQztBQUNoQzs7Q0FFQyxHQUNNLE1BQU1MO0lBU1QsQ0FBQ00sT0FBTyxDQUFDO0lBS1Q7O0tBRUMsR0FDREMsWUFBWUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVaLEtBQUssRUFBRVMsT0FBTyxDQUFFO1FBQ3JDLElBQUlBLFdBQVcsTUFBTTtZQUNqQkEsVUFBVTtRQUNkO1FBQ0FiLDhEQUFhQSxDQUFDRSxRQUFRYSxPQUFPO1FBQzdCZCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVTO1lBQWNNO1lBQU1aO1FBQU07UUFDbkQsSUFBSSxDQUFDLENBQUNTLE9BQU8sR0FBR0E7UUFDaEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0ksTUFBTTtJQUNmO0lBQ0E7O0tBRUMsR0FDREEsU0FBUztRQUNMLElBQUksSUFBSSxDQUFDRCxJQUFJLEtBQUssU0FB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QU07Z0JBQ3JCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLHVCQUF1QixFQUFFRixLQUFLLE1BQU0sRUFBRVosTUFBTVksSUFBSSxDQUFDLENBQUM7WUFDdkU7WUFDQSxPQUFPWixNQUFNQSxLQUFLO1FBQ3RCO1FBQ0EsT0FBT0E7SUFDWDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanM/NTYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIFR5cGVkIG9iamVjdCBhbGxvd3MgYSB2YWx1ZSB0byBoYXZlIGl0cyB0eXBlIGV4cGxpY2l0bHlcbiAqICBzcGVjaWZpZWQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbiBTb2xpZGl0eSwgdGhlIHZhbHVlIGBgNDVgYCBjb3VsZCByZXByZXNlbnQgYVxuICogIGBgdWludDhgYCBvciBhIGBgdWludDI1NmBgLiBUaGUgdmFsdWUgYGAweDEyMzRgYCBjb3VsZCByZXByZXNlbnRcbiAqICBhIGBgYnl0ZXMyYGAgb3IgYGBieXRlc2BgLlxuICpcbiAqICBTaW5jZSBKYXZhU2NyaXB0IGhhcyBubyBtZWFuaW5nZnVsIHdheSB0byBleHBsaWNpdGx5IGluZm9ybSBhbnlcbiAqICBBUElzIHdoaWNoIHdoYXQgdGhlIHR5cGUgaXMsIHRoaXMgYWxsb3dzIHRyYW5zcGFyZW50IGludGVyb3BlcmF0aW9uXG4gKiAgd2l0aCBTb2xkaXR5LlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9hYmk6VHlwZWQgVmFsdWVzXG4gKi9cbmltcG9ydCB7IGFzc2VydFByaXZhdGUsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9nYXVyZCA9IHt9O1xuZnVuY3Rpb24gbih2YWx1ZSwgd2lkdGgpIHtcbiAgICBsZXQgc2lnbmVkID0gZmFsc2U7XG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICB3aWR0aCAqPSAtMTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgJHtzaWduZWQgPyBcIlwiIDogXCJ1XCJ9aW50JHt3aWR0aH1gLCB2YWx1ZSwgeyBzaWduZWQsIHdpZHRoIH0pO1xufVxuZnVuY3Rpb24gYih2YWx1ZSwgc2l6ZSkge1xuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYGJ5dGVzJHsoc2l6ZSkgPyBzaXplIDogXCJcIn1gLCB2YWx1ZSwgeyBzaXplIH0pO1xufVxuY29uc3QgX3R5cGVkU3ltYm9sID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfdHlwZWRcIik7XG4vKipcbiAqICBUaGUgKipUeXBlZCoqIGNsYXNzIHRvIHdyYXAgdmFsdWVzIHByb3ZpZGluZyBleHBsaWNpdCB0eXBlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3R5cGVkU3ltYm9sO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShfZ2F1cmQsIGdhdXJkLCBcIlR5cGVkXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgX3R5cGVkU3ltYm9sLCB0eXBlLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWx1ZSBpcyB2YWxpZFxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9ybWF0IHRoZSB0eXBlIGFzIGEgSHVtYW4tUmVhZGFibGUgdHlwZS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJkeW5hbWljQXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYHR1cGxlKCR7dGhpcy52YWx1ZS5tYXAoKHYpID0+IHYuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIHR5cGUuXG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5pbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1pblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZEJpZ0ludF1dLlxuICAgICAqL1xuICAgIGlzQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy50eXBlLm1hdGNoKC9edT9pbnRbMC05XSskLykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkRGF0YV1dLlxuICAgICAqL1xuICAgIGlzRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRTdHJpbmddXS5cbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IFwic3RyaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHVwbGUgbmFtZSwgaWYgdGhpcyBpcyBhIHR1cGxlLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCB0dXBsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGEgdHVwbGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIHR5cGUgYXMgYW4gYXJyYXlcbiAgICAvLyAtIGBudWxsYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyB1bmZvcmNlZCwgaXQgY291bGQgYmUgZHluYW1pY1xuICAgIC8vIC0gYC0xYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyBkeW5hbWljXG4gICAgLy8gLSBhbnkgb3RoZXIgdmFsdWUgaW5kaWNhdGVzIGl0IGlzIGEgc3RhdGljIGFycmF5IGFuZCBpcyBpdHMgbGVuZ3RoXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdHlwZSBvciBgYC0xYGAgaWYgaXQgaXMgZHluYW1pYy5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIHR5cGUgaXMgbm90IGFuIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBhcnJheUxlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlR5cGVkKiogb2YgJSV0eXBlJSUgd2l0aCB0aGUgJSV2YWx1ZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCB0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OCh2KSB7IHJldHVybiBuKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYodikgeyByZXR1cm4gbih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNCh2KSB7IHJldHVybiBuKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDMyKHYpIHsgcmV0dXJuIG4odiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDAodikgeyByZXR1cm4gbih2LCA0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0OCh2KSB7IHJldHVybiBuKHYsIDQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDU2KHYpIHsgcmV0dXJuIG4odiwgNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NjQodikgeyByZXR1cm4gbih2LCA2NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ3Mih2KSB7IHJldHVybiBuKHYsIDcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgwKHYpIHsgcmV0dXJuIG4odiwgODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODgodikgeyByZXR1cm4gbih2LCA4OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ5Nih2KSB7IHJldHVybiBuKHYsIDk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMDQodikgeyByZXR1cm4gbih2LCAxMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDExMih2KSB7IHJldHVybiBuKHYsIDExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTIwKHYpIHsgcmV0dXJuIG4odiwgMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjgodikgeyByZXR1cm4gbih2LCAxMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEzNih2KSB7IHJldHVybiBuKHYsIDEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNTIodikgeyByZXR1cm4gbih2LCAxNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2MCh2KSB7IHJldHVybiBuKHYsIDE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTY4KHYpIHsgcmV0dXJuIG4odiwgMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNzYodikgeyByZXR1cm4gbih2LCAxNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE4NCh2KSB7IHJldHVybiBuKHYsIDE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTkyKHYpIHsgcmV0dXJuIG4odiwgMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDAodikgeyByZXR1cm4gbih2LCAyMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwOCh2KSB7IHJldHVybiBuKHYsIDIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjE2KHYpIHsgcmV0dXJuIG4odiwgMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMjQodikgeyByZXR1cm4gbih2LCAyMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIzMih2KSB7IHJldHVybiBuKHYsIDIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQwKHYpIHsgcmV0dXJuIG4odiwgMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDgodikgeyByZXR1cm4gbih2LCAyNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI1Nih2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgodikgeyByZXR1cm4gbih2LCAtOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYodikgeyByZXR1cm4gbih2LCAtMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0KHYpIHsgcmV0dXJuIG4odiwgLTI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQzMih2KSB7IHJldHVybiBuKHYsIC0zMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDAodikgeyByZXR1cm4gbih2LCAtNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQ4KHYpIHsgcmV0dXJuIG4odiwgLTQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ1Nih2KSB7IHJldHVybiBuKHYsIC01Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NjQodikgeyByZXR1cm4gbih2LCAtNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDcyKHYpIHsgcmV0dXJuIG4odiwgLTcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4MCh2KSB7IHJldHVybiBuKHYsIC04MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODgodikgeyByZXR1cm4gbih2LCAtODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDk2KHYpIHsgcmV0dXJuIG4odiwgLTk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTA0KHYpIHsgcmV0dXJuIG4odiwgLTEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDExMih2KSB7IHJldHVybiBuKHYsIC0xMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjAodikgeyByZXR1cm4gbih2LCAtMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTI4KHYpIHsgcmV0dXJuIG4odiwgLTEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEzNih2KSB7IHJldHVybiBuKHYsIC0xMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNDQodikgeyByZXR1cm4gbih2LCAtMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNTIodikgeyByZXR1cm4gbih2LCAtMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYwKHYpIHsgcmV0dXJuIG4odiwgLTE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2OCh2KSB7IHJldHVybiBuKHYsIC0xNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNzYodikgeyByZXR1cm4gbih2LCAtMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTg0KHYpIHsgcmV0dXJuIG4odiwgLTE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTkyKHYpIHsgcmV0dXJuIG4odiwgLTE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwMCh2KSB7IHJldHVybiBuKHYsIC0yMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDgodikgeyByZXR1cm4gbih2LCAtMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjE2KHYpIHsgcmV0dXJuIG4odiwgLTIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIyNCh2KSB7IHJldHVybiBuKHYsIC0yMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMzIodikgeyByZXR1cm4gbih2LCAtMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQwKHYpIHsgcmV0dXJuIG4odiwgLTI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0OCh2KSB7IHJldHVybiBuKHYsIC0yNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNTYodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMSh2KSB7IHJldHVybiBiKHYsIDEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIodikgeyByZXR1cm4gYih2LCAyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzKHYpIHsgcmV0dXJuIGIodiwgMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNCh2KSB7IHJldHVybiBiKHYsIDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczUodikgeyByZXR1cm4gYih2LCA1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM2KHYpIHsgcmV0dXJuIGIodiwgNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNyh2KSB7IHJldHVybiBiKHYsIDcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczgodikgeyByZXR1cm4gYih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM5KHYpIHsgcmV0dXJuIGIodiwgOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEwKHYpIHsgcmV0dXJuIGIodiwgMTApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMSh2KSB7IHJldHVybiBiKHYsIDExKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTIodikgeyByZXR1cm4gYih2LCAxMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEzKHYpIHsgcmV0dXJuIGIodiwgMTMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNCh2KSB7IHJldHVybiBiKHYsIDE0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTUodikgeyByZXR1cm4gYih2LCAxNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE2KHYpIHsgcmV0dXJuIGIodiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNyh2KSB7IHJldHVybiBiKHYsIDE3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTgodikgeyByZXR1cm4gYih2LCAxOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE5KHYpIHsgcmV0dXJuIGIodiwgMTkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMCh2KSB7IHJldHVybiBiKHYsIDIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjEodikgeyByZXR1cm4gYih2LCAyMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIyKHYpIHsgcmV0dXJuIGIodiwgMjIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMyh2KSB7IHJldHVybiBiKHYsIDIzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjQodikgeyByZXR1cm4gYih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI1KHYpIHsgcmV0dXJuIGIodiwgMjUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNih2KSB7IHJldHVybiBiKHYsIDI2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjcodikgeyByZXR1cm4gYih2LCAyNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI4KHYpIHsgcmV0dXJuIGIodiwgMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOSh2KSB7IHJldHVybiBiKHYsIDI5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzAodikgeyByZXR1cm4gYih2LCAzMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMxKHYpIHsgcmV0dXJuIGIodiwgMzEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMih2KSB7IHJldHVybiBiKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhZGRyZXNzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGFkZHJlc3ModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhZGRyZXNzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJvb2xgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9vbCh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJvb2xcIiwgISF2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJ5dGVzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHN0cmluZ2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmcodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJzdHJpbmdcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYXJyYXlgYCB0eXBlIGZvciAlJXYlJSwgYWxsb3dpbmcgJSVkeW5hbWljJSUgbGVuZ3RoLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheSh2LCBkeW5hbWljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFycmF5XCIsIHYsIGR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdHVwbGVgYCB0eXBlIGZvciAlJXYlJSwgd2l0aCB0aGUgb3B0aW9uYWwgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIHR1cGxlKHYsIG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwidHVwbGVcIiwgdiwgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvdmVycmlkZXModikge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJvdmVycmlkZXNcIiwgT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgJSV2YWx1ZSUlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWVcbiAgICAgICAgICAgICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBcIl90eXBlZFN5bWJvbFwiIGluIHZhbHVlXG4gICAgICAgICAgICAmJiB2YWx1ZS5fdHlwZWRTeW1ib2wgPT09IF90eXBlZFN5bWJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGUgdmFsdWUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UsIHZhbGlkYXRlcyB0aGUgdW5kZXJseWluZyB2YWx1ZVxuICAgICAqICBhbmQgcmV0dXJucyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgdmFsdWUgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGZ1bmN0aW9ucyB0aGF0IHdpdGggdG8gYWNjZXB0IGVpdGhlciBhIFtbVHlwZWRdXVxuICAgICAqICBvYmplY3Qgb3IgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGU6IGV4cGVjZXRkICR7dHlwZX0sIGdvdCAke3ZhbHVlLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRQcml2YXRlIiwiZGVmaW5lUHJvcGVydGllcyIsIl9nYXVyZCIsIm4iLCJ2YWx1ZSIsIndpZHRoIiwic2lnbmVkIiwiVHlwZWQiLCJiIiwic2l6ZSIsIl90eXBlZFN5bWJvbCIsIlN5bWJvbCIsImZvciIsIm9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsImdhdXJkIiwidHlwZSIsImZvcm1hdCIsIkVycm9yIiwibWFwIiwidiIsImpvaW4iLCJkZWZhdWx0VmFsdWUiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNCaWdJbnQiLCJtYXRjaCIsImlzRGF0YSIsInN0YXJ0c1dpdGgiLCJpc1N0cmluZyIsInR1cGxlTmFtZSIsIlR5cGVFcnJvciIsImFycmF5TGVuZ3RoIiwibGVuZ3RoIiwiZnJvbSIsInVpbnQ4IiwidWludDE2IiwidWludDI0IiwidWludDMyIiwidWludDQwIiwidWludDQ4IiwidWludDU2IiwidWludDY0IiwidWludDcyIiwidWludDgwIiwidWludDg4IiwidWludDk2IiwidWludDEwNCIsInVpbnQxMTIiLCJ1aW50MTIwIiwidWludDEyOCIsInVpbnQxMzYiLCJ1aW50MTQ0IiwidWludDE1MiIsInVpbnQxNjAiLCJ1aW50MTY4IiwidWludDE3NiIsInVpbnQxODQiLCJ1aW50MTkyIiwidWludDIwMCIsInVpbnQyMDgiLCJ1aW50MjE2IiwidWludDIyNCIsInVpbnQyMzIiLCJ1aW50MjQwIiwidWludDI0OCIsInVpbnQyNTYiLCJ1aW50IiwiaW50OCIsImludDE2IiwiaW50MjQiLCJpbnQzMiIsImludDQwIiwiaW50NDgiLCJpbnQ1NiIsImludDY0IiwiaW50NzIiLCJpbnQ4MCIsImludDg4IiwiaW50OTYiLCJpbnQxMDQiLCJpbnQxMTIiLCJpbnQxMjAiLCJpbnQxMjgiLCJpbnQxMzYiLCJpbnQxNDQiLCJpbnQxNTIiLCJpbnQxNjAiLCJpbnQxNjgiLCJpbnQxNzYiLCJpbnQxODQiLCJpbnQxOTIiLCJpbnQyMDAiLCJpbnQyMDgiLCJpbnQyMTYiLCJpbnQyMjQiLCJpbnQyMzIiLCJpbnQyNDAiLCJpbnQyNDgiLCJpbnQyNTYiLCJpbnQiLCJieXRlczEiLCJieXRlczIiLCJieXRlczMiLCJieXRlczQiLCJieXRlczUiLCJieXRlczYiLCJieXRlczciLCJieXRlczgiLCJieXRlczkiLCJieXRlczEwIiwiYnl0ZXMxMSIsImJ5dGVzMTIiLCJieXRlczEzIiwiYnl0ZXMxNCIsImJ5dGVzMTUiLCJieXRlczE2IiwiYnl0ZXMxNyIsImJ5dGVzMTgiLCJieXRlczE5IiwiYnl0ZXMyMCIsImJ5dGVzMjEiLCJieXRlczIyIiwiYnl0ZXMyMyIsImJ5dGVzMjQiLCJieXRlczI1IiwiYnl0ZXMyNiIsImJ5dGVzMjciLCJieXRlczI4IiwiYnl0ZXMyOSIsImJ5dGVzMzAiLCJieXRlczMxIiwiYnl0ZXMzMiIsImFkZHJlc3MiLCJib29sIiwiYnl0ZXMiLCJzdHJpbmciLCJhcnJheSIsImR5bmFtaWMiLCJ0dXBsZSIsIm5hbWUiLCJvdmVycmlkZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJpc1R5cGVkIiwiZGVyZWZlcmVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/address/address.js":
/*!************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/address/address.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErQztBQUNjO0FBQzdELE1BQU1HLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMsUUFBUUQsT0FBTztBQUNyQixTQUFTRSxtQkFBbUJDLE9BQU87SUFDL0Isc0NBQXNDO0lBQ3RDLDJFQUEyRTtJQUMzRSxPQUFPO0lBQ1BBLFVBQVVBLFFBQVFDLFdBQVc7SUFDN0IsTUFBTUMsUUFBUUYsUUFBUUcsU0FBUyxDQUFDLEdBQUdDLEtBQUssQ0FBQztJQUN6QyxNQUFNQyxXQUFXLElBQUlDLFdBQVc7SUFDaEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztRQUN6QkYsUUFBUSxDQUFDRSxFQUFFLEdBQUdMLEtBQUssQ0FBQ0ssRUFBRSxDQUFDQyxVQUFVLENBQUM7SUFDdEM7SUFDQSxNQUFNQyxTQUFTZix5REFBUUEsQ0FBQ0QsMkRBQVNBLENBQUNZO0lBQ2xDLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztRQUM1QixJQUFJLE1BQU8sQ0FBQ0EsS0FBSyxFQUFFLElBQUksS0FBTSxHQUFHO1lBQzVCTCxLQUFLLENBQUNLLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxFQUFFLENBQUNHLFdBQVc7UUFDbkM7UUFDQSxJQUFJLENBQUNELE1BQU0sQ0FBQ0YsS0FBSyxFQUFFLEdBQUcsSUFBRyxLQUFNLEdBQUc7WUFDOUJMLEtBQUssQ0FBQ0ssSUFBSSxFQUFFLEdBQUdMLEtBQUssQ0FBQ0ssSUFBSSxFQUFFLENBQUNHLFdBQVc7UUFDM0M7SUFDSjtJQUNBLE9BQU8sT0FBT1IsTUFBTVMsSUFBSSxDQUFDO0FBQzdCO0FBQ0EsdUVBQXVFO0FBQ3ZFLHNCQUFzQjtBQUN0QixNQUFNQyxhQUFhLENBQUM7QUFDcEIsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztJQUN6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LGVBQWVoQyxPQUFPO0lBQ2xDLDJFQUEyRTtJQUMzRSxJQUFJaUMsU0FBU3BDLE9BQU8rQixXQUFXNUIsVUFBVStCLFFBQVEsQ0FBQyxJQUFJckIsV0FBVztJQUNqRSxNQUFPdUIsT0FBT2QsTUFBTSxHQUFHLEdBQUk7UUFDdkJjLFNBQVMsTUFBTUE7SUFDbkI7SUFDQSxPQUFPLE9BQU9qQixhQUFhLFNBQVNpQixVQUFVQTtBQUNsRCxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzPzJlMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMzYgPSBCaWdJbnQoMzYpO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvLyAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgIC8vICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAvLyAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGdldEJ5dGVzKGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG4vLyBpLmUuIE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuY29uc3Qgc2FmZURpZ2l0cyA9IDE1O1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmNvbnN0IEJhc2UzNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiW2ldO1xuICAgICAgICByZXN1bHRba2V5XSA9IEJpZ0ludChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5mdW5jdGlvbiBmcm9tQmFzZTM2KHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogQk5fMzYgKyBCYXNlMzZbdmFsdWVbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5vcm1hbGl6ZWQgYW5kIGNoZWNrc3VtZWQgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUuXG4gKiAgVGhpcyBhY2NlcHRzIG5vbi1jaGVja3N1bSBhZGRyZXNzZXMsIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmRcbiAqICBbW2dldEljYXBBZGRyZXNzXV0gZm9ybWF0cy5cbiAqXG4gKiAgVGhlIGNoZWNrc3VtIGluIEV0aGVyZXVtIHVzZXMgdGhlIGNhcGl0YWxpemF0aW9uICh1cHBlci1jYXNlXG4gKiAgdnMgbG93ZXItY2FzZSkgb2YgdGhlIGNoYXJhY3RlcnMgd2l0aGluIGFuIGFkZHJlc3MgdG8gZW5jb2RlXG4gKiAgaXRzIGNoZWNrc3VtLCB3aGljaCBvZmZlcnMsIG9uIGF2ZXJhZ2UsIGEgY2hlY2tzdW0gb2YgMTUtYml0cy5cbiAqXG4gKiAgSWYgJSVhZGRyZXNzJSUgY29udGFpbnMgYm90aCB1cHBlci1jYXNlIGFuZCBsb3dlci1jYXNlLCBpdCBpc1xuICogIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGNoZWNrc3VtIGFkZHJlc3MgYW5kIGl0cyBjaGVja3N1bSBpc1xuICogIHZhbGlkYXRlZCwgYW5kIGlmIHRoZSBhZGRyZXNzIGZhaWxzIGl0cyBleHBlY3RlZCBjaGVja3N1bSBhblxuICogIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAgSWYgeW91IHdpc2ggdGhlIGNoZWNrc3VtIG9mICUlYWRkcmVzcyUlIHRvIGJlIGlnbm9yZSwgaXQgc2hvdWxkXG4gKiAgYmUgY29udmVydGVkIHRvIGxvd2VyLWNhc2UgKGkuZS4gYGAudG9Mb3dlcmNhc2UoKWBgKSBiZWZvcmVcbiAqICBiZWluZyBwYXNzZWQgaW4uIFRoaXMgc2hvdWxkIGJlIGEgdmVyeSByYXJlIHNpdHVhdGlvbiB0aG91Z2gsXG4gKiAgdGhhdCB5b3Ugd2lzaCB0byBieXBhc3MgdGhlIHNhZmVnYXVyZHMgaW4gcGxhY2UgdG8gcHJvdGVjdFxuICogIGFnYWluc3QgYW4gYWRkcmVzcyB0aGF0IGhhcyBiZWVuIGluY29ycmVjdGx5IGNvcGllZCBmcm9tIGFub3RoZXJcbiAqICBzb3VyY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQWRkcyB0aGUgY2hlY2tzdW0gKHZpYSB1cHBlci1jYXNpbmcgc3BlY2lmaWMgbGV0dGVycylcbiAqICAgIGdldEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb252ZXJ0cyBJQ0FQIGFkZHJlc3MgYW5kIGFkZHMgY2hlY2tzdW1cbiAqICAgIGdldEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gYWRkcmVzcyBjb250YWlucyBtaXhlZCBjYXNlLFxuICogICAgLy8gYnV0IHRoZSBjaGVja3N1bSBmYWlsc1xuICogICAgZ2V0QWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKCFhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudCghYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSB8fCByZXN1bHQgPT09IGFkZHJlc3MsIFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSA9PT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpLCBcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZyb21CYXNlMzYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xufVxuLyoqXG4gKiAgVGhlIFtJQ0FQIEFkZHJlc3MgZm9ybWF0XShsaW5rLWljYXApIGZvcm1hdCBpcyBhbiBlYXJseSBjaGVja3N1bVxuICogIGZvcm1hdCB3aGljaCBhdHRlbXB0cyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGJhbmtpbmdcbiAqICBpbmR1c3RyeSBbSUJBTiBmb3JtYXRdKGxpbmstd2lraS1pYmFuKSBmb3IgYmFuayBhY2NvdW50cy5cbiAqXG4gKiAgSXQgaXMgbm8gbG9uZ2VyIGNvbW1vbiBvciBhIHJlY29tbWVuZGVkIGZvcm1hdC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgSUNBUCBjaGVja3N1bSBpcyB3cm9uZ1xuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszN1wiKTtcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBiYXNlMzYgPSBCaWdJbnQoZ2V0QWRkcmVzcyhhZGRyZXNzKSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJnZXRCeXRlcyIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsIkJOXzM2IiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwiY2hhcnMiLCJzdWJzdHJpbmciLCJzcGxpdCIsImV4cGFuZGVkIiwiVWludDhBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiaGFzaGVkIiwidG9VcHBlckNhc2UiLCJqb2luIiwiaWJhbkxvb2t1cCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNhZmVEaWdpdHMiLCJpYmFuQ2hlY2tzdW0iLCJtYXAiLCJjIiwibGVuZ3RoIiwiYmxvY2siLCJwYXJzZUludCIsImNoZWNrc3VtIiwiQmFzZTM2IiwicmVzdWx0Iiwia2V5IiwiZnJvbUJhc2UzNiIsInZhbHVlIiwiZ2V0QWRkcmVzcyIsIm1hdGNoIiwic3RhcnRzV2l0aCIsInRvU3RyaW5nIiwiZ2V0SWNhcEFkZHJlc3MiLCJiYXNlMzYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/address/address.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/address/checks.js":
/*!***********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/address/checks.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n} //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY2hlY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ2pCO0FBQzFDOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTRyxjQUFjQyxLQUFLO0lBQy9CLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUYsVUFBVSxLQUFNO0FBQ25EO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNNLFNBQVNHLFVBQVVELEtBQUs7SUFDM0IsSUFBSTtRQUNBRix1REFBVUEsQ0FBQ0U7UUFDWCxPQUFPO0lBQ1gsRUFDQSxPQUFPRSxPQUFPLENBQUU7SUFDaEIsT0FBTztBQUNYO0FBQ0EsZUFBZUMsYUFBYUMsTUFBTSxFQUFFQyxPQUFPO0lBQ3ZDLE1BQU1DLFNBQVMsTUFBTUQ7SUFDckIsSUFBSUMsVUFBVSxRQUFRQSxXQUFXLDhDQUE4QztRQUMzRVYsdURBQU1BLENBQUMsT0FBUVEsV0FBWSxVQUFVLHFCQUFxQixxQkFBcUI7WUFBRUosT0FBT0k7UUFBTztRQUMvRlAsK0RBQWNBLENBQUMsT0FBTyxpRUFBaUUsVUFBVU87SUFDckc7SUFDQSxPQUFPTix1REFBVUEsQ0FBQ1E7QUFDdEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0NDLEdBQ00sU0FBU0MsZUFBZUgsTUFBTSxFQUFFSSxRQUFRO0lBQzNDLElBQUksT0FBUUosV0FBWSxVQUFVO1FBQzlCLElBQUlBLE9BQU9LLEtBQUssQ0FBQyxzQkFBc0I7WUFDbkMsT0FBT1gsdURBQVVBLENBQUNNO1FBQ3RCO1FBQ0FSLHVEQUFNQSxDQUFDWSxZQUFZLE1BQU0sc0NBQXNDLHlCQUF5QjtZQUFFRSxXQUFXO1FBQWM7UUFDbkgsT0FBT1AsYUFBYUMsUUFBUUksU0FBU0csV0FBVyxDQUFDUDtJQUNyRCxPQUNLLElBQUlMLGNBQWNLLFNBQVM7UUFDNUIsT0FBT0QsYUFBYUMsUUFBUUEsT0FBT04sVUFBVTtJQUNqRCxPQUNLLElBQUlNLFVBQVUsT0FBUUEsT0FBT1EsSUFBSSxLQUFNLFlBQVk7UUFDcEQsT0FBT1QsYUFBYUMsUUFBUUE7SUFDaEM7SUFDQVAsK0RBQWNBLENBQUMsT0FBTyxpQ0FBaUMsVUFBVU87QUFDckUsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY2hlY2tzLmpzP2U2YTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlXG4gKiAgW1tBZGRyZXNzYWJsZV1dIGludGVyZmFjZS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBXYWxsZXRzIGFuZCBBYnN0cmFjdFNpZ25lciBzdWItY2xhc3Nlc1xuICogICAgaXNBZGRyZXNzYWJsZShXYWxsZXQuY3JlYXRlUmFuZG9tKCkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udHJhY3RzXG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBbIF0sIHByb3ZpZGVyKVxuICogICAgaXNBZGRyZXNzYWJsZShjb250cmFjdClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzc2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBWYWxpZCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBWYWxpZCBJQ0FQIGFkZHJlc3NcbiAqICAgIGlzQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBJQ0FQIGNoZWNrc3VtXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBOb3QgYW4gYWRkcmVzcyAoYW4gRU5TIG5hbWUgcmVxdWlyZXMgYSBwcm92aWRlZCBhbmQgYW5cbiAqICAgIC8vIGFzeW5jaHJvbm91cyBBUEkgdG8gYWNjZXNzKVxuICogICAgaXNBZGRyZXNzKFwicmljbW9vLmV0aFwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHByb21pc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIiwgXCJ1bmNvbmZpZ3VyZWQgbmFtZVwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHsgdmFsdWU6IHRhcmdldCB9KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBBZGRyZXNzTGlrZSB2YWx1ZTsgZGlkIG5vdCByZXNvbHZlIHRvIGEgdmFsdWUgYWRkcmVzc1wiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYW4gYWRkcmVzcyBmb3IgdGhlICUldGFyZ2V0JSUsIHdoaWNoIG1heSBiZSBhbnlcbiAqICBzdXBwb3J0ZWQgYWRkcmVzcyB0eXBlLCBhbiBbW0FkZHJlc3NhYmxlXV0gb3IgYSBQcm9taXNlIHdoaWNoXG4gKiAgcmVzb2x2ZXMgdG8gYW4gYWRkcmVzcy5cbiAqXG4gKiAgSWYgYW4gRU5TIG5hbWUgaXMgcHJvdmlkZWQsIGJ1dCB0aGF0IG5hbWUgaGFzIG5vdCBiZWVuIGNvcnJlY3RseVxuICogIGNvbmZpZ3VyZWQgYSBbW1VuY29uZmlndXJlZE5hbWVFcnJvcl1dIGlzIHRocm93bi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBhZGRyID0gXCIweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEZcIlxuICpcbiAqICAgIC8vIEFkZHJlc3NlcyBhcmUgcmV0dXJuIHN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3MgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhQcm9taXNlLnJlc29sdmUoYWRkcikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRU5TIG5hbWVzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQWRkcmVzc2FibGUgb2JqZWN0cyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHIsIFsgXSlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGNvbnRyYWN0LCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBVbmNvbmZpZ3VyZWQgRU5TIG5hbWVzIHJlamVjdFxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiLCBwcm92aWRlcilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyByZXF1aXJlIGEgTmFtZVJlc29sdmVyIG9iamVjdCBwYXNzZWQgaW5cbiAqICAgIC8vIChub3RpY2UgdGhlIHByb3ZpZGVyIHdhcyBvbWl0dGVkKVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eMHhbMC05YS1mXXs0MH0kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChyZXNvbHZlciAhPSBudWxsLCBcIkVOUyByZXNvbHV0aW9uIHJlcXVpcmVzIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FkZHJlc3NhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldC5nZXRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mICh0YXJnZXQudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgYWRkcmVzc2FibGUgdmFsdWVcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcy5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRBZGRyZXNzIiwiaXNBZGRyZXNzYWJsZSIsInZhbHVlIiwiaXNBZGRyZXNzIiwiZXJyb3IiLCJjaGVja0FkZHJlc3MiLCJ0YXJnZXQiLCJwcm9taXNlIiwicmVzdWx0IiwicmVzb2x2ZUFkZHJlc3MiLCJyZXNvbHZlciIsIm1hdGNoIiwib3BlcmF0aW9uIiwicmVzb2x2ZU5hbWUiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/address/checks.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/address/contract-address.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* binding */ getCreateAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */ function getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.encodeRlp)([\n        from,\n        nonceHex\n    ])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */ function getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        from,\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=contract-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY29udHJhY3QtYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQztBQUN1RDtBQUM1RDtBQUMxQyxzR0FBc0c7QUFDdEc7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU1EsaUJBQWlCQyxFQUFFO0lBQy9CLE1BQU1DLE9BQU9ILHVEQUFVQSxDQUFDRSxHQUFHQyxJQUFJO0lBQy9CLE1BQU1DLFFBQVFSLDBEQUFTQSxDQUFDTSxHQUFHRSxLQUFLLEVBQUU7SUFDbEMsSUFBSUMsV0FBV0QsTUFBTUUsUUFBUSxDQUFDO0lBQzlCLElBQUlELGFBQWEsS0FBSztRQUNsQkEsV0FBVztJQUNmLE9BQ0ssSUFBSUEsU0FBU0UsTUFBTSxHQUFHLEdBQUc7UUFDMUJGLFdBQVcsUUFBUUE7SUFDdkIsT0FDSztRQUNEQSxXQUFXLE9BQU9BO0lBQ3RCO0lBQ0EsT0FBT0wsdURBQVVBLENBQUNMLDBEQUFTQSxDQUFDRiwyREFBU0EsQ0FBQ0ssMERBQVNBLENBQUM7UUFBQ0s7UUFBTUU7S0FBUyxJQUFJO0FBQ3hFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxTQUFTRyxrQkFBa0JDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxhQUFhO0lBQ3pELE1BQU1SLE9BQU9ILHVEQUFVQSxDQUFDUztJQUN4QixNQUFNRyxPQUFPZix5REFBUUEsQ0FBQ2EsT0FBTztJQUM3QixNQUFNRyxlQUFlaEIseURBQVFBLENBQUNjLGVBQWU7SUFDN0NaLCtEQUFjQSxDQUFDYSxLQUFLTCxNQUFNLEtBQUssSUFBSSx5QkFBeUIsUUFBUUc7SUFDcEVYLCtEQUFjQSxDQUFDYyxhQUFhTixNQUFNLEtBQUssSUFBSSxpQ0FBaUMsZ0JBQWdCSTtJQUM1RixPQUFPWCx1REFBVUEsQ0FBQ0wsMERBQVNBLENBQUNGLDJEQUFTQSxDQUFDQyx1REFBTUEsQ0FBQztRQUFDO1FBQVFTO1FBQU1TO1FBQU1DO0tBQWEsSUFBSTtBQUN2RixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzP2Q4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGVuY29kZVJscCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVBZGRyZXNzKHR4KSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyhfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiY29uY2F0IiwiZGF0YVNsaWNlIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJlbmNvZGVSbHAiLCJhc3NlcnRBcmd1bWVudCIsImdldEFkZHJlc3MiLCJnZXRDcmVhdGVBZGRyZXNzIiwidHgiLCJmcm9tIiwibm9uY2UiLCJub25jZUhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZ2V0Q3JlYXRlMkFkZHJlc3MiLCJfZnJvbSIsIl9zYWx0IiwiX2luaXRDb2RlSGFzaCIsInNhbHQiLCJpbml0Q29kZUhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/address/contract-address.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/constants/addresses.js":
/*!****************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/constants/addresses.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: () => (/* binding */ ZeroAddress)\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */ const ZeroAddress = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9hZGRyZXNzZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0NBSUMsR0FDTSxNQUFNQSxjQUFjLDZDQUE2QyxDQUN4RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9hZGRyZXNzZXMuanM/YmZlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBhZGRyZXNzLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbIlplcm9BZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/constants/addresses.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/constants/hashes.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: () => (/* binding */ ZeroHash)\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */ const ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0NBSUMsR0FDTSxNQUFNQSxXQUFXLHFFQUFxRSxDQUM3RixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanM/OGEyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBoYXNoLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvSGFzaCA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbIlplcm9IYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/constants/hashes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/constants/strings.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/constants/strings.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherSymbol: () => (/* binding */ EtherSymbol),\n/* harmony export */   MessagePrefix: () => (/* binding */ MessagePrefix)\n/* harmony export */ });\n// NFKC (composed)             // (decomposed)\n/**\n *  A constant for the ether symbol (normalized using NFKC).\n *\n *  (**i.e.** ``\"\\\\u039e\"``)\n */ const EtherSymbol = \"Ξ\"; // \"\\uD835\\uDF63\";\n/**\n *  A constant for the [[link-eip-191]] personal message prefix.\n *\n *  (**i.e.** ``\"\\\\x19Ethereum Signed Message:\\\\n\"``)\n */ const MessagePrefix = \"\\x19Ethereum Signed Message:\\n\"; //# sourceMappingURL=strings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9zdHJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsOENBQThDO0FBQzlDOzs7O0NBSUMsR0FDTSxNQUFNQSxjQUFjLElBQVMsQ0FBQyxrQkFBa0I7QUFDdkQ7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdCQUFnQixpQ0FBaUMsQ0FDOUQsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvc3RyaW5ncy5qcz82ODM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBldGhlciBzeW1ib2wgKG5vcm1hbGl6ZWQgdXNpbmcgTkZLQykuXG4gKlxuICogICgqKmkuZS4qKiBgYFwiXFxcXHUwMzllXCJgYClcbiAqL1xuZXhwb3J0IGNvbnN0IEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsIG1lc3NhZ2UgcHJlZml4LlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXFxcblwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBNZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOlsiRXRoZXJTeW1ib2wiLCJNZXNzYWdlUHJlZml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/constants/strings.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/contract/contract.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/contract/contract.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../providers/provider.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wrappers.js */ \"(rsc)/../../node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nclass PreparedTopicFilter {\n    #filter;\n    constructor(contract, fragment, args){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from);\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        const iface = contract.interface;\n        const noValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function(...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function(...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function(...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function(...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args)=>{\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function(...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once })=>{\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof target === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_8__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            filters\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n} //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L2NvbnRyYWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUQ7QUFDaUI7QUFDcEUsc0VBQXNFO0FBQ3RFLHlCQUF5QjtBQUNtQztBQUNpRztBQUNqQjtBQUM1SSxNQUFNb0IsT0FBT0MsT0FBTztBQUNwQixTQUFTQyxRQUFRQyxLQUFLO0lBQ2xCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUMsSUFBSSxLQUFNO0FBQzdDO0FBQ0EsU0FBU0MsWUFBWUYsS0FBSztJQUN0QixPQUFRQSxTQUFTLE9BQVFBLE1BQU1HLFdBQVcsS0FBTTtBQUNwRDtBQUNBLFNBQVNDLFdBQVdKLEtBQUs7SUFDckIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNSyxXQUFXLEtBQU07QUFDcEQ7QUFDQSxTQUFTQyxRQUFRTixLQUFLO0lBQ2xCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTU8sZUFBZSxLQUFNO0FBQ3hEO0FBQ0EsTUFBTUM7SUFDRixDQUFDQyxNQUFNLENBQUM7SUFFUkMsWUFBWUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksQ0FBRTtRQUNsQzlCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRTZCO1FBQVM7UUFDbEMsSUFBSUEsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSwwREFBMEQ7UUFDMUQsTUFBTUMsU0FBU0MsVUFBVVAsU0FBU00sTUFBTSxFQUFFO1FBQzFDLE1BQU1FLFdBQVdmLFdBQVdhLFVBQVVBLFNBQVM7UUFDL0MsSUFBSSxDQUFDLENBQUNSLE1BQU0sR0FBRztZQUNYLE1BQU1XLGVBQWUsTUFBTUMsUUFBUUMsR0FBRyxDQUFDVixTQUFTRSxNQUFNLENBQUNTLEdBQUcsQ0FBQyxDQUFDQyxPQUFPQztnQkFDL0QsTUFBTUMsTUFBTWIsSUFBSSxDQUFDWSxNQUFNO2dCQUN2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Q3ZDLE9BQU9OO0lBQ1g7QUFDSjtBQUNBLFNBQVNnTDtJQUNMLE9BQU85QztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxNQUFNK0MsaUJBQWlCRDtBQUM5QixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanM/NWQxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UsIFR5cGVkIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNBZGRyZXNzYWJsZSwgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIExvZyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaXNDYWxsRXhjZXB0aW9uLCBpc0hleFN0cmluZywgcmVzb2x2ZVByb3BlcnRpZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGNhbkNhbGwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5Fc3RpbWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblNlbmQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xuICAgICNmaWx0ZXI7XG4gICAgZnJhZ21lbnQ7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmcmFnbWVudCB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoZnJhZ21lbnQuaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzcyh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZpbHRlcjtcbiAgICB9XG59XG4vLyBBID0gQXJndW1lbnRzIHBhc3NlZCBpbiBhcyBhIHR1cGxlXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcbi8vIEQgPSBUaGUgdHlwZSB0aGUgZGVmYXVsdCBjYWxsIHdpbGwgcmV0dXJuIChpLmUuIFIgZm9yIHZpZXcvcHVyZSxcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XG5mdW5jdGlvbiBnZXRSdW5uZXIodmFsdWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gVHlwZWQuZGVyZWZlcmVuY2UoYXJnLCBcIm92ZXJyaWRlc1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSBjb3B5UmVxdWVzdChfb3ZlcnJpZGVzKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMudG8gPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcInRvXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIHRvXCIsIFwib3ZlcnJpZGVzLnRvXCIsIG92ZXJyaWRlcy50byk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3Mob3ZlcnJpZGVzLmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQXJncyhfcnVubmVyLCBpbnB1dHMsIGFyZ3MpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKF9ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRGYWxsYmFjayhjb250cmFjdCkge1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBjb25zdCB0eCA9IChhd2FpdCBjb3B5T3ZlcnJpZGVzKG92ZXJyaWRlcywgW1wiZGF0YVwiXSkpO1xuICAgICAgICB0eC50byA9IGF3YWl0IGNvbnRyYWN0LmdldEFkZHJlc3MoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XG4gICAgICAgIGNvbnN0IG5vVmFsdWUgPSAoZ2V0QmlnSW50KCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlIG9yIHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXNcIiwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBwYXlhYmxlIGNvbnRyYWN0cyB0byBzZXQgbm9uLXplcm8gdmFsdWVcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IGlmYWNlLnJlY2VpdmUgfHwgKGlmYWNlLmZhbGxiYWNrICYmIGlmYWNlLmZhbGxiYWNrLnBheWFibGUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKG92ZXJyaWRlcyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbFxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRNZXRob2QoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsUmVzdWx0ID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbk5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGwsIHN0YXRpY0NhbGxSZXN1bHQsXG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFRvcGljRmlsdGVyKGNvbnRyYWN0LCBnZXRGcmFnbWVudCguLi5hcmdzKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnROYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnRcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFycmF5IG9mIFRvcGljcyBhbmQgTmFtZXM7IGUuZy4gYFsgXCIweDEyMzQuLi44OWFiXCIsIFwiVHJhbnNmZXIoYWRkcmVzcylcIiBdYFxuICAgICAgICB0b3BpY3MgPSBldmVudC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubWFwKHRvcGljSGFzaGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9waWNIYXNoaWZ5KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIHRvcGljcyA9IFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmZXJyZWQoZXZlbnQpKSB7XG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxuICAgICAgICBmcmFnbWVudCA9IGV2ZW50LmZyYWdtZW50O1xuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gZXZlbnQgbmFtZVwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljcyBhbmQgc29ydCBUb3BpY1NldHNcbiAgICB0b3BpY3MgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSkudmFsdWVzKCkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHRhZyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4geyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhc1N1Yihjb250cmFjdCwgZXZlbnQpIHtcbiAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICByZXR1cm4gc3Vicy5nZXQoKGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSkudGFnKSB8fCBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViKGNvbnRyYWN0LCBvcGVyYXRpb24sIGV2ZW50KSB7XG4gICAgLy8gTWFrZSBzdXJlIG91ciBydW5uZXIgY2FuIGFjdHVhbGx5IHN1YnNjcmliZSB0byBldmVudHNcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RFdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgX2ZvdW5kRnJhZ21lbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgW10sIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQpO1xuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICBzdWIgPSB7IHRhZywgbGlzdGVuZXJzOiBbXSwgc3RhcnQsIHN0b3AgfTtcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cbi8vIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nIChub3RlIHRoaXMgY2Fubm90IHRocm93IGFuZCBqdXN0IGFkZHMgdGhlXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmFzeW5jIGZ1bmN0aW9uIF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICAgICAgICBpZiAocGF5bG9hZEZ1bmMpIHtcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgIH0pO1xuICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgPiAwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcbiAgICBsYXN0RW1pdCA9IHJlc3VsdFByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG59XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FkZHJlc3NhYmxlKHRhcmdldCksIFwiaW52YWxpZCB2YWx1ZSBmb3IgQ29udHJhY3QgdGFyZ2V0XCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IEludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0YXJnZXQsIHJ1bm5lciwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgICAgbGV0IGFkZHJQcm9taXNlO1xuICAgICAgICBsZXQgYWRkciA9IG51bGw7XG4gICAgICAgIGxldCBkZXBsb3lUeCA9IG51bGw7XG4gICAgICAgIGlmIChfZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIocnVubmVyKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgICAgIGRlcGxveVR4ID0gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIF9kZXBsb3lUeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRhcmdldCBhcyB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGFkZHIgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZ2V0UnVubmVyKHJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlc29sdmUocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiYW4gRU5TIG5hbWUgdXNlZCBmb3IgYSBjb250cmFjdCB0YXJnZXQgbXVzdCBiZSBjb3JyZWN0bHkgY29uZmlndXJlZFwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3VyIHByaXZhdGUgdmFsdWVzXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSB8fCB0aGlzLmludGVyZmFjZS5oYXNFdmVudChTdHJpbmcocHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0RnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuaW50ZXJmYWNlLmhhc0Z1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHRhcmdldCBhbmQgQUJJLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0aGlzLnRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBBQkkgYW5kIHJ1bm5lciwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUldGFyZ2V0JSUuXG4gICAgICovXG4gICAgYXR0YWNoKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHJlc29sdmVkIGFkZHJlc3Mgb2YgdGhpcyBDb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gYXdhaXQgZ2V0SW50ZXJuYWwodGhpcykuYWRkclByb21pc2U7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkZXBsb3llZCBieXRlY29kZSBvciBudWxsIGlmIG5vIGJ5dGVjb2RlIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveWVkQ29kZSgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIGV2ZW50IG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLypcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXG4gICAgLy8gICAgICAgIHY2IHJlbGVhc2VcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XG5cbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxuICAgICAqICBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xuICAgICAgICBpZiAoZnJvbUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhZGRyLCBhZGRyUHJvbWlzZSB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MsIGZyb21CbG9jaywgdG9CbG9jayB9O1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlGaWx0ZXJcIiB9KTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcikpLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJS5cbiAgICAgKi9cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25cIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUsIGJ1dCByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICogIGFmdGVyIGl0IGlzIGZpcmVkIG9uY2UuXG4gICAgICovXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25jZVwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbWl0IGFuICUlZXZlbnQlJSBjYWxsaW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCAlJWFyZ3MlJS5cbiAgICAgKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXQodGhpcywgZXZlbnQsIGFyZ3MsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgb2YgJSVldmVudCUlIG9yIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiAgb2YgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gJSVldmVudCUlIG9yIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIHRoZSAlJWxpc3RlbmVyJSUgZnJvbSB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlXG4gICAgICogIGFsbCBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmUgYWxsIGxpc3RlbmVycyBpZlxuICAgICAqICB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCBzdG9wIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICBzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvbl0uXG4gICAgICovXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29mZl0uXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IENsYXNzIGZvciB0aGUgJSVhYmklJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRDbGFzcyhhYmkpIHtcbiAgICAgICAgY2xhc3MgQ3VzdG9tQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoYWRkcmVzcywgcnVubmVyID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKGFkZHJlc3MsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ3VzdG9tQ29udHJhY3Q7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEJhc2VDb250cmFjdCB3aXRoIGEgc3BlY2lmaWVkIEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0YXJnZXQsIGFiaSwgcnVubmVyKSB7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyB0aGlzKHRhcmdldCwgYWJpLCBydW5uZXIpO1xuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX0NvbnRyYWN0QmFzZSgpIHtcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xufVxuLyoqXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIl0sIm5hbWVzIjpbIkludGVyZmFjZSIsIlR5cGVkIiwiaXNBZGRyZXNzYWJsZSIsInJlc29sdmVBZGRyZXNzIiwiY29weVJlcXVlc3QiLCJMb2ciLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiaXNDYWxsRXhjZXB0aW9uIiwiaXNIZXhTdHJpbmciLCJyZXNvbHZlUHJvcGVydGllcyIsImlzRXJyb3IiLCJtYWtlRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwiRXZlbnRMb2ciLCJVbmRlY29kZWRFdmVudExvZyIsIkJOXzAiLCJCaWdJbnQiLCJjYW5DYWxsIiwidmFsdWUiLCJjYWxsIiwiY2FuRXN0aW1hdGUiLCJlc3RpbWF0ZUdhcyIsImNhblJlc29sdmUiLCJyZXNvbHZlTmFtZSIsImNhblNlbmQiLCJzZW5kVHJhbnNhY3Rpb24iLCJQcmVwYXJlZFRvcGljRmlsdGVyIiwiZmlsdGVyIiwiY29uc3RydWN0b3IiLCJjb250cmFjdCIsImZyYWdtZW50IiwiYXJncyIsImlucHV0cyIsImxlbmd0aCIsIkVycm9yIiwicnVubmVyIiwiZ2V0UnVubmVyIiwicmVzb2x2ZXIiLCJyZXNvbHZlZEFyZ3MiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicGFyYW0iLCJpbmRleCIsImFyZyIsIndhbGtBc3luYyIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJ2IiwiaW50ZXJmYWNlIiwiZW5jb2RlRmlsdGVyVG9waWNzIiwiZ2V0VG9waWNGaWx0ZXIiLCJmZWF0dXJlIiwicHJvdmlkZXIiLCJnZXRQcm92aWRlciIsImNvcHlPdmVycmlkZXMiLCJhbGxvd2VkIiwiX292ZXJyaWRlcyIsImRlcmVmZXJlbmNlIiwib3ZlcnJpZGVzIiwidG8iLCJpbmRleE9mIiwiZGF0YSIsImZyb20iLCJyZXNvbHZlQXJncyIsIl9ydW5uZXIiLCJidWlsZFdyYXBwZWRGYWxsYmFjayIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJ0eCIsImdldEFkZHJlc3MiLCJpZmFjZSIsIm5vVmFsdWUiLCJub0RhdGEiLCJmYWxsYmFjayIsInBheWFibGUiLCJyZWNlaXZlIiwic3RhdGljQ2FsbCIsIm9wZXJhdGlvbiIsImVycm9yIiwic2VuZCIsIm1ldGhvZCIsIl9jb250cmFjdCIsImJ1aWxkV3JhcHBlZE1ldGhvZCIsImtleSIsImdldEZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJpbmZvIiwicG9wIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwicmVzdWx0Iiwic3RhdGljQ2FsbFJlc3VsdCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiY29uc3RhbnQiLCJuYW1lIiwiZ2V0RnVuY3Rpb25OYW1lIiwiX2tleSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImJ1aWxkV3JhcHBlZEV2ZW50IiwiZ2V0RXZlbnQiLCJnZXRFdmVudE5hbWUiLCJpbnRlcm5hbCIsIlN5bWJvbCIsImZvciIsImludGVybmFsVmFsdWVzIiwiV2Vha01hcCIsInNldEludGVybmFsIiwidmFsdWVzIiwic2V0IiwiZ2V0SW50ZXJuYWwiLCJpc0RlZmVycmVkIiwiZ2V0U3ViSW5mbyIsImV2ZW50IiwidG9waWNzIiwidG9waWNIYXNoaWZ5IiwidG9waWNIYXNoIiwiZSIsInQiLCJpdGVtcyIsIlNldCIsInRvTG93ZXJDYXNlIiwic29ydCIsInRhZyIsImpvaW4iLCJoYXNTdWIiLCJzdWJzIiwiZ2V0U3ViIiwiYWRkciIsInN1YiIsImFkZHJlc3MiLCJsaXN0ZW5lciIsImxvZyIsImZvdW5kRnJhZ21lbnQiLCJfZm91bmRGcmFnbWVudCIsImRlY29kZUV2ZW50TG9nIiwiZW1pdCIsInN0YXJ0aW5nIiwic3RhcnQiLCJwdXNoIiwib24iLCJzdG9wIiwic3RhcnRlZCIsIm9mZiIsImxpc3RlbmVycyIsImxhc3RFbWl0IiwicmVzb2x2ZSIsIl9lbWl0IiwicGF5bG9hZEZ1bmMiLCJjb3VudCIsIm9uY2UiLCJwYXNzQXJncyIsImRlbGV0ZSIsInJlc3VsdFByb21pc2UiLCJwYXNzUHJvcGVydGllcyIsIkJhc2VDb250cmFjdCIsInRhcmdldCIsImFiaSIsIl9kZXBsb3lUeCIsImFkZHJQcm9taXNlIiwiZGVwbG95VHgiLCJNYXAiLCJ0aGVuIiwiZmlsdGVycyIsIlByb3h5IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImFyZ3VtZW50IiwidW5kZWZpbmVkIiwiaGFzIiwiaGFzRXZlbnQiLCJTdHJpbmciLCJoYXNGdW5jdGlvbiIsImNvbm5lY3QiLCJhdHRhY2giLCJnZXREZXBsb3llZENvZGUiLCJjb2RlIiwiZ2V0Q29kZSIsIndhaXRGb3JEZXBsb3ltZW50IiwiZGVwbG95bWVudFRyYW5zYWN0aW9uIiwid2FpdCIsInJlamVjdCIsImNoZWNrQ29kZSIsImZvcm1hdCIsImZ1bmMiLCJxdWVyeVRyYW5zYWN0aW9uIiwiaGFzaCIsInF1ZXJ5RmlsdGVyIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsImdldExvZ3MiLCJsaXN0ZW5lckNvdW50IiwidG90YWwiLCJjb25jYXQiLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYnVpbGRDbGFzcyIsIkN1c3RvbUNvbnRyYWN0IiwiX0NvbnRyYWN0QmFzZSIsIkNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/contract/contract.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            error\n        });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms) {\n        const receipt = await super.wait(confirms);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.EventPayload {\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            log\n        });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n} //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L3dyYXBwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHNFQUFzRTtBQUN0RSx5QkFBeUI7QUFDK0Q7QUFDckI7QUFDbkU7O0NBRUMsR0FDTSxNQUFNSyxpQkFBaUJMLHVEQUFHQTtJQWE3Qjs7S0FFQyxHQUNETSxZQUFZQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxDQUFFO1FBQzlCLEtBQUssQ0FBQ0YsS0FBS0EsSUFBSUcsUUFBUTtRQUN2QixNQUFNQyxPQUFPSCxNQUFNSSxjQUFjLENBQUNILFVBQVVGLElBQUlNLElBQUksRUFBRU4sSUFBSU8sTUFBTTtRQUNoRVgsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFUTtZQUFNRjtZQUFVTSxXQUFXUDtRQUFNO0lBQzlEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJUSxZQUFZO1FBQUUsT0FBTyxJQUFJLENBQUNQLFFBQVEsQ0FBQ1EsSUFBSTtJQUFFO0lBQzdDOztLQUVDLEdBQ0QsSUFBSUMsaUJBQWlCO1FBQUUsT0FBTyxJQUFJLENBQUNULFFBQVEsQ0FBQ1UsTUFBTTtJQUFJO0FBQzFEO0FBQ0E7O0NBRUMsR0FDTSxNQUFNQywwQkFBMEJwQix1REFBR0E7SUFLdEM7O0tBRUMsR0FDRE0sWUFBWUMsR0FBRyxFQUFFYyxLQUFLLENBQUU7UUFDcEIsS0FBSyxDQUFDZCxLQUFLQSxJQUFJRyxRQUFRO1FBQ3ZCUCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVrQjtRQUFNO0lBQ25DO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQyxtQ0FBbUNyQixzRUFBa0JBO0lBQzlELENBQUNPLEtBQUssQ0FBQztJQUNQOztLQUVDLEdBQ0RGLFlBQVlFLEtBQUssRUFBRUUsUUFBUSxFQUFFYSxFQUFFLENBQUU7UUFDN0IsS0FBSyxDQUFDQSxJQUFJYjtRQUNWLElBQUksQ0FBQyxDQUFDRixLQUFLLEdBQUdBO0lBQ2xCO0lBQ0E7OztLQUdDLEdBQ0QsSUFBSWdCLE9BQU87UUFDUCxPQUFPLEtBQUssQ0FBQ0EsS0FBS0MsR0FBRyxDQUFDLENBQUNsQjtZQUNuQixNQUFNRSxXQUFXRixJQUFJTyxNQUFNLENBQUNZLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQ2xCLEtBQUssQ0FBQ21CLFFBQVEsQ0FBQ3BCLElBQUlPLE1BQU0sQ0FBQyxFQUFFLElBQUk7WUFDM0UsSUFBSUwsVUFBVTtnQkFDVixJQUFJO29CQUNBLE9BQU8sSUFBSUosU0FBU0UsS0FBSyxJQUFJLENBQUMsQ0FBQ0MsS0FBSyxFQUFFQztnQkFDMUMsRUFDQSxPQUFPWSxPQUFPO29CQUNWLE9BQU8sSUFBSUQsa0JBQWtCYixLQUFLYztnQkFDdEM7WUFDSjtZQUNBLE9BQU9kO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTXFCLG9DQUFvQzFCLHVFQUFtQkE7SUFDaEUsQ0FBQ00sS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREYsWUFBWUUsS0FBSyxFQUFFRSxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBQ1YsSUFBSSxDQUFDLENBQUNGLEtBQUssR0FBR0E7SUFDbEI7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU1xQixLQUFLQyxRQUFRLEVBQUU7UUFDakIsTUFBTUMsVUFBVSxNQUFNLEtBQUssQ0FBQ0YsS0FBS0M7UUFDakMsSUFBSUMsV0FBVyxNQUFNO1lBQ2pCLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSVQsMkJBQTJCLElBQUksQ0FBQyxDQUFDZCxLQUFLLEVBQUUsSUFBSSxDQUFDRSxRQUFRLEVBQUVxQjtJQUN0RTtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsb0NBQW9DNUIseURBQVlBO0lBS3pEOztLQUVDLEdBQ0RFLFlBQVkyQixRQUFRLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFNUIsR0FBRyxDQUFFO1FBQ3pDLEtBQUssQ0FBQzBCLFVBQVVDLFVBQVVDO1FBQzFCaEMsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFSTtRQUFJO0lBQ2pDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNNkIsV0FBVztRQUNiLE9BQU8sTUFBTSxJQUFJLENBQUM3QixHQUFHLENBQUM2QixRQUFRO0lBQ2xDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxpQkFBaUI7UUFDbkIsT0FBTyxNQUFNLElBQUksQ0FBQzlCLEdBQUcsQ0FBQzhCLGNBQWM7SUFDeEM7SUFDQTs7S0FFQyxHQUNELE1BQU1DLHdCQUF3QjtRQUMxQixPQUFPLE1BQU0sSUFBSSxDQUFDL0IsR0FBRyxDQUFDK0IscUJBQXFCO0lBQy9DO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQyw2QkFBNkJQO0lBQ3RDOztLQUVDLEdBQ0QxQixZQUFZMkIsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRTFCLFFBQVEsRUFBRStCLElBQUksQ0FBRTtRQUNwRCxLQUFLLENBQUNQLFVBQVVDLFVBQVVDLFFBQVEsSUFBSTlCLFNBQVNtQyxNQUFNUCxTQUFTbEIsU0FBUyxFQUFFTjtRQUN6RSxNQUFNRSxPQUFPc0IsU0FBU2xCLFNBQVMsQ0FBQ0gsY0FBYyxDQUFDSCxVQUFVLElBQUksQ0FBQ0YsR0FBRyxDQUFDTSxJQUFJLEVBQUUsSUFBSSxDQUFDTixHQUFHLENBQUNPLE1BQU07UUFDdkZYLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVE7WUFBTUY7UUFBUztJQUM1QztJQUNBOztLQUVDLEdBQ0QsSUFBSU8sWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDUCxRQUFRLENBQUNRLElBQUk7SUFDN0I7SUFDQTs7S0FFQyxHQUNELElBQUlDLGlCQUFpQjtRQUNqQixPQUFPLElBQUksQ0FBQ1QsUUFBUSxDQUFDVSxNQUFNO0lBQy9CO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L3dyYXBwZXJzLmpzPzMyY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpOyB9XG59XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxuICAgICAqL1xuICAgIGVycm9yO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGxvZ3MgZm9yIGFueSBbW0xvZ11dIHdoaWNoIGhhcyBhIG1hdGNoaW5nIGV2ZW50IGluIHRoZVxuICAgICAqICBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2c7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UqKiB3aWxsIHJldHVybiBhXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoY29uZmlybXMpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2lmYWNlLCB0aGlzLnByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2cgd2l0aCBubyBtYXRjaGluZyBldmVudHMuXG4gICAgICovXG4gICAgbG9nO1xuICAgIC8qKlxuICAgICAqICBAX2V2ZW50OlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBsb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RFdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgaXMga25vd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEV2ZW50UGF5bG9hZCBleHRlbmRzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBmcmFnbWVudCwgX2xvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgdGhpcy5sb2cuZGF0YSwgdGhpcy5sb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwcGVycy5qcy5tYXAiXSwibmFtZXMiOlsiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJFdmVudExvZyIsImNvbnN0cnVjdG9yIiwibG9nIiwiaWZhY2UiLCJmcmFnbWVudCIsInByb3ZpZGVyIiwiYXJncyIsImRlY29kZUV2ZW50TG9nIiwiZGF0YSIsInRvcGljcyIsImludGVyZmFjZSIsImV2ZW50TmFtZSIsIm5hbWUiLCJldmVudFNpZ25hdHVyZSIsImZvcm1hdCIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiZXJyb3IiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsInR4IiwibG9ncyIsIm1hcCIsImxlbmd0aCIsImdldEV2ZW50IiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwid2FpdCIsImNvbmZpcm1zIiwicmVjZWlwdCIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsImNvbnRyYWN0IiwibGlzdGVuZXIiLCJmaWx0ZXIiLCJnZXRCbG9jayIsImdldFRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJfbG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/contract/wrappers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/hmac.js":
/*!********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/hmac.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: () => (/* binding */ computeHmac)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"crypto\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  An **HMAC** enables verification that a given key was used\n *  to authenticate a payload.\n *\n *  See: [[link-wiki-hmac]]\n *\n *  @_subsection: api/crypto:HMAC  [about-hmac]\n */ \n\nlet locked = false;\nconst _computeHmac = function(algorithm, key, data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHmac)(algorithm, key).update(data).digest();\n};\nlet __computeHmac = _computeHmac;\n/**\n *  Return the HMAC for %%data%% using the %%key%% key with the underlying\n *  %%algo%% used for compression.\n *\n *  @example:\n *    key = id(\"some-secret\")\n *\n *    // Compute the HMAC\n *    computeHmac(\"sha256\", key, \"0x1337\")\n *    //_result:\n *\n *    // To compute the HMAC of UTF-8 data, the data must be\n *    // converted to UTF-8 bytes\n *    computeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n *    //_result:\n *\n */ function computeHmac(algorithm, _key, _data) {\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_key, \"key\");\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__computeHmac(algorithm, key, data));\n}\ncomputeHmac._ = _computeHmac;\ncomputeHmac.lock = function() {\n    locked = true;\n};\ncomputeHmac.register = function(func) {\n    if (locked) {\n        throw new Error(\"computeHmac is locked\");\n    }\n    __computeHmac = func;\n};\nObject.freeze(computeHmac); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FDd0M7QUFDYTtBQUN0RCxJQUFJRyxTQUFTO0FBQ2IsTUFBTUMsZUFBZSxTQUFVQyxTQUFTLEVBQUVDLEdBQUcsRUFBRUMsSUFBSTtJQUMvQyxPQUFPUCxzREFBVUEsQ0FBQ0ssV0FBV0MsS0FBS0UsTUFBTSxDQUFDRCxNQUFNRSxNQUFNO0FBQ3pEO0FBQ0EsSUFBSUMsZ0JBQWdCTjtBQUNwQjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVNPLFlBQVlOLFNBQVMsRUFBRU8sSUFBSSxFQUFFQyxLQUFLO0lBQzlDLE1BQU1QLE1BQU1MLHlEQUFRQSxDQUFDVyxNQUFNO0lBQzNCLE1BQU1MLE9BQU9OLHlEQUFRQSxDQUFDWSxPQUFPO0lBQzdCLE9BQU9YLHdEQUFPQSxDQUFDUSxjQUFjTCxXQUFXQyxLQUFLQztBQUNqRDtBQUNBSSxZQUFZRyxDQUFDLEdBQUdWO0FBQ2hCTyxZQUFZSSxJQUFJLEdBQUc7SUFBY1osU0FBUztBQUFNO0FBQ2hEUSxZQUFZSyxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUNqQyxJQUFJZCxRQUFRO1FBQ1IsTUFBTSxJQUFJZSxNQUFNO0lBQ3BCO0lBQ0FSLGdCQUFnQk87QUFDcEI7QUFDQUUsT0FBT0MsTUFBTSxDQUFDVCxjQUNkLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2htYWMuanM/NjQzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbiAqKkhNQUMqKiBlbmFibGVzIHZlcmlmaWNhdGlvbiB0aGF0IGEgZ2l2ZW4ga2V5IHdhcyB1c2VkXG4gKiAgdG8gYXV0aGVudGljYXRlIGEgcGF5bG9hZC5cbiAqXG4gKiAgU2VlOiBbW2xpbmstd2lraS1obWFjXV1cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhNQUMgIFthYm91dC1obWFjXVxuICovXG5pbXBvcnQgeyBjcmVhdGVIbWFjIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2NvbXB1dGVIbWFjID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhtYWMoYWxnb3JpdGhtLCBrZXkpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19jb21wdXRlSG1hYyA9IF9jb21wdXRlSG1hYztcbi8qKlxuICogIFJldHVybiB0aGUgSE1BQyBmb3IgJSVkYXRhJSUgdXNpbmcgdGhlICUla2V5JSUga2V5IHdpdGggdGhlIHVuZGVybHlpbmdcbiAqICAlJWFsZ28lJSB1c2VkIGZvciBjb21wcmVzc2lvbi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZXkgPSBpZChcInNvbWUtc2VjcmV0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgSE1BQ1xuICogICAgY29tcHV0ZUhtYWMoXCJzaGEyNTZcIiwga2V5LCBcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRvIGNvbXB1dGUgdGhlIEhNQUMgb2YgVVRGLTggZGF0YSwgdGhlIGRhdGEgbXVzdCBiZVxuICogICAgLy8gY29udmVydGVkIHRvIFVURi04IGJ5dGVzXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIHRvVXRmOEJ5dGVzKFwiSGVsbG8gV29ybGRcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKF9rZXksIFwia2V5XCIpO1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcbn1cbmNvbXB1dGVIbWFjLl8gPSBfY29tcHV0ZUhtYWM7XG5jb21wdXRlSG1hYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xuY29tcHV0ZUhtYWMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcHV0ZUhtYWMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2NvbXB1dGVIbWFjID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGNvbXB1dGVIbWFjKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUhtYWMiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJsb2NrZWQiLCJfY29tcHV0ZUhtYWMiLCJhbGdvcml0aG0iLCJrZXkiLCJkYXRhIiwidXBkYXRlIiwiZGlnZXN0IiwiX19jb21wdXRlSG1hYyIsImNvbXB1dGVIbWFjIiwiX2tleSIsIl9kYXRhIiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJFcnJvciIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/hmac.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/../../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ \n\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9rZWNjYWsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUMrQztBQUNNO0FBQ3RELElBQUlHLFNBQVM7QUFDYixNQUFNQyxhQUFhLFNBQVVDLElBQUk7SUFDN0IsT0FBT0wsOERBQVVBLENBQUNLO0FBQ3RCO0FBQ0EsSUFBSUMsY0FBY0Y7QUFDbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNNLFNBQVNHLFVBQVVDLEtBQUs7SUFDM0IsTUFBTUgsT0FBT0oseURBQVFBLENBQUNPLE9BQU87SUFDN0IsT0FBT04sd0RBQU9BLENBQUNJLFlBQVlEO0FBQy9CO0FBQ0FFLFVBQVVFLENBQUMsR0FBR0w7QUFDZEcsVUFBVUcsSUFBSSxHQUFHO0lBQWNQLFNBQVM7QUFBTTtBQUM5Q0ksVUFBVUksUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDL0IsSUFBSVQsUUFBUTtRQUNSLE1BQU0sSUFBSVUsVUFBVTtJQUN4QjtJQUNBUCxjQUFjTTtBQUNsQjtBQUNBRSxPQUFPQyxNQUFNLENBQUNSLFlBQ2Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzPzc0MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQ3J5cHRvZ3JhcGhpYyBoYXNoaW5nIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnMgW2Fib3V0LWNyeXB0by1oYXNoaW5nXVxuICovXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBrZWNjYWtfMjU2KGRhdGEpO1xufTtcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIEtFQ0NBSzI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBUaGUgJSVkYXRhJSUgKiptdXN0KiogYmUgYSBkYXRhIHJlcHJlc2VudGF0aW9uLCB0byBjb21wdXRlIHRoZVxuICogIGhhc2ggb2YgVVRGLTggZGF0YSB1c2UgdGhlIFtbaWRdXSBmdW5jdGlvbi5cbiAqXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICogIEBleGFtcGxlOlxuICogICAga2VjY2FrMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqICAgIC8vIHRocm93LiBUbyBoYXNoIFVURi04IGRhdGEsIHNlZSB0aGUgbm90ZSBhYm92ZS5cbiAqICAgIGtlY2NhazI1NihcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fa2VjY2FrMjU2KGRhdGEpKTtcbn1cbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1NjtcbmtlY2NhazI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xua2VjY2FrMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWNjYWsyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShrZWNjYWsyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWtfMjU2IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibG9ja2VkIiwiX2tlY2NhazI1NiIsImRhdGEiLCJfX2tlY2NhazI1NiIsImtlY2NhazI1NiIsIl9kYXRhIiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJUeXBlRXJyb3IiLCJPYmplY3QiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/pbkdf2.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/pbkdf2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"crypto\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  A **Password-Based Key-Derivation Function** is designed to create\n *  a sequence of bytes suitible as a **key** from a human-rememberable\n *  password.\n *\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\n */ \n\nlet locked = false;\nconst _pbkdf2 = function(password, salt, iterations, keylen, algo) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.pbkdf2Sync)(password, salt, iterations, keylen, algo);\n};\nlet __pbkdf2 = _pbkdf2;\n/**\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\n *  the %%salt%% and using %%iterations%% of %%algo%%.\n *\n *  This PBKDF is outdated and should not be used in new projects, but is\n *  required to decrypt older files.\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the PBKDF2\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n *    //_result:\n */ function pbkdf2(_password, _salt, iterations, keylen, algo) {\n    const password = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_password, \"password\");\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));\n}\npbkdf2._ = _pbkdf2;\npbkdf2.lock = function() {\n    locked = true;\n};\npbkdf2.register = function(func) {\n    if (locked) {\n        throw new Error(\"pbkdf2 is locked\");\n    }\n    __pbkdf2 = func;\n};\nObject.freeze(pbkdf2); //# sourceMappingURL=pbkdf2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ3dDO0FBQ2E7QUFDdEQsSUFBSUcsU0FBUztBQUNiLE1BQU1DLFVBQVUsU0FBVUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQzlELE9BQU9ULHNEQUFVQSxDQUFDSyxVQUFVQyxNQUFNQyxZQUFZQyxRQUFRQztBQUMxRDtBQUNBLElBQUlDLFdBQVdOO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTTyxPQUFPQyxTQUFTLEVBQUVDLEtBQUssRUFBRU4sVUFBVSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7SUFDN0QsTUFBTUosV0FBV0oseURBQVFBLENBQUNXLFdBQVc7SUFDckMsTUFBTU4sT0FBT0wseURBQVFBLENBQUNZLE9BQU87SUFDN0IsT0FBT1gsd0RBQU9BLENBQUNRLFNBQVNMLFVBQVVDLE1BQU1DLFlBQVlDLFFBQVFDO0FBQ2hFO0FBQ0FFLE9BQU9HLENBQUMsR0FBR1Y7QUFDWE8sT0FBT0ksSUFBSSxHQUFHO0lBQWNaLFNBQVM7QUFBTTtBQUMzQ1EsT0FBT0ssUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSWQsUUFBUTtRQUNSLE1BQU0sSUFBSWUsTUFBTTtJQUNwQjtJQUNBUixXQUFXTztBQUNmO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1QsU0FDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9wYmtkZjIuanM/MjA3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24qKiBpcyBkZXNpZ25lZCB0byBjcmVhdGVcbiAqICBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN1aXRpYmxlIGFzIGEgKiprZXkqKiBmcm9tIGEgaHVtYW4tcmVtZW1iZXJhYmxlXG4gKiAgcGFzc3dvcmQuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpQYXNzd29yZHMgIFthYm91dC1wYmtkZl1cbiAqL1xuaW1wb3J0IHsgcGJrZGYyU3luYyB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9wYmtkZjIgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xuICAgIHJldHVybiBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pO1xufTtcbmxldCBfX3Bia2RmMiA9IF9wYmtkZjI7XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbbGluay1wYmtkZjJdXSBmb3IgJSVrZXlsZW4lJSBieXRlcyBmb3IgJSVwYXNzd29yZCUlIHVzaW5nXG4gKiAgdGhlICUlc2FsdCUlIGFuZCB1c2luZyAlJWl0ZXJhdGlvbnMlJSBvZiAlJWFsZ28lJS5cbiAqXG4gKiAgVGhpcyBQQktERiBpcyBvdXRkYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cywgYnV0IGlzXG4gKiAgcmVxdWlyZWQgdG8gZGVjcnlwdCBvbGRlciBmaWxlcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIFBCS0RGMlxuICogICAgcGJrZGYyKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDE2LCBcInNoYTI1NlwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKF9wYXNzd29yZCwgX3NhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0Qnl0ZXMoX3Bhc3N3b3JkLCBcInBhc3N3b3JkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pKTtcbn1cbnBia2RmMi5fID0gX3Bia2RmMjtcbnBia2RmMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucGJrZGYyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBia2RmMiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcGJrZGYyID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHBia2RmMik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIl0sIm5hbWVzIjpbInBia2RmMlN5bmMiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJsb2NrZWQiLCJfcGJrZGYyIiwicGFzc3dvcmQiLCJzYWx0IiwiaXRlcmF0aW9ucyIsImtleWxlbiIsImFsZ28iLCJfX3Bia2RmMiIsInBia2RmMiIsIl9wYXNzd29yZCIsIl9zYWx0IiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJFcnJvciIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/random.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/random.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"crypto\");\n/**\n *  A **Cryptographically Secure Random Value** is one that has been\n *  generated with additional care take to prevent side-channels\n *  from allowing others to detect it and prevent others from through\n *  coincidence generate the same values.\n *\n *  @_subsection: api/crypto:Random Values  [about-crypto-random]\n */ \nlet locked = false;\nconst _randomBytes = function(length) {\n    return new Uint8Array((0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(length));\n};\nlet __randomBytes = _randomBytes;\n/**\n *  Return %%length%% bytes of cryptographically secure random data.\n *\n *  @example:\n *    randomBytes(8)\n *    //_result:\n */ function randomBytes(length) {\n    return __randomBytes(length);\n}\nrandomBytes._ = _randomBytes;\nrandomBytes.lock = function() {\n    locked = true;\n};\nrandomBytes.register = function(func) {\n    if (locked) {\n        throw new Error(\"randomBytes is locked\");\n    }\n    __randomBytes = func;\n};\nObject.freeze(randomBytes); //# sourceMappingURL=random.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9yYW5kb20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQzBEO0FBQzNELElBQUlFLFNBQVM7QUFDYixNQUFNQyxlQUFlLFNBQVVDLE1BQU07SUFDakMsT0FBTyxJQUFJQyxXQUFXSix1REFBYUEsQ0FBQ0c7QUFDeEM7QUFDQSxJQUFJRSxnQkFBZ0JIO0FBQ3BCOzs7Ozs7Q0FNQyxHQUNNLFNBQVNILFlBQVlJLE1BQU07SUFDOUIsT0FBT0UsY0FBY0Y7QUFDekI7QUFDQUosWUFBWU8sQ0FBQyxHQUFHSjtBQUNoQkgsWUFBWVEsSUFBSSxHQUFHO0lBQWNOLFNBQVM7QUFBTTtBQUNoREYsWUFBWVMsUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDakMsSUFBSVIsUUFBUTtRQUNSLE1BQU0sSUFBSVMsTUFBTTtJQUNwQjtJQUNBTCxnQkFBZ0JJO0FBQ3BCO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ2IsY0FDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9yYW5kb20uanM/NzJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqQ3J5cHRvZ3JhcGhpY2FsbHkgU2VjdXJlIFJhbmRvbSBWYWx1ZSoqIGlzIG9uZSB0aGF0IGhhcyBiZWVuXG4gKiAgZ2VuZXJhdGVkIHdpdGggYWRkaXRpb25hbCBjYXJlIHRha2UgdG8gcHJldmVudCBzaWRlLWNoYW5uZWxzXG4gKiAgZnJvbSBhbGxvd2luZyBvdGhlcnMgdG8gZGV0ZWN0IGl0IGFuZCBwcmV2ZW50IG90aGVycyBmcm9tIHRocm91Z2hcbiAqICBjb2luY2lkZW5jZSBnZW5lcmF0ZSB0aGUgc2FtZSB2YWx1ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpSYW5kb20gVmFsdWVzICBbYWJvdXQtY3J5cHRvLXJhbmRvbV1cbiAqL1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgYXMgY3J5cHRvX3JhbmRvbSB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjcnlwdG9fcmFuZG9tKGxlbmd0aCkpO1xufTtcbmxldCBfX3JhbmRvbUJ5dGVzID0gX3JhbmRvbUJ5dGVzO1xuLyoqXG4gKiAgUmV0dXJuICUlbGVuZ3RoJSUgYnl0ZXMgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBkYXRhLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJhbmRvbUJ5dGVzKDgpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICByZXR1cm4gX19yYW5kb21CeXRlcyhsZW5ndGgpO1xufVxucmFuZG9tQnl0ZXMuXyA9IF9yYW5kb21CeXRlcztcbnJhbmRvbUJ5dGVzLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5yYW5kb21CeXRlcy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb21CeXRlcyBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcmFuZG9tQnl0ZXMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocmFuZG9tQnl0ZXMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCJdLCJuYW1lcyI6WyJyYW5kb21CeXRlcyIsImNyeXB0b19yYW5kb20iLCJsb2NrZWQiLCJfcmFuZG9tQnl0ZXMiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwiX19yYW5kb21CeXRlcyIsIl8iLCJsb2NrIiwicmVnaXN0ZXIiLCJmdW5jIiwiRXJyb3IiLCJPYmplY3QiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/random.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/ripemd160.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/ripemd160.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(rsc)/../../node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n\n\nlet locked = false;\nconst _ripemd160 = function(data) {\n    return (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_0__.ripemd160)(data);\n};\nlet __ripemd160 = _ripemd160;\n/**\n *  Compute the cryptographic RIPEMD-160 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    ripemd160(\"0x\")\n *    //_result:\n *\n *    ripemd160(\"0x1337\")\n *    //_result:\n *\n *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function ripemd160(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__ripemd160(data));\n}\nripemd160._ = _ripemd160;\nripemd160.lock = function() {\n    locked = true;\n};\nripemd160.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"ripemd160 is locked\");\n    }\n    __ripemd160 = func;\n};\nObject.freeze(ripemd160); //# sourceMappingURL=ripemd160.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVFO0FBQ2pCO0FBQ3RELElBQUlJLFNBQVM7QUFDYixNQUFNQyxhQUFhLFNBQVVDLElBQUk7SUFDN0IsT0FBT0wsa0VBQWVBLENBQUNLO0FBQzNCO0FBQ0EsSUFBSUMsY0FBY0Y7QUFDbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTTCxVQUFVUSxLQUFLO0lBQzNCLE1BQU1GLE9BQU9KLHlEQUFRQSxDQUFDTSxPQUFPO0lBQzdCLE9BQU9MLHdEQUFPQSxDQUFDSSxZQUFZRDtBQUMvQjtBQUNBTixVQUFVUyxDQUFDLEdBQUdKO0FBQ2RMLFVBQVVVLElBQUksR0FBRztJQUFjTixTQUFTO0FBQU07QUFDOUNKLFVBQVVXLFFBQVEsR0FBRyxTQUFVQyxJQUFJO0lBQy9CLElBQUlSLFFBQVE7UUFDUixNQUFNLElBQUlTLFVBQVU7SUFDeEI7SUFDQU4sY0FBY0s7QUFDbEI7QUFDQUUsT0FBT0MsTUFBTSxDQUFDZixZQUNkLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3JpcGVtZDE2MC5qcz9iYWIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfcmlwZW1kMTYwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbm9ibGVfcmlwZW1kMTYwKGRhdGEpO1xufTtcbmxldCBfX3JpcGVtZDE2MCA9IF9yaXBlbWQxNjA7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFJJUEVNRC0xNjAgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgcmlwZW1kMTYwKFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICByaXBlbWQxNjAoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICByaXBlbWQxNjAobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJpcGVtZDE2MChfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fcmlwZW1kMTYwKGRhdGEpKTtcbn1cbnJpcGVtZDE2MC5fID0gX3JpcGVtZDE2MDtcbnJpcGVtZDE2MC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucmlwZW1kMTYwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyaXBlbWQxNjAgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3JpcGVtZDE2MCA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShyaXBlbWQxNjApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6WyJyaXBlbWQxNjAiLCJub2JsZV9yaXBlbWQxNjAiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJsb2NrZWQiLCJfcmlwZW1kMTYwIiwiZGF0YSIsIl9fcmlwZW1kMTYwIiwiX2RhdGEiLCJfIiwibG9jayIsInJlZ2lzdGVyIiwiZnVuYyIsIlR5cGVFcnJvciIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/ripemd160.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/scrypt.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/scrypt.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptSync: () => (/* binding */ scryptSync)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/scrypt */ \"(rsc)/../../node_modules/@noble/hashes/esm/scrypt.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n\n\nlet lockedSync = false, lockedAsync = false;\nconst _scryptAsync = async function(passwd, salt, N, r, p, dkLen, onProgress) {\n    return await (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__.scryptAsync)(passwd, salt, {\n        N,\n        r,\n        p,\n        dkLen,\n        onProgress\n    });\n};\nconst _scryptSync = function(passwd, salt, N, r, p, dkLen) {\n    return (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__.scrypt)(passwd, salt, {\n        N,\n        r,\n        p,\n        dkLen\n    });\n};\nlet __scryptAsync = _scryptAsync;\nlet __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */ async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\n    const passwd = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_passwd, \"passwd\");\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n}\nscrypt._ = _scryptAsync;\nscrypt.lock = function() {\n    lockedAsync = true;\n};\nscrypt.register = function(func) {\n    if (lockedAsync) {\n        throw new Error(\"scrypt is locked\");\n    }\n    __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */ function scryptSync(_passwd, _salt, N, r, p, dkLen) {\n    const passwd = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_passwd, \"passwd\");\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nscryptSync._ = _scryptSync;\nscryptSync.lock = function() {\n    lockedSync = true;\n};\nscryptSync.register = function(func) {\n    if (lockedSync) {\n        throw new Error(\"scryptSync is locked\");\n    }\n    __scryptSync = func;\n};\nObject.freeze(scryptSync); //# sourceMappingURL=scrypt.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zY3J5cHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RjtBQUM3QjtBQUMzRCxJQUFJTyxhQUFhLE9BQU9DLGNBQWM7QUFDdEMsTUFBTUMsZUFBZSxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsVUFBVTtJQUN6RSxPQUFPLE1BQU1iLGlFQUFXQSxDQUFDTyxRQUFRQyxNQUFNO1FBQUVDO1FBQUdDO1FBQUdDO1FBQUdDO1FBQU9DO0lBQVc7QUFDeEU7QUFDQSxNQUFNQyxjQUFjLFNBQVVQLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLO0lBQ3RELE9BQU9kLDREQUFVQSxDQUFDUyxRQUFRQyxNQUFNO1FBQUVDO1FBQUdDO1FBQUdDO1FBQUdDO0lBQU07QUFDckQ7QUFDQSxJQUFJRyxnQkFBZ0JUO0FBQ3BCLElBQUlVLGVBQWVGO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxlQUFlakIsT0FBT29CLE9BQU8sRUFBRUMsS0FBSyxFQUFFVCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVPLFFBQVE7SUFDakUsTUFBTVosU0FBU04seURBQVFBLENBQUNnQixTQUFTO0lBQ2pDLE1BQU1ULE9BQU9QLHlEQUFRQSxDQUFDaUIsT0FBTztJQUM3QixPQUFPZix3REFBQ0EsQ0FBQyxNQUFNWSxjQUFjUixRQUFRQyxNQUFNQyxHQUFHQyxHQUFHQyxHQUFHQyxPQUFPTztBQUMvRDtBQUNBdEIsT0FBT3VCLENBQUMsR0FBR2Q7QUFDWFQsT0FBT3dCLElBQUksR0FBRztJQUFjaEIsY0FBYztBQUFNO0FBQ2hEUixPQUFPeUIsUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSWxCLGFBQWE7UUFDYixNQUFNLElBQUltQixNQUFNO0lBQ3BCO0lBQ0FULGdCQUFnQlE7QUFDcEI7QUFDQUUsT0FBT0MsTUFBTSxDQUFDN0I7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBUzhCLFdBQVdWLE9BQU8sRUFBRUMsS0FBSyxFQUFFVCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLO0lBQ3JELE1BQU1MLFNBQVNOLHlEQUFRQSxDQUFDZ0IsU0FBUztJQUNqQyxNQUFNVCxPQUFPUCx5REFBUUEsQ0FBQ2lCLE9BQU87SUFDN0IsT0FBT2Ysd0RBQUNBLENBQUNhLGFBQWFULFFBQVFDLE1BQU1DLEdBQUdDLEdBQUdDLEdBQUdDO0FBQ2pEO0FBQ0FlLFdBQVdQLENBQUMsR0FBR047QUFDZmEsV0FBV04sSUFBSSxHQUFHO0lBQWNqQixhQUFhO0FBQU07QUFDbkR1QixXQUFXTCxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUNoQyxJQUFJbkIsWUFBWTtRQUNaLE1BQU0sSUFBSW9CLE1BQU07SUFDcEI7SUFDQVIsZUFBZU87QUFDbkI7QUFDQUUsT0FBT0MsTUFBTSxDQUFDQyxhQUNkLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NjcnlwdC5qcz9iMmUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNjcnlwdCBhcyBfbm9ibGVTeW5jLCBzY3J5cHRBc3luYyBhcyBfbm9ibGVBc3luYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NjcnlwdFwiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgYXMgSCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZFN5bmMgPSBmYWxzZSwgbG9ja2VkQXN5bmMgPSBmYWxzZTtcbmNvbnN0IF9zY3J5cHRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IF9ub2JsZUFzeW5jKHBhc3N3ZCwgc2FsdCwgeyBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcyB9KTtcbn07XG5jb25zdCBfc2NyeXB0U3luYyA9IGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgcmV0dXJuIF9ub2JsZVN5bmMocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuIH0pO1xufTtcbmxldCBfX3NjcnlwdEFzeW5jID0gX3NjcnlwdEFzeW5jO1xubGV0IF9fc2NyeXB0U3luYyA9IF9zY3J5cHRTeW5jO1xuLyoqXG4gKiAgVGhlIFtbbGluay13aWtpLXNjcnlwdF1dIHVzZXMgYSBtZW1vcnkgYW5kIGNwdSBoYXJkIG1ldGhvZCBvZlxuICogIGRlcml2YXRpb24gdG8gaW5jcmVhc2UgdGhlIHJlc291cmNlIGNvc3QgdG8gYnJ1dGUtZm9yY2UgYSBwYXNzd29yZFxuICogIGZvciBhIGdpdmVuIGtleS5cbiAqXG4gKiAgVGhpcyBtZWFucyB0aGlzIGFsZ29yaXRobSBpcyBpbnRlbnRpb25hbGx5IHNsb3csIGFuZCBjYW4gYmUgdHVuZWQgdG9cbiAqICBiZWNvbWUgc2xvd2VyLiBBcyBjb21wdXRhdGlvbiBhbmQgbWVtb3J5IHNwZWVkIGltcHJvdmUgb3ZlciB0aW1lLFxuICogIGluY3JlYXNpbmcgdGhlIGRpZmZpY3VsdHkgbWFpbnRhaW5zIHRoZSBjb3N0IG9mIGFuIGF0dGFja2VyLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSB0YXJnZXQgdGltZSBvZiA1IHNlY29uZHMgaXMgdXNlZCwgYSBsZWdpdGltYXRlIHVzZXJcbiAqICB3aGljaCBrbm93cyB0aGVpciBwYXNzd29yZCByZXF1aXJlcyBvbmx5IDUgc2Vjb25kcyB0byB1bmxvY2sgdGhlaXJcbiAqICBhY2NvdW50LiBBIDYgY2hhcmFjdGVyIHBhc3N3b3JkIGhhcyA2OCBiaWxsaW9uIHBvc3NpYmlsaXRpZXMsIHdoaWNoXG4gKiAgd291bGQgcmVxdWlyZSBhbiBhdHRhY2tlciB0byBpbnZlc3Qgb3ZlciAxMCwwMDAgeWVhcnMgb2YgQ1BVIHRpbWUuIFRoaXNcbiAqICBpcyBvZiBjb3Vyc2UgYSBjcnVkZSBleGFtcGxlIChhcyBwYXNzd29yZCBnZW5lcmFsbHkgYXJlbid0IHJhbmRvbSksXG4gKiAgYnV0IGRlbW9uc3RyYXRlcyB0byB2YWx1ZSBvZiBpbXBvc2luZyBsYXJnZSBjb3N0cyB0byBkZWNyeXB0aW9uLlxuICpcbiAqICBGb3IgdGhpcyByZWFzb24sIGlmIGJ1aWxkaW5nIGEgVUkgd2hpY2ggaW52b2x2ZWQgZGVjcnlwdGluZyBvclxuICogIGVuY3J5cHRpbmcgZGF0c2EgdXNpbmcgc2NyeXB0LCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYVxuICogIFtbUHJvZ3Jlc3NDYWxsYmFja11dIChhcyBldmVudCBzaG9ydCBwZXJpb2RzIGNhbiBzZWVtIGxpayBhbiBldGVybml0eVxuICogIGlmIHRoZSBVSSBmcmVlemVzKS4gSW5jbHVkaW5nIHRoZSBwaHJhc2UgLy9cImRlY3J5cHRpbmdcIi8vIGluIHRoZSBVSVxuICogIGNhbiBhbHNvIGhlbHAsIGFzc3VyaW5nIHRoZSB1c2VyIHRoZWlyIHdhaXRpbmcgaXMgZm9yIGEgZ29vZCByZWFzb24uXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XG4gKiAgICBzY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY3J5cHQoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IHBhc3N3ZCA9IGdldEJ5dGVzKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIHJldHVybiBIKGF3YWl0IF9fc2NyeXB0QXN5bmMocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpKTtcbn1cbnNjcnlwdC5fID0gX3NjcnlwdEFzeW5jO1xuc2NyeXB0LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZEFzeW5jID0gdHJ1ZTsgfTtcbnNjcnlwdC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZEFzeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjcnlwdCBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2NyeXB0QXN5bmMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2NyeXB0KTtcbi8qKlxuICogIFByb3ZpZGVzIGEgc3luY2hyb25vdXMgdmFyaWFudCBvZiBbW3NjcnlwdF1dLlxuICpcbiAqICBUaGlzIHdpbGwgY29tcGxldGVseSBsb2NrIHVwIGFuZCBmcmVlemUgdGhlIFVJIGluIGEgYnJvd3NlciBhbmQgd2lsbFxuICogIHByZXZlbnQgYW55IGV2ZW50IGxvb3AgZnJvbSBwcm9ncmVzc2luZy4gRm9yIHRoaXMgcmVhc29uLCBpdCBpc1xuICogIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2YXJpYW50XShzY3J5cHQpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpQYXNzd29yZHNcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIHNjcnlwdFxuICogICAgc2NyeXB0U3luYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCAxMDI0LCA4LCAxLCAxNilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcnlwdFN5bmMoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgY29uc3QgcGFzc3dkID0gZ2V0Qnl0ZXMoX3Bhc3N3ZCwgXCJwYXNzd2RcIik7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuIEgoX19zY3J5cHRTeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcbn1cbnNjcnlwdFN5bmMuXyA9IF9zY3J5cHRTeW5jO1xuc2NyeXB0U3luYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRTeW5jID0gdHJ1ZTsgfTtcbnNjcnlwdFN5bmMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWRTeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjcnlwdFN5bmMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NjcnlwdFN5bmMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2NyeXB0U3luYyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3J5cHQuanMubWFwIl0sIm5hbWVzIjpbInNjcnlwdCIsIl9ub2JsZVN5bmMiLCJzY3J5cHRBc3luYyIsIl9ub2JsZUFzeW5jIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiSCIsImxvY2tlZFN5bmMiLCJsb2NrZWRBc3luYyIsIl9zY3J5cHRBc3luYyIsInBhc3N3ZCIsInNhbHQiLCJOIiwiciIsInAiLCJka0xlbiIsIm9uUHJvZ3Jlc3MiLCJfc2NyeXB0U3luYyIsIl9fc2NyeXB0QXN5bmMiLCJfX3NjcnlwdFN5bmMiLCJfcGFzc3dkIiwiX3NhbHQiLCJwcm9ncmVzcyIsIl8iLCJsb2NrIiwicmVnaXN0ZXIiLCJmdW5jIiwiRXJyb3IiLCJPYmplY3QiLCJmcmVlemUiLCJzY3J5cHRTeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/scrypt.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/sha2.js":
/*!********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"crypto\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n\n\nconst _sha256 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function sha256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function() {\n    locked256 = true;\n};\nsha256.register = function(func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */ function sha512(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function() {\n    locked512 = true;\n};\nsha512.register = function(func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDYTtBQUN0RCxNQUFNRyxVQUFVLFNBQVVDLElBQUk7SUFDMUIsT0FBT0osc0RBQVVBLENBQUMsVUFBVUssTUFBTSxDQUFDRCxNQUFNRSxNQUFNO0FBQ25EO0FBQ0EsTUFBTUMsVUFBVSxTQUFVSCxJQUFJO0lBQzFCLE9BQU9KLHNEQUFVQSxDQUFDLFVBQVVLLE1BQU0sQ0FBQ0QsTUFBTUUsTUFBTTtBQUNuRDtBQUNBLElBQUlFLFdBQVdMO0FBQ2YsSUFBSU0sV0FBV0Y7QUFDZixJQUFJRyxZQUFZLE9BQU9DLFlBQVk7QUFDbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTQyxPQUFPQyxLQUFLO0lBQ3hCLE1BQU1ULE9BQU9ILHlEQUFRQSxDQUFDWSxPQUFPO0lBQzdCLE9BQU9YLHdEQUFPQSxDQUFDTSxTQUFTSjtBQUM1QjtBQUNBUSxPQUFPRSxDQUFDLEdBQUdYO0FBQ1hTLE9BQU9HLElBQUksR0FBRztJQUFjTCxZQUFZO0FBQU07QUFDOUNFLE9BQU9JLFFBQVEsR0FBRyxTQUFVQyxJQUFJO0lBQzVCLElBQUlQLFdBQVc7UUFDWCxNQUFNLElBQUlRLE1BQU07SUFDcEI7SUFDQVYsV0FBV1M7QUFDZjtBQUNBRSxPQUFPQyxNQUFNLENBQUNSO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sU0FBU1MsT0FBT1IsS0FBSztJQUN4QixNQUFNVCxPQUFPSCx5REFBUUEsQ0FBQ1ksT0FBTztJQUM3QixPQUFPWCx3REFBT0EsQ0FBQ08sU0FBU0w7QUFDNUI7QUFDQWlCLE9BQU9QLENBQUMsR0FBR1A7QUFDWGMsT0FBT04sSUFBSSxHQUFHO0lBQWNKLFlBQVk7QUFBTTtBQUM5Q1UsT0FBT0wsUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSU4sV0FBVztRQUNYLE1BQU0sSUFBSU8sTUFBTTtJQUNwQjtJQUNBVCxXQUFXUTtBQUNmO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1IsU0FDZCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaGEyLmpzPzY1ODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5jb25zdCBfc2hhNTEyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaChcInNoYTUxMlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59O1xubGV0IF9fc2hhMjU2ID0gX3NoYTI1NjtcbmxldCBfX3NoYTUxMiA9IF9zaGE1MTI7XG5sZXQgbG9ja2VkMjU2ID0gZmFsc2UsIGxvY2tlZDUxMiA9IGZhbHNlO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGEyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGEyNTYoZGF0YSkpO1xufVxuc2hhMjU2Ll8gPSBfc2hhMjU2O1xuc2hhMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDI1NiA9IHRydWU7IH07XG5zaGEyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQyNTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zaGEyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi01MTIgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgc2hhNTEyKFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGE1MTIoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGE1MTIobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhNTEyKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGE1MTIoZGF0YSkpO1xufVxuc2hhNTEyLl8gPSBfc2hhNTEyO1xuc2hhNTEyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDUxMiA9IHRydWU7IH07XG5zaGE1MTIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQ1MTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhNTEyIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zaGE1MTIgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUhhc2giLCJnZXRCeXRlcyIsImhleGxpZnkiLCJfc2hhMjU2IiwiZGF0YSIsInVwZGF0ZSIsImRpZ2VzdCIsIl9zaGE1MTIiLCJfX3NoYTI1NiIsIl9fc2hhNTEyIiwibG9ja2VkMjU2IiwibG9ja2VkNTEyIiwic2hhMjU2IiwiX2RhdGEiLCJfIiwibG9jayIsInJlZ2lzdGVyIiwiZnVuYyIsIkVycm9yIiwiT2JqZWN0IiwiZnJlZXplIiwic2hhNTEyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/sha2.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/signature.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */ class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */ get r() {\n        return this.#r;\n    }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */ get s() {\n        return this.#s;\n    }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */ get v() {\n        return this.#v;\n    }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get networkV() {\n        return this.#networkV;\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */ get yParity() {\n        return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */ get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */ get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.yParityAndS\n        ]);\n    }\n    /**\n     *  The serialized representation.\n     */ get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.s,\n            this.yParity ? \"0x1c\" : \"0x1b\"\n        ]);\n    }\n    /**\n     *  @private\n     */ constructor(guard, r, s, v){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */ clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */ toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: networkV != null ? networkV.toString() : null,\n            r: this.r,\n            s: this.s,\n            v: this.v\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */ static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if (bv == BN_27 || bv == BN_28) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */ static getChainIdV(chainId, v) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */ static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */ static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, 27);\n        }\n        if (typeof sig === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = s[0] & 0x80 ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = function(s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        }(sig.s, sig.yParityAndS);\n        assertError(((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = function(_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_v);\n                return {\n                    networkV: v >= BN_35 ? v : undefined,\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return {\n                    v: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n                };\n            }\n            if (yParity != null) {\n                switch((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(yParity, \"sig.yParity\")){\n                    case 0:\n                        return {\n                            v: 27\n                        };\n                    case 1:\n                        return {\n                            v: 28\n                        };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n} //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUQ7QUFDb0g7QUFDckssWUFBWTtBQUNaLE1BQU1ZLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLFFBQVFILE9BQU87QUFDckIsTUFBTUksUUFBUUosT0FBTztBQUNyQixNQUFNSyxRQUFRTCxPQUFPO0FBQ3JCLE1BQU1NLFNBQVMsQ0FBQztBQUNoQixTQUFTQyxVQUFVQyxLQUFLO0lBQ3BCLE9BQU9aLDZEQUFZQSxDQUFDRiwwREFBU0EsQ0FBQ2MsUUFBUTtBQUMxQztBQUNBOzs7OztDQUtDLEdBQ00sTUFBTUM7SUFDVCxDQUFDQyxDQUFDLENBQUM7SUFDSCxDQUFDQyxDQUFDLENBQUM7SUFDSCxDQUFDQyxDQUFDLENBQUM7SUFDSCxDQUFDQyxRQUFRLENBQUM7SUFDVjs7Ozs7S0FLQyxHQUNELElBQUlILElBQUk7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxDQUFDO0lBQUU7SUFDMUIsSUFBSUEsRUFBRUYsS0FBSyxFQUFFO1FBQ1RYLCtEQUFjQSxDQUFDUiwyREFBVUEsQ0FBQ21CLFdBQVcsSUFBSSxhQUFhLFNBQVNBO1FBQy9ELElBQUksQ0FBQyxDQUFDRSxDQUFDLEdBQUdqQix3REFBT0EsQ0FBQ2U7SUFDdEI7SUFDQTs7S0FFQyxHQUNELElBQUlHLElBQUk7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxDQUFDO0lBQUU7SUFDMUIsSUFBSUEsRUFBRUcsTUFBTSxFQUFFO1FBQ1ZqQiwrREFBY0EsQ0FBQ1IsMkRBQVVBLENBQUN5QixZQUFZLElBQUksYUFBYSxTQUFTQTtRQUNoRSxNQUFNTixRQUFRZix3REFBT0EsQ0FBQ3FCO1FBQ3RCakIsK0RBQWNBLENBQUNrQixTQUFTUCxNQUFNUSxTQUFTLENBQUMsR0FBRyxNQUFNLEdB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TztRQUN0QyxNQUFNMkIsU0FBUyxJQUFJckMsVUFBVUgsUUFBUUksR0FBR0MsR0FBR0M7UUFDM0MsSUFBSUMsVUFBVTtZQUNWaUMsT0FBTyxDQUFDakMsUUFBUSxHQUFHQTtRQUN2QjtRQUNBLG9FQUFvRTtRQUNwRXdCLFlBQVlELElBQUlqQixPQUFPLElBQUksUUFBUTNCLDBEQUFTQSxDQUFDNEMsSUFBSWpCLE9BQU8sRUFBRSxtQkFBbUIyQixPQUFPM0IsT0FBTyxFQUFFO1FBQzdGa0IsWUFBWUQsSUFBSWhCLFdBQVcsSUFBSSxRQUFRZ0IsSUFBSWhCLFdBQVcsS0FBSzBCLE9BQU8xQixXQUFXLEVBQUU7UUFDL0UsT0FBTzBCO0lBQ1g7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcz9kZDAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFplcm9IYXNoIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydFByaXZhdGUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0b1VpbnQyNTYodmFsdWUpIHtcbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHRvQmVBcnJheSh2YWx1ZSksIDMyKTtcbn1cbi8qKlxuICogIEEgU2lnbmF0dXJlICBAVE9ET1xuICpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86U2lnbmluZ1xuICovXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAjcjtcbiAgICAjcztcbiAgICAjdjtcbiAgICAjbmV0d29ya1Y7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHJgYCB2YWx1ZSBmb3IgYSBzaWduYXV0cmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxuICAgICAqICBjaGFsbGVuZ2UgcG9pbnQsIGZyb20gd2hpY2ggdGhlIGBgeWBgIGNhbiBiZSBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cbiAgICBzZXQgcih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCByXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNyID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBzKCkgeyByZXR1cm4gdGhpcy4jczsgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShfdmFsdWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMCwgMykpIDwgOCwgXCJub24tY2Fub25pY2FsIHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxuICAgICAqICB2YWx1ZXMgdG8gdXNlLlxuICAgICAqXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcbiAgICAgKiAgcHVycG9zZXMuXG4gICAgICovXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XG4gICAgc2V0IHYodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9IGdldEJ5dGVzKHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnlQYXJpdHkpIHtcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoeVBhcml0eUFuZFMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IGNvbXBhY3RTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMucywgKHRoaXMueVBhcml0eSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJTaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMuI3IgPSByO1xuICAgICAgICB0aGlzLiNzID0gcztcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgICAgIHRoaXMuI25ldHdvcmtWID0gbnVsbDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6IFwiJHt0aGlzLnJ9XCIsIHM6IFwiJHt0aGlzLnN9XCIsIHlQYXJpdHk6ICR7dGhpcy55UGFyaXR5fSwgbmV0d29ya1Y6ICR7dGhpcy5uZXR3b3JrVn0gfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IGlkZW50aWNhbCBbW1NpZ25hdHVyZV1dLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCB0aGlzLnIsIHRoaXMucywgdGhpcy52KTtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya1YpIHtcbiAgICAgICAgICAgIGNsb25lLiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBgSlNPTi5zdHJpbmdpZnlgYC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgbmV0d29ya1Y6ICgobmV0d29ya1YgIT0gbnVsbCkgPyBuZXR3b3JrVi50b1N0cmluZygpIDogbnVsbCksXG4gICAgICAgICAgICByOiB0aGlzLnIsIHM6IHRoaXMucywgdjogdGhpcy52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYGB2YGAgaW4gYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCBFSVAtMTU1IHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBMZWdhY3kgdHJhbnNhY3Rpb25zIHdoaWNoIHVzZSBbW2xpbmstZWlwLTE1NV1dIGhpamFjayB0aGUgYGB2YGBcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xuICAgICAgICByZXR1cm4gKGdldEJpZ0ludChjaGFpbklkKSAqIEJOXzIpICsgQmlnSW50KDM1ICsgdiAtIDI3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIG5vcm1hbGl6ZWQgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIGZyb20gYSBgYHlQYXJpcnR5YGAsXG4gICAgICogIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIG9yIGEgbGVnYWN5IFtbbGluay1laXAtMTU1XV0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgLy8gVGhlIHZhbHVlcyAwIGFuZCAxIGltcGx5IHYgaXMgYWN0dWFsbHkgeVBhcml0eVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigwKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBub24tRUlQLTE1NTkgdHJhbnNhY3Rpb24gKGkuZS4gMjcgb3IgMjgpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9uIChpLmUuID49IDM1KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBJbnZhbGlkIHZhbHVlcyB0aHJvd1xuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig1KVxuICAgICAqICAgIC8vX2Vycm9yOlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXROb3JtYWxpemVkVih2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxuICAgICAgICByZXR1cm4gKGJ2ICYgQk5fMSkgPyAyNyA6IDI4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1NpZ25hdHVyZV1dLlxuICAgICAqXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxuICAgICAqICB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBcInNpZ25hdHVyZVwiLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHNpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIFplcm9IYXNoLCBaZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoc2lnLCBcInNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKHNbMF0gJiAweDgwKSA/IDI4IDogMjc7XG4gICAgICAgICAgICAgICAgc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKHNbMF0gJiAweDgwKSA9PT0gMCwgXCJub24tY2Fub25pY2FsIHNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVihieXRlc1s2NF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHJhdyBzaWduYXR1cmUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWcuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgclxuICAgICAgICBjb25zdCBfciA9IHNpZy5yO1xuICAgICAgICBhc3NlcnRFcnJvcihfciAhPSBudWxsLCBcIm1pc3NpbmcgclwiKTtcbiAgICAgICAgY29uc3QgciA9IHRvVWludDI1Nihfcik7XG4gICAgICAgIC8vIEdldCBzOyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgcyA9IChmdW5jdGlvbiAocywgeVBhcml0eUFuZFMpIHtcbiAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VaW50MjU2KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh5UGFyaXR5QW5kUyk7XG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHNcIik7XG4gICAgICAgIH0pKHNpZy5zLCBzaWcueVBhcml0eUFuZFMpO1xuICAgICAgICBhc3NlcnRFcnJvcigoZ2V0Qnl0ZXMocylbMF0gJiAweDgwKSA9PSAwLCBcIm5vbi1jYW5vbmljYWwgc1wiKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0QmlnSW50KF92KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdjogKChnZXRCeXRlcyh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChnZXROdW1iZXIoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHsgdjogMjggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCBnZXROdW1iZXIoc2lnLnlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikgPT09IHJlc3VsdC55UGFyaXR5LCBcInlQYXJpdHkgbWlzbWF0Y2hcIik7XG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5QW5kUyA9PSBudWxsIHx8IHNpZy55UGFyaXR5QW5kUyA9PT0gcmVzdWx0LnlQYXJpdHlBbmRTLCBcInlQYXJpdHlBbmRTIG1pc21hdGNoXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiWmVyb0hhc2giLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydFByaXZhdGUiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJfZ3VhcmQiLCJ0b1VpbnQyNTYiLCJ2YWx1ZSIsIlNpZ25hdHVyZSIsInIiLCJzIiwidiIsIm5ldHdvcmtWIiwiX3ZhbHVlIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJsZWdhY3lDaGFpbklkIiwiZ2V0Q2hhaW5JZCIsInlQYXJpdHkiLCJ5UGFyaXR5QW5kUyIsImNvbXBhY3RTZXJpYWxpemVkIiwic2VyaWFsaXplZCIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJTeW1ib2wiLCJmb3IiLCJjbG9uZSIsInRvSlNPTiIsIl90eXBlIiwidG9TdHJpbmciLCJidiIsImdldENoYWluSWRWIiwiY2hhaW5JZCIsImdldE5vcm1hbGl6ZWRWIiwiZnJvbSIsInNpZyIsImFzc2VydEVycm9yIiwiY2hlY2siLCJtZXNzYWdlIiwiYnl0ZXMiLCJsZW5ndGgiLCJzbGljZSIsIl9yIiwiX3YiLCJ1bmRlZmluZWQiLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/signature.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey)\n/* harmony export */ });\n/* harmony import */ var _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/secp256k1 */ \"(rsc)/../../node_modules/@noble/secp256k1/lib/esm/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/hmac.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./signature.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */ \n\n\n\n//const N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n// Make noble-secp256k1 sync\n_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.hmacSha256Sync = function(key, ...messages) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)((0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.computeHmac)(\"sha256\", key, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(messages)));\n};\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */ class SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */ constructor(privateKey){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */ get privateKey() {\n        return this.#privateKey;\n    }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */ get publicKey() {\n        return SigningKey.computePublicKey(this.#privateKey);\n    }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */ get compressedPublicKey() {\n        return SigningKey.computePublicKey(this.#privateKey, true);\n    }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */ sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const [sigDer, recid] = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.signSync((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), {\n            recovered: true,\n            canonical: true\n        });\n        const sig = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.Signature.fromHex(sigDer);\n        return _signature_js__WEBPACK_IMPORTED_MODULE_4__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toBeHex)(\"0x\" + sig.r.toString(16), 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toBeHex)(\"0x\" + sig.s.toString(16), 32),\n            v: recid ? 0x1c : 0x1b\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */ computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(pubKey)));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */ static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.Point.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */ static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_4__.Signature.from(signature);\n        const der = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            sig.r,\n            sig.s\n        ]))).toDERRawBytes();\n        const pubKey = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest), der, sig.yParity);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(pubKey);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */ static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.Point.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.Point.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n} //# sourceMappingURL=signing-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduaW5nLWtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUM2QztBQUNtRTtBQUN6RTtBQUNHO0FBQzNDLHlGQUF5RjtBQUN6Riw0QkFBNEI7QUFDNUJBLG1EQUFlLENBQUNXLGNBQWMsR0FBRyxTQUFVQyxHQUFHLEVBQUUsR0FBR0MsUUFBUTtJQUN2RCxPQUFPVix5REFBUUEsQ0FBQ0sscURBQVdBLENBQUMsVUFBVUksS0FBS1gsdURBQU1BLENBQUNZO0FBQ3REO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUM7SUFDVCxDQUFDQyxVQUFVLENBQUM7SUFDWjs7S0FFQyxHQUNEQyxZQUFZRCxVQUFVLENBQUU7UUFDcEJSLCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ2EsZ0JBQWdCLElBQUksdUJBQXVCLGNBQWM7UUFDbkYsSUFBSSxDQUFDLENBQUNBLFVBQVUsR0FBR1Ysd0RBQU9BLENBQUNVO0lBQy9CO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsVUFBVTtJQUFFO0lBQzVDOzs7OztLQUtDLEdBQ0QsSUFBSUUsWUFBWTtRQUFFLE9BQU9ILFdBQVdJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDSCxVQUFVO0lBQUc7SUFDeEU7Ozs7OztLQU1DLEdBQ0QsSUFBSUksc0JBQXNCO1FBQUUsT0FBT0wsV0FBV0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUNILFVBQVUsRUFBRTtJQUFPO0lBQ3hGOztLQUVDLEdBQ0RLLEtBQUtDLE1BQU0sRUFBRTtRQUNUZCwrREFBY0EsQ0FBQ0wsMkRBQVVBLENBQUNtQixZQUFZLElBQUkseUJBQXlCLFVBQVVBO1FBQzdFLE1BQU0sQ0FBQ0MsUUFBUUMsTUFBTSxHQUFHdkIsc0RBQWtCLENBQUNJLDZEQUFZQSxDQUFDaUIsU0FBU2pCLDZEQUFZQSxDQUFDLElBQUksQ0FBQyxDQUFDVyxVQUFVLEdBQUc7WUFDN0ZVLFdBQVc7WUFDWEMsV0FBVztRQUNmO1FBQ0EsTUFBTUMsTUFBTTNCLHVEQUFtQixDQUFDNEIsT0FBTyxDQUFDTjtRQUN4QyxPQUFPYixvREFBU0EsQ0FBQ29CLElBQUksQ0FBQztZQUNsQkMsR0FBR3hCLHdEQUFPQSxDQUFDLE9BQU9xQixJQUFJRyxDQUFDLENBQUNDLFFBQVEsQ0FBQyxLQUFLO1lBQ3RDQyxHQUFHMUIsd0RBQU9BLENBQUMsT0FBT3FCLElBQUlLLENBQUMsQ0FBQ0QsUUFBUSxDQUFDLEtBQUs7WUFDdENFLEdBQUlWLFFBQVEsT0FBTztRQUN2QjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEVyxvQkFBb0JDLEtBQUssRUFBRTtRQUN2QixNQUFNQyxTQUFTdEIsV0FBV0ksZ0JBQWdCLENBQUNpQjtRQUMzQyxPQUFPOUIsd0RBQU9BLENBQUNMLDZEQUF5QixDQUFDSSw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ1csVUFBVSxHQUFHWix5REFBUUEsQ0FBQ2lDO0lBQ3RGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXdCQyxHQUNELE9BQU9sQixpQkFBaUJOLEdBQUcsRUFBRTBCLFVBQVUsRUFBRTtRQUNyQyxJQUFJQyxRQUFRcEMseURBQVFBLENBQUNTLEtBQUs7UUFDMUIsY0FBYztRQUNkLElBQUkyQixNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNSixTQUFTcEMsMERBQXNCLENBQUN1QyxPQUFPLENBQUMsQ0FBQ0Q7WUFDL0MsT0FBT2pDLHdEQUFPQSxDQUFDK0I7UUFDbkI7UUFDQSx3REFBd0Q7UUFDeEQsSUFBSUcsTUFBTUMsTUFBTSxLQUFLLElBQUk7WUFDckIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXO1lBQzNCRCxHQUFHLENBQUMsRUFBRSxHQUFHO1lBQ1RBLElBQUlFLEdBQUcsQ0FBQ0wsT0FBTztZQUNmQSxRQUFRRztRQUNaO1FBQ0EsTUFBTUcsUUFBUTdDLG1EQUFlLENBQUM0QixPQUFPLENBQUNXO1FBQ3RDLE9BQU9sQyx3REFBT0EsQ0FBQ3dDLE1BQU1FLFVBQVUsQ0FBQ1Q7SUFDcEM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQkMsR0FDRCxPQUFPVSxpQkFBaUIzQixNQUFNLEVBQUU0QixTQUFTLEVBQUU7UUFDdkMxQywrREFBY0EsQ0FBQ0wsMkRBQVVBLENBQUNtQixZQUFZLElBQUkseUJBQXlCLFVBQVVBO1FBQzdFLE1BQU1NLE1BQU1sQixvREFBU0EsQ0FBQ29CLElBQUksQ0FBQ29CO1FBQzNCLE1BQU1DLE1BQU1sRCx1REFBbUIsQ0FBQ21ELFdBQVcsQ0FBQy9DLDZEQUFZQSxDQUFDSCx1REFBTUEsQ0FBQztZQUFDMEIsSUFBSUcsQ0FBQztZQUFFSCxJQUFJSyxDQUFDO1NBQUMsSUFBSW9CLGFBQWE7UUFDL0YsTUFBTWhCLFNBQVNwQyw4REFBMEIsQ0FBQ0ksNkRBQVlBLENBQUNpQixTQUFTNkIsS0FBS3ZCLElBQUkwQixPQUFPO1FBQ2hGOUMsK0RBQWNBLENBQUM2QixVQUFVLE1BQU0sZ0NBQWdDLGFBQWFhO1FBQzVFLE9BQU81Qyx3REFBT0EsQ0FBQytCO0lBQ25CO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QsT0FBT2tCLFVBQVVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFbEIsVUFBVSxFQUFFO1FBQ2pDLE1BQU1tQixPQUFPekQsbURBQWUsQ0FBQzRCLE9BQU8sQ0FBQ2QsV0FBV0ksZ0JBQWdCLENBQUNxQyxJQUFJRyxTQUFTLENBQUM7UUFDL0UsTUFBTUMsT0FBTzNELG1EQUFlLENBQUM0QixPQUFPLENBQUNkLFdBQVdJLGdCQUFnQixDQUFDc0MsSUFBSUUsU0FBUyxDQUFDO1FBQy9FLE9BQU8sT0FBT0QsS0FBS0csR0FBRyxDQUFDRCxNQUFNRSxLQUFLLENBQUMsQ0FBQyxDQUFDdkI7SUFDekM7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzP2Q0OTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tIFwiQG5vYmxlL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29tcHV0ZUhtYWMgfSBmcm9tIFwiLi9obWFjLmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUuanNcIjtcbi8vY29uc3QgTiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKTtcbi8vIE1ha2Ugbm9ibGUtc2VjcDI1NmsxIHN5bmNcbnNlY3AyNTZrMS51dGlscy5obWFjU2hhMjU2U3luYyA9IGZ1bmN0aW9uIChrZXksIC4uLm1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIGdldEJ5dGVzKGNvbXB1dGVIbWFjKFwic2hhMjU2XCIsIGtleSwgY29uY2F0KG1lc3NhZ2VzKSkpO1xufTtcbi8qKlxuICogIEEgKipTaWduaW5nS2V5KiogcHJvdmlkZXMgaGlnaC1sZXZlbCBhY2Nlc3MgdG8gdGhlIGVsbGlwdGljIGN1cnZlXG4gKiAgY3J5cHRvZ3JhcGh5IChFQ0MpIG9wZXJhdGlvbnMgYW5kIGtleSBtYW5hZ2VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgU2lnbmluZ0tleSB7XG4gICAgI3ByaXZhdGVLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTaWduaW5nS2V5KiogZm9yICUlcHJpdmF0ZUtleSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChwcml2YXRlS2V5KSA9PT0gMzIsIFwiaW52YWxpZCBwcml2YXRlIGtleVwiLCBcInByaXZhdGVLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICB0aGlzLiNwcml2YXRlS2V5ID0gaGV4bGlmeShwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuI3ByaXZhdGVLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGAweDA0YGAgYW5kIGJlIDEzMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDEzMCBoZXhhZGVjaW1hbCBuaWJibGVzKS5cbiAgICAgKi9cbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIGVpdGhlciB0aGUgcHJlZml4IGBgMHgwMmBgIG9yIGBgMHgwM2BgXG4gICAgICogIGFuZCBiZSA2OCBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAzMyBoZXhhZGVjaW1hbFxuICAgICAqICBuaWJibGVzKVxuICAgICAqL1xuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXksIHRydWUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgJSVkaWdlc3QlJS5cbiAgICAgKi9cbiAgICBzaWduKGRpZ2VzdCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBbc2lnRGVyLCByZWNpZF0gPSBzZWNwMjU2azEuc2lnblN5bmMoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgcmVjb3ZlcmVkOiB0cnVlLFxuICAgICAgICAgICAgY2Fub25pY2FsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWcgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21IZXgoc2lnRGVyKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoXCIweFwiICsgc2lnLnIudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICAgICAgICBzOiB0b0JlSGV4KFwiMHhcIiArIHNpZy5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICAgICAgdjogKHJlY2lkID8gMHgxYyA6IDB4MWIpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgW1tsaW5rLXdpa2ktZWNkaF1dIHNoYXJlZCBzZWNyZXQgYmV0d2VlbiB0aGlzXG4gICAgICogIHByaXZhdGUga2V5IGFuZCB0aGUgJSVvdGhlciUlIGtleS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVvdGhlciUlIGtleSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LFxuICAgICAqICBhIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmljIGtleSBvciBhcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQmVzdCBwcmFjdGljZSBpcyB1c3VhbGx5IHRvIHVzZSBhIGNyeXB0b2dyYXBoaWMgaGFzaCBvbiB0aGVcbiAgICAgKiAgcmV0dXJuZWQgdmFsdWUgYmVmb3JlIHVzaW5nIGl0IGFzIGEgc3ltZXRyaWMgc2VjcmV0LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24xID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0xXCIpKVxuICAgICAqICAgIHNpZ24yID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0yXCIpKVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoYXQgcHJpdkEuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJCKS4uLlxuICAgICAqICAgIHNpZ24xLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjIucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHByaXZCLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQSkuXG4gICAgICogICAgc2lnbjIuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMS5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIGNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIGdldEJ5dGVzKHB1YktleSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xuICAgICAgICAgICAgcHViLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qb2ludC5mcm9tSGV4KGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocG9pbnQudG9SYXdCeXRlcyhjb21wcmVzc2VkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGZvciB0aGUgcHJpdmF0ZSBrZXkgd2hpY2ggcHJvZHVjZWQgdGhlXG4gICAgICogICUlc2lnbmF0dXJlJSUgZm9yIHRoZSBnaXZlbiAlJWRpZ2VzdCUlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIGtleSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpXG4gICAgICogICAgZGlnZXN0ID0gaWQoXCJoZWxsbyB3b3JsZFwiKVxuICAgICAqICAgIHNpZyA9IGtleS5zaWduKGRpZ2VzdClcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGUgc2lnbmVyIHB1YmxpYyBrZXkuLi5cbiAgICAgKiAgICBrZXkucHVibGljS2V5XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gdGhlIHJlY292ZXJlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IGRlciA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3QoZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbc2lnLnIsIHNpZy5zXSkpKS50b0RFUlJhd0J5dGVzKCk7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyUHVibGljS2V5KGdldEJ5dGVzQ29weShkaWdlc3QpLCBkZXIsIHNpZy55UGFyaXR5KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHViS2V5ICE9IG51bGwsIFwiaW52YWxpZCBzaWduYXR1cmUgZm9yIGRpZ2VzdFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAwKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICBjb25zdCBwdWIxID0gc2VjcDI1NmsxLlBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAxKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViMC5hZGQocHViMSkudG9IZXgoISFjb21wcmVzc2VkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLWtleS5qcy5tYXAiXSwibmFtZXMiOlsic2VjcDI1NmsxIiwiY29uY2F0IiwiZGF0YUxlbmd0aCIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsInRvQmVIZXgiLCJhc3NlcnRBcmd1bWVudCIsImNvbXB1dGVIbWFjIiwiU2lnbmF0dXJlIiwidXRpbHMiLCJobWFjU2hhMjU2U3luYyIsImtleSIsIm1lc3NhZ2VzIiwiU2lnbmluZ0tleSIsInByaXZhdGVLZXkiLCJjb25zdHJ1Y3RvciIsInB1YmxpY0tleSIsImNvbXB1dGVQdWJsaWNLZXkiLCJjb21wcmVzc2VkUHVibGljS2V5Iiwic2lnbiIsImRpZ2VzdCIsInNpZ0RlciIsInJlY2lkIiwic2lnblN5bmMiLCJyZWNvdmVyZWQiLCJjYW5vbmljYWwiLCJzaWciLCJmcm9tSGV4IiwiZnJvbSIsInIiLCJ0b1N0cmluZyIsInMiLCJ2IiwiY29tcHV0ZVNoYXJlZFNlY3JldCIsIm90aGVyIiwicHViS2V5IiwiZ2V0U2hhcmVkU2VjcmV0IiwiY29tcHJlc3NlZCIsImJ5dGVzIiwibGVuZ3RoIiwiZ2V0UHVibGljS2V5IiwicHViIiwiVWludDhBcnJheSIsInNldCIsInBvaW50IiwiUG9pbnQiLCJ0b1Jhd0J5dGVzIiwicmVjb3ZlclB1YmxpY0tleSIsInNpZ25hdHVyZSIsImRlciIsImZyb21Db21wYWN0IiwidG9ERVJSYXdCeXRlcyIsInlQYXJpdHkiLCJhZGRQb2ludHMiLCJwMCIsInAxIiwicHViMCIsInN1YnN0cmluZyIsInB1YjEiLCJhZGQiLCJ0b0hleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/hash/id.js":
/*!****************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/hash/id.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ0M7QUFDaEQ7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLFNBQVNFLEdBQUdDLEtBQUs7SUFDcEIsT0FBT0gsMkRBQVNBLENBQUNDLDREQUFXQSxDQUFDRTtBQUNqQyxFQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcz9lYWJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBBIHNpbXBsZSBoYXNoaW5nIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIFVURi04IHN0cmluZ3MgdG9cbiAqICBjb21wdXRlIGFuIDMyLWJ5dGUgaWRlbnRpZmllci5cbiAqXG4gKiAgVGhpcyBzaW1wbHkgY29tcHV0ZXMgdGhlIFtVVEYtOCBieXRlc10odG9VdGY4Qnl0ZXMpIGFuZCBjb21wdXRlc1xuICogIHRoZSBbW2tlY2NhazI1Nl1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGlkKFwiaGVsbG8gd29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtlY2NhazI1Nih0b1V0ZjhCeXRlcyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsInRvVXRmOEJ5dGVzIiwiaWQiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/hash/message.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/hash/message.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   verifyMessage: () => (/* binding */ verifyMessage)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/strings.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n\n\n\n\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */ function hashMessage(message) {\n    if (typeof message === \"string\") {\n        message = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(message);\n    }\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(_constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MessagePrefix),\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(String(message.length)),\n        message\n    ]));\n}\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */ function verifyMessage(message, sig) {\n    const digest = hashMessage(message);\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress)(digest, sig);\n} //# sourceMappingURL=message.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStDO0FBQ087QUFDRztBQUNEO0FBQ3hEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkMsR0FDTSxTQUFTSyxZQUFZQyxPQUFPO0lBQy9CLElBQUksT0FBUUEsWUFBYSxVQUFVO1FBQy9CQSxVQUFVRiw0REFBV0EsQ0FBQ0U7SUFDMUI7SUFDQSxPQUFPTiwyREFBU0EsQ0FBQ0csdURBQU1BLENBQUM7UUFDcEJDLDREQUFXQSxDQUFDSCw4REFBYUE7UUFDekJHLDREQUFXQSxDQUFDRyxPQUFPRCxRQUFRRSxNQUFNO1FBQ2pDRjtLQUNIO0FBQ0w7QUFDQTs7O0NBR0MsR0FDTSxTQUFTRyxjQUFjSCxPQUFPLEVBQUVJLEdBQUc7SUFDdEMsTUFBTUMsU0FBU04sWUFBWUM7SUFDM0IsT0FBT0oscUVBQWNBLENBQUNTLFFBQVFEO0FBQ2xDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL21lc3NhZ2UuanM/ODRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlUHJlZml4IH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIENvbXB1dGVzIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsLXNpZ24gbWVzc2FnZSBkaWdlc3QgdG8gc2lnbi5cbiAqXG4gKiAgVGhpcyBwcmVmaXhlcyB0aGUgbWVzc2FnZSB3aXRoIFtbTWVzc2FnZVByZWZpeF1dIGFuZCB0aGUgZGVjaW1hbCBsZW5ndGhcbiAqICBvZiAlJW1lc3NhZ2UlJSBhbmQgY29tcHV0ZXMgdGhlIFtba2VjY2FrMjU2XV0gZGlnZXN0LlxuICpcbiAqICBJZiAlJW1lc3NhZ2UlJSBpcyBhIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGl0cyBVVEYtOCBieXRlc1xuICogIGZpcnN0LiBUbyBjb21wdXRlIHRoZSBkaWdlc3Qgb2YgYSBbW0RhdGFIZXhTdHJpbmddXSwgaXQgbXVzdCBiZSBjb252ZXJ0ZWRcbiAqICB0byBbYnl0ZXNdKGdldEJ5dGVzKS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBoYXNoTWVzc2FnZShcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSGFzaGVzIHRoZSBTSVggKDYpIHN0cmluZyBjaGFyYWN0ZXJzLCBpLmUuXG4gKiAgICAvLyBbIFwiMFwiLCBcInhcIiwgXCI0XCIsIFwiMlwiLCBcIjRcIiwgXCIzXCIgXVxuICogICAgaGFzaE1lc3NhZ2UoXCIweDQyNDNcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBIYXNoZXMgdGhlIFRXTyAoMikgYnl0ZXMgWyAweDQyLCAweDQzIF0uLi5cbiAqICAgIGhhc2hNZXNzYWdlKGdldEJ5dGVzKFwiMHg0MjQzXCIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIC4uLndoaWNoIGlzIGVxdWFsIHRvIHVzaW5nIGRhdGFcbiAqICAgIGhhc2hNZXNzYWdlKG5ldyBVaW50OEFycmF5KFsgMHg0MiwgMHg0MyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRvVXRmOEJ5dGVzKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXG4gICAgICAgIHRvVXRmOEJ5dGVzKE1lc3NhZ2VQcmVmaXgpLFxuICAgICAgICB0b1V0ZjhCeXRlcyhTdHJpbmcobWVzc2FnZS5sZW5ndGgpKSxcbiAgICAgICAgbWVzc2FnZVxuICAgIF0pKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgYWRkcmVzcyBvZiB0aGUgcHJpdmF0ZSBrZXkgdGhhdCBwcm9kdWNlZFxuICogIHRoZSBzaWduYXR1cmUgJSVzaWclJSBkdXJpbmcgc2lnbmluZyBmb3IgJSVtZXNzYWdlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKG1lc3NhZ2UsIHNpZykge1xuICAgIGNvbnN0IGRpZ2VzdCA9IGhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJNZXNzYWdlUHJlZml4IiwicmVjb3ZlckFkZHJlc3MiLCJjb25jYXQiLCJ0b1V0ZjhCeXRlcyIsImhhc2hNZXNzYWdlIiwibWVzc2FnZSIsIlN0cmluZyIsImxlbmd0aCIsInZlcmlmeU1lc3NhZ2UiLCJzaWciLCJkaWdlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/hash/message.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/hash/namehash.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/hash/namehash.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(rsc)/../../node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */ function ensNormalize(name) {\n    try {\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */ function isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */ function namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)([\n            result,\n            (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */ function dnsEncode(name) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)(ensNameSplit(name).map((comp)=>{\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ2tDO0FBQzFCO0FBQ3ZELE1BQU1NLFFBQVEsSUFBSUMsV0FBVztBQUM3QkQsTUFBTUUsSUFBSSxDQUFDO0FBQ1gsU0FBU0MsZUFBZUMsSUFBSTtJQUN4QlAsK0RBQWNBLENBQUNPLEtBQUtDLE1BQU0sS0FBSyxHQUFHLHFDQUFxQyxRQUFRRDtJQUMvRSxPQUFPQTtBQUNYO0FBQ0EsU0FBU0UsYUFBYUMsSUFBSTtJQUN0QixNQUFNQyxRQUFRViw0REFBV0EsQ0FBQ1csYUFBYUY7SUFDdkMsTUFBTUcsUUFBUSxFQUFFO0lBQ2hCLElBQUlILEtBQUtGLE1BQU0sS0FBSyxHQUFHO1FBQ25CLE9BQU9LO0lBQ1g7SUFDQSxJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLE1BQU1ILE1BQU0sRUFBRU8sSUFBSztRQUNuQyxNQUFNQyxJQUFJTCxLQUFLLENBQUNJLEVBQUU7UUFDbEIsOENBQThDO1FBQzlDLElBQUlDLE1BQU0sTUFBTTtZQUNaSCxNQUFNSSxJQUFJLENBQUNYLGVBQWVLLE1BQU1PLEtBQUssQ0FBQ0osTUFBTUM7WUFDNUNELE9BQU9DLElBQUk7UUFDZjtJQUNKO0lBQ0EscURBQXFEO0lBQ3JEZiwrREFBY0EsQ0FBQ2MsT0FBT0gsTUFBTUgsTUFBTSxFQUFFLHFDQUFxQyxRQUFRRTtJQUNqRkcsTUFBTUksSUFBSSxDQUFDWCxlQUFlSyxNQUFNTyxLQUFLLENBQUNKO0lBQ3RDLE9BQU9EO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNELGFBQWFGLElBQUk7SUFDN0IsSUFBSTtRQUNBLE9BQU9SLHFFQUFhQSxDQUFDUTtJQUN6QixFQUNBLE9BQU9TLE9BQU87UUFDVm5CLCtEQUFjQSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRW1CLE1BQU1DLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRVjtJQUN6RTtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxTQUFTVyxZQUFZWCxJQUFJO0lBQzVCLElBQUk7UUFDQSxPQUFRRCxhQUFhQyxNQUFNRixNQUFNLEtBQUs7SUFDMUMsRUFDQSxPQUFPVyxPQUFPLENBQUU7SUFDaEIsT0FBTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRyxTQUFTWixJQUFJO0lBQ3pCViwrREFBY0EsQ0FBQyxPQUFRVSxTQUFVLFVBQVUsa0NBQWtDLFFBQVFBO0lBQ3JGLElBQUlhLFNBQVNwQjtJQUNiLE1BQU1VLFFBQVFKLGFBQWFDO0lBQzNCLE1BQU9HLE1BQU1MLE1BQU0sQ0FBRTtRQUNqQmUsU0FBUzFCLDJEQUFTQSxDQUFDQyx1REFBTUEsQ0FBQztZQUFDeUI7WUFBUTFCLDJEQUFTQSxDQUFFZ0IsTUFBTVcsR0FBRztTQUFLO0lBQ2hFO0lBQ0EsT0FBT3pCLHdEQUFPQSxDQUFDd0I7QUFDbkI7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNFLFVBQVVmLElBQUk7SUFDMUIsT0FBT1gsd0RBQU9BLENBQUNELHVEQUFNQSxDQUFDVyxhQUFhQyxNQUFNZ0IsR0FBRyxDQUFDLENBQUNuQjtRQUMxQyx3REFBd0Q7UUFDeEQsSUFBSUEsS0FBS0MsTUFBTSxHQUFHLElBQUk7WUFDbEIsTUFBTSxJQUFJbUIsTUFBTTtRQUNwQjtRQUNBLE1BQU1oQixRQUFRLElBQUlQLFdBQVdHLEtBQUtDLE1BQU0sR0FBRztRQUMzQ0csTUFBTWlCLEdBQUcsQ0FBQ3JCLE1BQU07UUFDaEJJLEtBQUssQ0FBQyxFQUFFLEdBQUdBLE1BQU1ILE1BQU0sR0FBRztRQUMxQixPQUFPRztJQUNYLE9BQU87QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcz82YzgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBlbnNfbm9ybWFsaXplIH0gZnJvbSBcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIjtcbmNvbnN0IFplcm9zID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuWmVyb3MuZmlsbCgwKTtcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGNvbXApIHtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCAhPT0gMCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJjb21wXCIsIGNvbXApO1xuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgYXNzZXJ0QXJndW1lbnQobGFzdCA8IGJ5dGVzLmxlbmd0aCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBFTlMgJSVuYW1lJSUgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVuc19ub3JtYWxpemUobmFtZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgRU5TIG5hbWUgKCR7ZXJyb3IubWVzc2FnZX0pYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVuYW1lJSUgaXMgYSB2YWxpZCBFTlMgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGVuc05hbWVTcGxpdChuYW1lKS5sZW5ndGggIT09IDApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFtbbGluay1uYW1laGFzaF1dIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgRU5TIG5hbWU7IG5vdCBhIHN0cmluZ1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIGNvbnN0IGNvbXBzID0gZW5zTmFtZVNwbGl0KG5hbWUpO1xuICAgIHdoaWxlIChjb21wcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0ga2VjY2FrMjU2KGNvbmNhdChbcmVzdWx0LCBrZWNjYWsyNTYoKGNvbXBzLnBvcCgpKSldKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBETlMgZW5jb2RlZCAlJW5hbWUlJS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VkIGZvciB2YXJpb3VzIHBhcnRzIG9mIEVOUyBuYW1lIHJlc29sdXRpb24sIHN1Y2hcbiAqICBhcyB0aGUgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRuc0VuY29kZShuYW1lKSB7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KGVuc05hbWVTcGxpdChuYW1lKS5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgLy8gRE5TIGRvZXMgbm90IGFsbG93IGNvbXBvbmVudHMgb3ZlciA2MyBieXRlcyBpbiBsZW5ndGhcbiAgICAgICAgaWYgKGNvbXAubGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRE5TIGVuY29kZWQgZW50cnk7IGxlbmd0aCBleGNlZWRzIDYzIGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY29tcC5sZW5ndGggKyAxKTtcbiAgICAgICAgYnl0ZXMuc2V0KGNvbXAsIDEpO1xuICAgICAgICBieXRlc1swXSA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9KSkpICsgXCIwMFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsImNvbmNhdCIsImhleGxpZnkiLCJhc3NlcnRBcmd1bWVudCIsInRvVXRmOEJ5dGVzIiwiZW5zX25vcm1hbGl6ZSIsIlplcm9zIiwiVWludDhBcnJheSIsImZpbGwiLCJjaGVja0NvbXBvbmVudCIsImNvbXAiLCJsZW5ndGgiLCJlbnNOYW1lU3BsaXQiLCJuYW1lIiwiYnl0ZXMiLCJlbnNOb3JtYWxpemUiLCJjb21wcyIsImxhc3QiLCJpIiwiZCIsInB1c2giLCJzbGljZSIsImVycm9yIiwibWVzc2FnZSIsImlzVmFsaWROYW1lIiwibmFtZWhhc2giLCJyZXN1bHQiLCJwb3AiLCJkbnNFbmNvZGUiLCJtYXAiLCJFcnJvciIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/hash/namehash.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/hash/typed-data.js":
/*!************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder),\n/* harmony export */   verifyTypedData: () => (/* binding */ verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n            return function(_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function(value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */ class TypedDataEncoder {\n    #types;\n    /**\n     *  The types.\n     */ get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */ constructor(types){\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        Object.keys(types).forEach((type)=>{\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        for(const name in types){\n            const uniqueNames = new Set();\n            for (const field of types[name]){\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n)=>parents.get(n).length === 0);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            primaryType: primaryTypes[0]\n        });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            found.add(type);\n            for (const child of links.get(type)){\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found){\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes){\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */ getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value)=>{\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256);\n                }\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(this.#fullTypes.get(type));\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n            };\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */ encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */ encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */ hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */ encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */ hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */ _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n            return value.map((v)=>this._visit(match[1], v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */ visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */ static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */ static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */ static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */ static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */ static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for(const key in domain){\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for(const name in ensCache){\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return {\n            domain,\n            value\n        };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */ static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */ function verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_7__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsMkZBQTJGO0FBQzFDO0FBQ0Y7QUFDVTtBQUNnSDtBQUM1STtBQUM3QixNQUFNZ0IsVUFBVSxJQUFJQyxXQUFXO0FBQy9CRCxRQUFRRSxJQUFJLENBQUM7QUFDYixNQUFNQyxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLGlCQUFpQkgsT0FBTzs7O0FBRzlCLFNBQVNJLFlBQVlDLEtBQUs7SUFDdEIsTUFBTUMsUUFBUXBCLHlEQUFRQSxDQUFDbUI7SUFDdkIsTUFBTUUsWUFBWUQsTUFBTUUsTUFBTSxHQUFHO0lBQ2pDLElBQUlELFdBQVc7UUFDWCxPQUFPeEIsdURBQU1BLENBQUM7WUFBQ3VCO1lBQU9WLFFBQVFhLEtBQUssQ0FBQ0Y7U0FBVztJQUNuRDtJQUNBLE9BQU9wQix3REFBT0EsQ0FBQ21CO0FBQ25CO0FBQ0EsTUFBTUksVUFBVXBCLHdEQUFPQSxDQUFDWSxNQUFNO0FBQzlCLE1BQU1TLFdBQVdyQix3REFBT0EsQ0FBQ1csTUFBTTtBQUMvQixNQUFNVyxtQkFBbUI7SUFDckJDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLG1CQUFtQjtJQUNuQkMsTUFBTTtBQUNWO0FBQ0EsTUFBTUMsbUJBQW1CO0lBQ3JCO0lBQVE7SUFBVztJQUFXO0lBQXFCO0NBQ3REO0FBQ0QsU0FBU0MsWUFBWUMsR0FBRztJQUNwQixPQUFPLFNBQVVmLEtBQUs7UUFDbEJYLCtEQUFjQSxDQUFDLE9BQVFXLFVBQVcsVUFBVSxDQUFDLHlCQUF5QixFQUFFZ0IsS0FBS0MsU0FBUyxDQUFDRixLQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRUEsSUFBSSxDQUFDLEVBQUVmO1FBQ2hILE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1B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QVgsK0RBQWNBLENBQUMsT0FBTyxvQkFBb0IsUUFBUW9DO1lBQ3REO1FBQ0o7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxTQUFTbUYsZ0JBQWdCaEIsTUFBTSxFQUFFdEQsS0FBSyxFQUFFdEMsS0FBSyxFQUFFNkcsU0FBUztJQUMzRCxPQUFPcEkscUVBQWNBLENBQUM0RCxpQkFBaUI4QyxJQUFJLENBQUNTLFFBQVF0RCxPQUFPdEMsUUFBUTZHO0FBQ3ZFLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanM/OTRjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXRCeXRlcywgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIG1hc2ssIHRvQmVIZXgsIHRvUXVhbnRpdHksIHRvVHdvcywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi9pZC5qc1wiO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IEJOX18xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG47XG47XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gdG9CZUhleChCTl8xLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IHRvQmVIZXgoQk5fMCwgMzIpO1xuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcbiAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IFwiYWRkcmVzc1wiLFxuICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG59O1xuY29uc3QgZG9tYWluRmllbGROYW1lcyA9IFtcbiAgICBcIm5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwiY2hhaW5JZFwiLCBcInZlcmlmeWluZ0NvbnRyYWN0XCIsIFwic2FsdFwiXG5dO1xuZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwiZG9tYWluLmNoYWluSWRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IDAsIFwiaW52YWxpZCBjaGFpbiBJRFwiLCBcImRvbWFpbi5jaGFpbklkXCIsIF92YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1F1YW50aXR5KHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJ2ZXJpZnlpbmdDb250cmFjdFwiYCwgXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2FsdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUsIFwiZG9tYWluLnNhbHRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14odT8paW50KFxcZCopJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggJSA4ID09PSAwICYmIHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDI1NiAmJiAobWF0Y2hbMl0gPT0gbnVsbCB8fCBtYXRjaFsyXSA9PT0gU3RyaW5nKHdpZHRoKSksIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gbWFzayhCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/ICgoYm91bmRzVXBwZXIgKyBCTl8xKSAqIEJOX18xKSA6IEJOXzA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSBib3VuZHNMb3dlciAmJiB2YWx1ZSA8PSBib3VuZHNVcHBlciwgYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9CZUhleChzaWduZWQgPyB0b1R3b3ModmFsdWUsIDI1NikgOiB2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBieXRlc1hYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDMyICYmIG1hdGNoWzFdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gd2lkdGgsIGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuLyoqXG4gKiAgQSAqKlR5cGVkRGF0YUVuY29kZSoqIHByZXBhcmVzIGFuZCBlbmNvZGVzIFtbbGluay1laXAtNzEyXV0gcGF5bG9hZHNcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXG4gKlxuICogIFRoaXMgaXMgdXNlZnVsIGZvciB0aG9zZSB0aGF0IHdpc2ggdG8gY29tcHV0ZSB2YXJpb3VzIGNvbXBvbmVudHMgb2YgYVxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXG4gKiAgaGlnaGVyIGxldmVsIFtbU2lnbmVyLXNpZ25UeXBlZERhdGFdXSBpcyBtb3JlIHVzZWZ1bC5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpbWFyeSB0eXBlIGZvciB0aGUgc3RydWN0dXJlZCBbW3R5cGVzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBkZXJpdmVkIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgW1t0eXBlc11dLCBzaW5jZSBub1xuICAgICAqICByZWN1cnNpb24gaXMgcG9zc2libGUsIG9uY2UgdGhlIERBRyBmb3IgdGhlIHR5cGVzIGlzIGNvbnN0dXJjdGVkXG4gICAgICogIGludGVybmFsbHksIHRoZSBwcmltYXJ5IHR5cGUgbXVzdCBiZSB0aGUgb25seSByZW1haW5pbmcgdHlwZSB3aXRoXG4gICAgICogIG5vIHBhcmVudCBub2Rlcy5cbiAgICAgKi9cbiAgICBwcmltYXJ5VHlwZTtcbiAgICAjdHlwZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuI3R5cGVzKTtcbiAgICB9XG4gICAgI2Z1bGxUeXBlcztcbiAgICAjZW5jb2RlckNhY2hlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHBlcmZvcm1zIGFsbCBuZWNlc3NhcnkgY2hlY2tpbmcgdGhhdCB0eXBlcyBhcmUgdmFsaWQgYW5kXG4gICAgICogIGRvIG5vdCB2aW9sYXRlIHRoZSBbW2xpbmstZWlwLTcxMl1dIHN0cnVjdHVyYWwgY29uc3RyYWludHMgYXNcbiAgICAgKiAgd2VsbCBhcyBjb21wdXRlcyB0aGUgW1twcmltYXJ5VHlwZV1dLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGVzKSB7XG4gICAgICAgIHRoaXMuI3R5cGVzID0gSlNPTi5zdHJpbmdpZnkodHlwZXMpO1xuICAgICAgICB0aGlzLiNmdWxsVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcbiAgICAgICAgY29uc3QgbGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0cyB0byBzdHJ1Y3RzIHdoaWNoIGNvbnRhaW4gdGhlbSBhcyBhIGNoaWxkXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxpbmtzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgc3VidHlwZXMuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghdW5pcXVlTmFtZXMuaGFzKGZpZWxkLm5hbWUpLCBgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSAoZmllbGQudHlwZS5tYXRjaCgvXihbXlxceDViXSopKFxceDVifCQpLykpWzFdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYmFzZVR5cGUgIT09IG5hbWUsIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KGJhc2VUeXBlKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzLmdldChuYW1lKS5hZGQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoICE9PSAwLCBcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAxLCBgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZXNbMF0gfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZvdW5kLmhhcyh0eXBlKSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodHlwZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpbmtzLmdldCh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50cy5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ0eXBlIG9mIGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzLmdldChzdWJ0eXBlKS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHNldF0gb2Ygc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuZnJvbShzZXQpO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy4jZnVsbFR5cGVzLnNldChuYW1lLCBlbmNvZGVUeXBlKG5hbWUsIHR5cGVzW25hbWVdKSArIHN0Lm1hcCgodCkgPT4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSkpLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm50aGUgZW5jb2RlciBmb3IgdGhlIHNwZWNpZmljICUldHlwZSUlLlxuICAgICAqL1xuICAgIGdldEVuY29kZXIodHlwZSkge1xuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuI2VuY29kZXJDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuI2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUuc2V0KHR5cGUsIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH1cbiAgICAjZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3ViRW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghbWF0Y2hbM10gfHwgcGFyc2VJbnQobWF0Y2hbM10pID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke3BhcnNlSW50KG1hdGNoWzNdKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHN1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoa2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVHlwZSA9IGlkKHRoaXMuI2Z1bGxUeXBlcy5nZXQodHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbCB0eXBlIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVsbFR5cGVzLmdldChuYW1lKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgaGFzaCBvZiAlJXZhbHVlJSUgZm9yIHRoZSB0eXBlIG9mICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbGVkIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFtYXRjaFszXSB8fCBwYXJzZUludChtYXRjaFszXSkgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7cGFyc2VJbnQobWF0Y2hbM10pfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQobWF0Y2hbMV0sIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXG4gICAgICogIGNvbXBvbmVudCB3aXRoaW4gJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcbiAgICAgKiAgbWF5IGJlIGRlc2lyZWQgb24gZWFjaCBjb21wb25lbnQsIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgICAqL1xuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHByaW1hcnkgdHlwZSBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaGVkIHN0cnVjdCBmb3IgJSV2YWx1ZSUlIHVzaW5nICUldHlwZXMlJSBhbmQgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkb21haW4gaGFzaCBmb3IgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlLCBgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXG4gICAgICogJSV0eXBlcyUlIGFuZCB0aGUgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgZG9tYWluKTtcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSBhd2FpdCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxuICAgICAqICB0aGUgSlNPTi1SUEMgW1tsaW5rLWVpcC03MTJdXSBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoZ2V0Qnl0ZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIENvbXB1dGUgdGhlIGFkZHJlc3MgdXNlZCB0byBzaWduIHRoZSB0eXBlZCBkYXRhIGZvciB0aGUgJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwicmVjb3ZlckFkZHJlc3MiLCJjb25jYXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJtYXNrIiwidG9CZUhleCIsInRvUXVhbnRpdHkiLCJ0b1R3b3MiLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImlkIiwicGFkZGluZyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiQk5fXzEiLCJCaWdJbnQiLCJCTl8wIiwiQk5fMSIsIkJOX01BWF9VSU5UMjU2IiwiaGV4UGFkUmlnaHQiLCJ2YWx1ZSIsImJ5dGVzIiwicGFkT2Zmc2V0IiwibGVuZ3RoIiwic2xpY2UiLCJoZXhUcnVlIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsInZlcnNpb24iLCJjaGFpbklkIiwidmVyaWZ5aW5nQ29udHJhY3QiLCJzYWx0IiwiZG9tYWluRmllbGROYW1lcyIsImNoZWNrU3RyaW5nIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRvbWFpbkNoZWNrcyIsIl92YWx1ZSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJ0b0xvd2VyQ2FzZSIsImVycm9yIiwiZ2V0QmFzZUVuY29kZXIiLCJ0eXBlIiwibWF0Y2giLCJzaWduZWQiLCJ3aWR0aCIsInBhcnNlSW50IiwiU3RyaW5nIiwiYm91bmRzVXBwZXIiLCJib3VuZHNMb3dlciIsImVuY29kZVR5cGUiLCJmaWVsZHMiLCJtYXAiLCJqb2luIiwiVHlwZWREYXRhRW5jb2RlciIsInR5cGVzIiwicGFyc2UiLCJmdWxsVHlwZXMiLCJlbmNvZGVyQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzZXQiLCJTZXQiLCJ1bmlxdWVOYW1lcyIsImZpZWxkIiwiaGFzIiwiYWRkIiwiYmFzZVR5cGUiLCJlbmNvZGVyIiwiZ2V0IiwicHVzaCIsInByaW1hcnlUeXBlcyIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIm4iLCJ0IiwicHJpbWFyeVR5cGUiLCJjaGVja0NpcmN1bGFyIiwiZm91bmQiLCJjaGlsZCIsInN1YnR5cGUiLCJkZWxldGUiLCJzdCIsInNvcnQiLCJnZXRFbmNvZGVyIiwic3ViRW5jb2RlciIsInJlc3VsdCIsImVuY29kZWRUeXBlIiwidmFsdWVzIiwidW5zaGlmdCIsImVuY29kZURhdGEiLCJoYXNoU3RydWN0IiwiZW5jb2RlIiwiaGFzaCIsIl92aXNpdCIsImNhbGxiYWNrIiwidiIsInJlZHVjZSIsImFjY3VtIiwidmlzaXQiLCJnZXRQcmltYXJ5VHlwZSIsImhhc2hEb21haW4iLCJkb21haW4iLCJkb21haW5GaWVsZHMiLCJhIiwiYiIsImluZGV4T2YiLCJFSVA3MTJEb21haW4iLCJyZXNvbHZlTmFtZXMiLCJyZXNvbHZlTmFtZSIsImFzc2lnbiIsImVuc0NhY2hlIiwiZ2V0UGF5bG9hZCIsImRvbWFpblZhbHVlcyIsImRvbWFpblR5cGVzIiwidHlwZXNXaXRoRG9tYWluIiwibWVzc2FnZSIsInRvU3RyaW5nIiwidmVyaWZ5VHlwZWREYXRhIiwic2lnbmF0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/hash/typed-data.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!************************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* binding */ AbstractProvider),\n/* harmony export */   UnmanagedSubscriber: () => (/* binding */ UnmanagedSubscriber)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../contract/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ens-resolver.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./network.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */ // @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v)=>{\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof v === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof v === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key)=>{\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */ class UnmanagedSubscriber {\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    start() {}\n    stop() {}\n    pause(dropWhilePaused) {}\n    resume() {}\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from(new Set(items).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = {\n            topics: _event\n        };\n    }\n    if (typeof _event === \"string\") {\n        switch(_event){\n            case \"block\":\n            case \"pending\":\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                {\n                    return {\n                        type: _event,\n                        tag: _event\n                    };\n                }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n                hash\n            }),\n            hash\n        };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n        };\n    }\n    if (_event.address || _event.topics) {\n        const event = _event;\n        const filter = {\n            topics: (event.topics || []).map((t)=>{\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t)=>t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            })\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr)=>{\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async ()=>{\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a)=>a.toLowerCase()));\n        }\n        return {\n            filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n        };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */ class AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */ constructor(_network, options){\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_4__.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(()=>{\n                this.emit(\"network\", network, null);\n            }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() {\n        return this.#options.pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */ get provider() {\n        return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */ get disableCcipRead() {\n        return this.#disableCcipRead;\n    }\n    set disableCcipRead(value) {\n        this.#disableCcipRead = !!value;\n    }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(()=>{\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */ async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for(let i = 0; i < urls.length; i++){\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                    data,\n                    sender\n                };\n            }\n            this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request,\n                index: i,\n                urls\n            });\n            let errorMessage = \"unknown error\";\n            const resp = await request.send();\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadFetchResult\",\n                        request,\n                        result\n                    });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result\n                });\n            } catch (error) {}\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                    url,\n                    errorMessage\n                }\n            });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx,\n            info: {\n                urls,\n                errorMessages\n            }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */ _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */ _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */ _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */ _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */ _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */ async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#perform({\n            method: \"getBlockNumber\"\n        }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */ _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */ _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n        }\n        if (typeof blockTag === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof blockTag === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b)=>(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */ _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t)=>{\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t)=>t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock)=>{\n            let address = undefined;\n            switch(_address.length){\n                case 0:\n                    break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address){\n                    address.push(this._getAddress(addr));\n                }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a)=>typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n            return Promise.all([\n                Promise.all(address),\n                fromBlock,\n                toBlock\n            ]).then((result)=>{\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resovles to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */ _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(_request);\n        const promises = [];\n        [\n            \"to\",\n            \"from\"\n        ].forEach((key)=>{\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(request[key]);\n            if (isPromise(addr)) {\n                promises.push(async function() {\n                    request[key] = await addr;\n                }());\n            } else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push(async function() {\n                    request.blockTag = await blockTag;\n                }());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return async function() {\n                await Promise.all(promises);\n                return request;\n            }();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = this._detectNetwork().then((network)=>{\n                this.emit(\"network\", network, null);\n                return network;\n            }, (error)=>{\n                // Reset the networkPromise on failure, so we will try again\n                if (this.#networkPromise === detectNetwork) {\n                    this.#networkPromise = null;\n                }\n                throw error;\n            });\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async ()=>{\n            const { _block, gasPrice } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: (async ()=>{\n                    try {\n                        const gasPrice = await this.#perform({\n                            method: \"getGasPrice\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(gasPrice, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })()\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = BigInt(\"1000000000\");\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#perform({\n            method: \"estimateGas\",\n            transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n                blockTag,\n                enableCcipRead: true\n            })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(tx);\n        try {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this._perform({\n                method: \"call\",\n                transaction,\n                blockTag\n            }));\n        } catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 4));\n                } catch (error) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\",\n                        transaction,\n                        info: {\n                            data\n                        }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\",\n                    transaction,\n                    info: {\n                        data: error.data,\n                        errorArgs: ccipArgs.errorArgs\n                    }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n                        ccipArgs.selector,\n                        encodeBytes([\n                            ccipResult,\n                            ccipArgs.extraData\n                        ])\n                    ])\n                };\n                this.emit(\"debug\", {\n                    action: \"sendCcipReadCall\",\n                    transaction: tx\n                });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallResult\",\n                        transaction: Object.assign({}, tx),\n                        result\n                    });\n                    return result;\n                } catch (error) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallError\",\n                        transaction: Object.assign({}, tx),\n                        error\n                    });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n            [address, blockTag] = await Promise.all([\n                address,\n                blockTag\n            ]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, {\n            address,\n            blockTag\n        })));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#getAccountValue({\n            method: \"getBalance\"\n        }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#getAccountValue({\n            method: \"getTransactionCount\"\n        }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getCode\"\n        }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getStorage\",\n            position\n        }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\",\n                blockHash: block,\n                includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof blockTag !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\",\n            blockTag,\n            includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransaction\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransactionReceipt\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({\n                method: \"getTransaction\",\n                hash\n            });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({\n                method: \"getTransactionResult\",\n                hash\n            })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getLogs\",\n                filter\n            })\n        });\n        return params.map((p)=>this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_11__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_12__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_14__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = _confirms != null ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject)=>{\n            let timer = null;\n            const listener = async (blockNumber)=>{\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            };\n            if (timeout != null) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"timeout\", \"TIMEOUT\", {\n                        reason: \"timeout\"\n                    }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */ _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */ _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = ()=>{\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, {\n                timer: null,\n                func,\n                time: timeout\n            });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, {\n                timer,\n                func,\n                time: getTime()\n            });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */ _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()){\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                {\n                    const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockSubscriber(this);\n                    subscriber.pollingInterval = this.pollingInterval;\n                    return subscriber;\n                }\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */ _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()){\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({\n                orphan: \"drop-log\",\n                log: emitArgs[0]\n            }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = {\n                subscriber,\n                tag,\n                addressableMap,\n                nameMap,\n                started: false,\n                listeners: []\n            };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once })=>{\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.EventPayload(this, once ? null : listener, event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch (error) {}\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return count > 0;\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        } else {\n            for (const [tag, { started, subscriber }] of this.#subs){\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */ get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */ destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()){\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */ get paused() {\n        return this.#pausedState != null;\n    }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */ pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s)=>s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()){\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */ resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s)=>s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()){\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.toUtf8String)(bytes);\n        }\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset + 32, offset + 32 + length);\n    } catch (error) {}\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(empty);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\",\n        urls: [],\n        calldata: \"\",\n        selector: \"\",\n        extraData: \"\",\n        errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset + 32);\n        for(let u = 0; u < urlsLength; u++){\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k)=>result[k]);\n    return result;\n} //# sourceMappingURL=abstract-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNELFFBQVE7QUFDUixvQkFBb0I7QUFDcEIsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSw2RUFBNkU7QUFDN0UsNkVBQTZFO0FBQzdFLDJFQUEyRTtBQUNWO0FBQ2I7QUFDSjtBQUNKO0FBQ1U7QUFDcU87QUFDM087QUFDMEQ7QUFDbkU7QUFDbUU7QUFDc0M7QUFDaEosWUFBWTtBQUNaLE1BQU0wQyxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLHFCQUFxQjtBQUMzQixTQUFTQyxVQUFVQyxLQUFLO0lBQ3BCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUMsSUFBSSxLQUFNO0FBQzdDO0FBQ0EsU0FBU0MsT0FBT0MsTUFBTSxFQUFFSCxLQUFLO0lBQ3pCLE9BQU9HLFNBQVMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDTCxPQUFPLENBQUNNLEdBQUdDO1FBQzVDLElBQUlBLEtBQUssTUFBTTtZQUNYLE9BQU87UUFDWDtRQUNBLElBQUksT0FBUUEsTUFBTyxVQUFVO1lBQ3pCLE9BQU8sQ0FBQyxPQUFPLEVBQUVBLEVBQUVDLFFBQVEsR0FBRyxDQUFDO1FBQ25DO1FBQ0EsSUFBSSxPQUFRRCxNQUFPLFVBQVU7WUFDekIsT0FBT0EsRUFBRUUsV0FBVztRQUN4QjtRQUNBLG1CQUFtQjtRQUNuQixJQUFJLE9BQVFGLE1BQU8sWUFBWSxDQUFDRyxNQUFNQyxPQUFPLENBQUNKLElBQUk7WUFDOUMsTUFBTUssT0FBT0MsT0FBT0QsSUFBSSxDQUFDTDtZQUN6QkssS0FBS0UsSUFBSTtZQUNULE9BQU9GLEtBQUtHLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztnQkFDdkJELEtBQUssQ0FBQ0MsSUFBSSxHQUFHVixDQUFDLENBQUNVLElBQUk7Z0JBQ25CLE9BQU9EO1lBQ1gsR0FB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QUFPO1FBQ1ZsSix1REFBTUEsQ0FBQyxPQUFPLG9DQUFvQyxrQkFBa0I7WUFDaEVvSixRQUFRO1FBQ1o7SUFDSjtJQUNBTCxPQUFPMkQsU0FBUyxHQUFHLDBDQUEwQzZHLEtBQUssQ0FBQyxLQUFLN08sR0FBRyxDQUFDLENBQUN2QyxJQUFNNEcsTUFBTSxDQUFDNUcsRUFBRTtJQUM1RixPQUFPNEc7QUFDWCxFQUNBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzPzMyNDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCB0b0JlQXJyYXksIHRvUXVhbnRpdHksIGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCwgcmVzb2x2ZVByb3BlcnRpZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUmVzb2x2ZXIgfSBmcm9tIFwiLi9lbnMtcmVzb2x2ZXIuanNcIjtcbmltcG9ydCB7IGZvcm1hdEJsb2NrLCBmb3JtYXRMb2csIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCwgZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciwgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciwgUG9sbGluZ09ycGhhblN1YnNjcmliZXIsIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG4vKipcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogIGFueSBhZGRpdGlvbmFsIG1hbmFnZW1lbnQsIHN1Y2ggYXMgYGBcImRlYnVnXCJgYCB3aGljaCBvbmx5IHJlcXVpcmVzXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVubWFuYWdlZFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBmb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyIHdpdGggJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkgeyBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTsgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgc3RvcCgpIHsgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG59XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBfZXZlbnQsIHRhZzogX2V2ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKF9ldmVudCwgMzIpKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBfZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFuc2FjdGlvblwiLCB0YWc6IGdldFRhZyhcInR4XCIsIHsgaGFzaCB9KSwgaGFzaCB9O1xuICAgIH1cbiAgICBpZiAoX2V2ZW50Lm9ycGhhbikge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgLy8gQFRPRE86IFNob3VsZCBsb3dlcmNhc2UgYW5kIHdoYXRub3QgdGhpbmdzIGhlcmUgaW5zdGVhZCBvZiBjb3B5Li4uXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3JwaGFuXCIsIHRhZzogZ2V0VGFnKFwib3JwaGFuXCIsIGV2ZW50KSwgZmlsdGVyOiBjb3B5KGV2ZW50KSB9O1xuICAgIH1cbiAgICBpZiAoKF9ldmVudC5hZGRyZXNzIHx8IF9ldmVudC50b3BpY3MpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICB0b3BpY3M6ICgoZXZlbnQudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkQWRkcmVzcyA9IChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYWRkcmVzcy5mb3JFYWNoKGFkZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQWRkcmVzcyhldmVudC5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGNvbmNpc2lmeShhZGRyZXNzZXMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWx0ZXIsIHRhZzogZ2V0VGFnKFwiZXZlbnRcIiwgZmlsdGVyKSwgdHlwZTogXCJldmVudFwiIH07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gUHJvdmlkZXJFdmVudFwiLCBcImV2ZW50XCIsIF9ldmVudCk7XG59XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFByb3ZpZGVyKiogcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBzdWItY2xhc3NlcyB0b1xuICogIGltcGxlbWVudCB0aGUgW1tQcm92aWRlcl1dIEFQSSBieSBub3JtYWxpemluZyBpbnB1dCBhcmd1bWVudHMgYW5kXG4gKiAgZm9ybWF0dGluZyBvdXRwdXQgcmVzdWx0cyBhcyB3ZWxsIGFzIHRyYWNraW5nIGV2ZW50cyBmb3IgY29uc2lzdGVudFxuICogIGJlaGF2aW91ciBvbiBhbiBldmVudHVhbGx5LWNvbnNpc3RlbnQgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNzdWJzO1xuICAgICNwbHVnaW5zO1xuICAgIC8vIG51bGw9dW5wYXVzZWQsIHRydWU9cGF1c2VkK2Ryb3BXaGlsZVBhdXNlZCwgZmFsc2U9cGF1c2VkXG4gICAgI3BhdXNlZFN0YXRlO1xuICAgICNkZXN0cm95ZWQ7XG4gICAgI25ldHdvcmtQcm9taXNlO1xuICAgICNhbnlOZXR3b3JrO1xuICAgICNwZXJmb3JtQ2FjaGU7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIG51bWJlciBpZiBydW5uaW5nIGFuIGV2ZW50IG9yIC0xIGlmIG5vIFwiYmxvY2tcIiBldmVudFxuICAgICNsYXN0QmxvY2tOdW1iZXI7XG4gICAgI25leHRUaW1lcjtcbiAgICAjdGltZXJzO1xuICAgICNkaXNhYmxlQ2NpcFJlYWQ7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFic3RyYWN0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUsIG9yXG4gICAgICogIHVzZSB0aGUgdmFyaW91cyBuZXR3b3JrIGRldGVjdGlvbiBjYXBhYmlsaXRpZXMgdG8gZGlzY292ZXIgdGhlXG4gICAgICogIFtbTmV0d29ya11dIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAoX25ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9uZXR3b3JrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldHdvcmspO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25leHRUaW1lciA9IDE7XG4gICAgICAgIHRoaXMuI3RpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNvcHRpb25zLnBvbGxpbmdJbnRlcnZhbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdGhpc2BgLCB0byBhbGxvdyBhbiAqKkFic3RyYWN0UHJvdmlkZXIqKiB0byBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIFtbQ29udHJhY3RSdW5uZXJdXSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZ2V0IHByb3ZpZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBwbHVnLWlucy5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgcGx1Zy1pbi5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNvbm5lY3QodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCBhIHBsdWdpbiBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcmV2ZW50IGFueSBDQ0lQLXJlYWQgb3BlcmF0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgcmVxdWVzdGVkXG4gICAgICogIGluIGEgW1tjYWxsXV0gdXNpbmcgYGBlbmFibGVDY2lwUmVhZGBgLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlQ2NpcFJlYWQoKSB7IHJldHVybiB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQ7IH1cbiAgICBzZXQgZGlzYWJsZUNjaXBSZWFkKHZhbHVlKSB7IHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9ICEhdmFsdWU7IH1cbiAgICAvLyBTaGFyZXMgbXVsdGlwbGUgaWRlbnRpY2FsIHJlcXVlc3RzIG1hZGUgZHVyaW5nIHRoZSBzYW1lIDI1MG1zXG4gICAgYXN5bmMgI3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLiNvcHRpb25zLmNhY2hlVGltZW91dDtcbiAgICAgICAgLy8gQ2FjaGluZyBkaXNhYmxlZFxuICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGFnXG4gICAgICAgIGNvbnN0IHRhZyA9IGdldFRhZyhyZXEubWV0aG9kLCByZXEpO1xuICAgICAgICBsZXQgcGVyZm9ybSA9IHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFwZXJmb3JtKSB7XG4gICAgICAgICAgICBwZXJmb3JtID0gdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLnNldCh0YWcsIHBlcmZvcm0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKSA9PT0gcGVyZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGF0YSBmb3IgZXhlY3V0aW5nIHRoZSBDQ0lQLXJlYWQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDAgfHwgdHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAvL2NvbnN0IGpzb246IHN0cmluZyB8IG51bGwgPSAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPj0gMCkgPyBudWxsOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIC8vY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoaHJlZik7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0geyBkYXRhLCBzZW5kZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZEZldGNoUmVxdWVzdFwiLCByZXF1ZXN0LCBpbmRleDogaSwgdXJscyB9KTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcInVua25vd24gZXJyb3JcIjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcC5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hSZXN1bHRcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXG4gICAgICAgICAgICBhc3NlcnQocmVzcC5zdGF0dXNDb2RlIDwgNDAwIHx8IHJlc3Auc3RhdHVzQ29kZSA+PSA1MDAsIGByZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwgeyByZWFzb246IFwiNDA0X01JU1NJTkdfUkVTT1VSQ0VcIiwgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybCwgZXJyb3JNZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiNTAwX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybHMsIGVycm9yTWVzc2FnZXMgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGJsb2NrIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgX3dyYXBCbG9jayh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrKGZvcm1hdEJsb2NrKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBsb2cgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbTG9nXV0uXG4gICAgICovXG4gICAgX3dyYXBMb2codmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2coZm9ybWF0TG9nKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZWNlaXB0IGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZWNlaXB0KGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UoZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIE5ldHdvcmssIGZvcmNpbmcgYSBuZXR3b3JrIGRldGVjdGlvbiB1c2luZyB3aGF0ZXZlclxuICAgICAqICB0ZWNobmlxdWUgdGhlIHN1Yi1jbGFzcyByZXF1aXJlcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwic3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2RldGVjdE5ldHdvcmtcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIHNob3VsZCB1c2UgdGhpcyB0byBwZXJmb3JtIGFsbCBidWlsdC1pbiBvcGVyYXRpb25zLiBBbGxcbiAgICAgKiAgbWV0aG9kcyBzYW5pdGl6ZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIHZhbHVlcyBwYXNzZWQgaW50byB0aGlzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIG1ldGhvZDogJHtyZXEubWV0aG9kfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGluZm86IHJlcVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3RhdGVcbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBnZXROdW1iZXIoYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRCbG9ja051bWJlclwiIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJSwgcmVzb2x2aW5nIEVOU1xuICAgICAqICBuYW1lcyBhbmQgW1tBZGRyZXNzYWJsZV1dIG9iamVjdHMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGFuXG4gICAgICogIGFkZHJlc3MuXG4gICAgICovXG4gICAgX2dldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3MoYWRkcmVzcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdmFsaWQgYmxvY2sgdGFnIGZvciAlJWJsb2NrVGFnJSUsIHJlc29sdmluZ1xuICAgICAqICBuZWdhdGl2ZSB2YWx1ZXMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWQgYmxvY2sgdGFnLlxuICAgICAqL1xuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGdldE51bWJlcihibG9ja1RhZywgXCJibG9ja1RhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RhZyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodGhpcy4jbGFzdEJsb2NrTnVtYmVyICsgYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChiKSA9PiB0b1F1YW50aXR5KGIgKyBibG9ja1RhZykpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgYmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgZmlsdGVyIGZvciAlJWZpbHRlciUlLCByZXNvbHZpbmcgYW55IEVOU1xuICAgICAqICBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0IGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIGZpbHRlci5cbiAgICAgKi9cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICAvLyBDcmVhdGUgYSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRvcGljc1xuICAgICAgICBjb25zdCB0b3BpY3MgPSAoZmlsdGVyLnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IChcImJsb2NrSGFzaFwiIGluIGZpbHRlcikgPyBmaWx0ZXIuYmxvY2tIYXNoIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKF9hZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3dpdGNoIChfYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfYWRkcmVzcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUJsb2NrICE9IG51bGwgfHwgdG9CbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmlsdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGZyb21CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSB0b0Jsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGRyZXNzZXMgY291bGQgYmUgYXN5bmMgKEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXMpXG4gICAgICAgIGxldCBhZGRyZXNzID0gW107XG4gICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGFkZHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcImZyb21CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcInRvQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIudG9CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3MuZmlsdGVyKChhKSA9PiAodHlwZW9mIChhKSAhPT0gXCJzdHJpbmdcIikpLmxlbmd0aCB8fFxuICAgICAgICAgICAgKGZyb21CbG9jayAhPSBudWxsICYmIHR5cGVvZiAoZnJvbUJsb2NrKSAhPT0gXCJzdHJpbmdcIikgfHxcbiAgICAgICAgICAgICh0b0Jsb2NrICE9IG51bGwgJiYgdHlwZW9mICh0b0Jsb2NrKSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoYWRkcmVzcyksIGZyb21CbG9jaywgdG9CbG9ja10pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb3ZsZXMgdG8gYSB0cmFuc2FjdGlvbiBmb3IgJSVyZXF1ZXN0JSUsIHJlc29sdmluZ1xuICAgICAqICBhbnkgRU5TIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF9yZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjb3B5UmVxdWVzdChfcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIFtcInRvXCIsIFwiZnJvbVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSByZXNvbHZlQWRkcmVzcyhyZXF1ZXN0W2tleV0pO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdFtrZXldID0gYXdhaXQgYWRkcjsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0W2tleV0gPSBhZGRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhyZXF1ZXN0LmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0LmJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja1RhZyA9IGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IG5ldHdvcmsgd2FzIHNldCBhbmQgdGhpcyBpcyBvdXIgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IHRoZSBjdXJyZW50IG5ldHdvcmsgKHNoYXJlZCB3aXRoIGFsbCBjYWxscylcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdE5ldHdvcmsgPSB0aGlzLl9kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgbmV0d29ya1Byb21pc2Ugb24gZmFpbHVyZSwgc28gd2Ugd2lsbCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IGRldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBkZXRlY3ROZXR3b3JrO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBkZXRlY3ROZXR3b3JrKS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlID0gdGhpcy4jbmV0d29ya1Byb21pc2U7XG4gICAgICAgIGNvbnN0IFtleHBlY3RlZCwgYWN0dWFsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG5ldHdvcmtQcm9taXNlLFxuICAgICAgICAgICAgdGhpcy5fZGV0ZWN0TmV0d29yaygpIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIG5ldHdvcmtcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChleHBlY3RlZC5jaGFpbklkICE9PSBhY3R1YWwuY2hhaW5JZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJhbnlcIiBuZXR3b3JrIGNhbiBjaGFuZ2UsIHNvIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmV0d29yayBpZiBzb21ldGhpbmcgZWxzZSBoYXNuJ3QgYWxyZWFkeSBjaGFuZ2VkIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBuZXR3b3JrUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGFsbG93IGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2Jsb2NrLCBnYXNQcmljZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludChnYXNQcmljZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSByZWNvbW1lbmRlZCBFSVAtMTU1OSBoZXVyaXN0aWNzIGZvciBmZWUgZGF0YVxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl93cmFwQmxvY2soX2Jsb2NrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBCaWdJbnQoXCIxMDAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IChibG9jay5iYXNlRmVlUGVyR2FzICogQk5fMikgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENoZWNrIGZvciBhIEZlZURhdGFOZXRXb3JrUGx1Z2luXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KHBsdWdpbi51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShmZWVEYXRhLmdhc1ByaWNlLCBmZWVEYXRhLm1heEZlZVBlckdhcywgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEZlZURhdGFGdW5jKCk7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKF90eCkge1xuICAgICAgICBsZXQgdHggPSB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh0eCkpIHtcbiAgICAgICAgICAgIHR4ID0gYXdhaXQgdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLCB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyAjY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgYXNzZXJ0KGF0dGVtcHQgPCBNQVhfQ0NJUF9SRURJUkVDVFMsIFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIlRPT19NQU5ZX1JFRElSRUNUU1wiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IGJsb2NrVGFnLCBlbmFibGVDY2lwUmVhZDogdHJ1ZSB9KVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBjYW1lIGluIGFzIGEgUGVyZm9ybUFjdGlvblRyYW5zYWN0aW9uLCBzbyB0by9mcm9tIGFyZSBzYWZlOyB3ZSBjYW4gY2FzdFxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUNjaXBSZWFkICYmIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSAmJiBhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHJhbnNhY3Rpb24udG8gIT0gbnVsbCAmJiBkYXRhU2xpY2UoZXJyb3IuZGF0YSwgMCwgNCkgPT09IFwiMHg1NTZmMTgzMFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0cmFuc2FjdGlvbi50bywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIENDSVAgUmVhZCBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2NpcEFyZ3MgPSBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGFTbGljZShlcnJvci5kYXRhLCA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkJBRF9EQVRBXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGEgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlbmRlciBvZiB0aGUgT2ZmY2hhaW5Mb29rdXAgbWF0Y2hlcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcFJlc3VsdCAhPSBudWxsLCBcIkNDSVAgUmVhZCBmYWlsZWQgdG8gZmV0Y2ggZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkZFVENIX0ZBSUxFRFwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhOiBlcnJvci5kYXRhLCBlcnJvckFyZ3M6IGNjaXBBcmdzLmVycm9yQXJncyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29uY2F0KFtjY2lwQXJncy5zZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGNjaXBBcmdzLmV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZENhbGxcIiwgdHJhbnNhY3Rpb246IHR4IH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxSZXN1bHRcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbEVycm9yXCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjY2hlY2tOZXR3b3JrKHByb21pc2UpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICB2YWx1ZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKF90eCkge1xuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKF90eC5ibG9ja1RhZylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIF90eC5lbmFibGVDY2lwUmVhZCA/IDAgOiAtMSkpO1xuICAgIH1cbiAgICAvLyBBY2NvdW50XG4gICAgYXN5bmMgI2dldEFjY291bnRWYWx1ZShyZXF1ZXN0LCBfYWRkcmVzcywgX2Jsb2NrVGFnKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKF9ibG9ja1RhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBbYWRkcmVzcywgYmxvY2tUYWddID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FkZHJlc3MsIGJsb2NrVGFnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNwZXJmb3JtKE9iamVjdC5hc3NpZ24ocmVxdWVzdCwgeyBhZGRyZXNzLCBibG9ja1RhZyB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldEJhbGFuY2VcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXROdW1iZXIoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRDb2RlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3RvcmFnZShhZGRyZXNzLCBfcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0QmlnSW50KF9wb3NpdGlvbiwgXCJwb3NpdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgLy8gV3JpdGVcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5fcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFR4XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE86IHRoZSByZXR1cm5lZCBoYXNoIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tIYXNoOiBibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2spO1xuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0QmxvY2soYmxvY2ssIHByZWZldGNoVHhzKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jZ2V0QmxvY2soYmxvY2ssICEhcHJlZmV0Y2hUeHMpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwQmxvY2socGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgYmFja2VuZHMgZGlkIG5vdCBiYWNrZmlsbCB0aGUgZWZmZWN0aXZlR2FzUHJpY2UgaW50byBvbGQgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIGluIHRoZSByZWNlaXB0LCBzbyB3ZSBsb29rIGl0IHVwIG1hbnVhbGx5IGFuZCBpbmplY3QgaXQuXG4gICAgICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgPT0gbnVsbCAmJiBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSk7XG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcG9ydCB0aGlzOyBjb3VsZCBub3QgZmluZCB0eCBvciBlZmZlY3RpdmVHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVzdWx0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQmxvb20tZmlsdGVyIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShmaWx0ZXIpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldExvZ3NcIiwgZmlsdGVyIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5fd3JhcExvZyhwLCBuZXR3b3JrKSk7XG4gICAgfVxuICAgIC8vIEVOU1xuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJwcm92aWRlciBjYW5ub3QgY29ubmVjdCB0byB0YXJnZXQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2dldFByb3ZpZGVyKClcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgRW5zUmVzb2x2ZXIuZnJvbU5hbWUodGhpcywgbmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEF2YXRhcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHJlc29sdmVyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBuYW1lKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCByZXNvbHZlckNvbnRyYWN0Lm5hbWUobm9kZSk7XG4gICAgICAgICAgICAvLyBGYWlsZWQgZm9yd2FyZCByZXNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IGF3YWl0IHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpICYmIGVycm9yLnZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyByZWVydGVkXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zICE9IG51bGwpID8gX2NvbmZpcm1zIDogMTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChhc3luYyAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIoYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JCbG9jayhibG9ja1RhZykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwibm90IGltcGxlbWVudGVkIHlldFwiLCBcIk5PVF9JTVBMRU1FTlRFRFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwid2FpdEZvckJsb2NrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhIHRpbWVyIGNyZWF0ZWQgdXNpbmcgdGhlIFtbX3NldFRpbWVvdXRdXSBtZXRob2QuXG4gICAgICovXG4gICAgX2NsZWFyVGltZW91dCh0aW1lcklkKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy4jdGltZXJzLmdldCh0aW1lcklkKTtcbiAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgdGltZXIgdGhhdCB3aWxsIGV4ZWN1dGUgJSVmdW5jJSUgYWZ0ZXIgYXQgbGVhc3QgJSV0aW1lb3V0JSVcbiAgICAgKiAgKGluIG1zKS4gSWYgJSV0aW1lb3V0JSUgaXMgdW5zcGVjaWZpZWQsIHRoZW4gJSVmdW5jJSUgd2lsbCBleGVjdXRlXG4gICAgICogIGluIHRoZSBuZXh0IGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiAgW1BhdXNpbmddKEFic3RyYWN0UHJvdmlkZXItcGF1c2VkKSB0aGUgcHJvdmlkZXIgd2lsbCBwYXVzZSBhbnlcbiAgICAgKiAgYXNzb2NpYXRlZCB0aW1lcnMuXG4gICAgICovXG4gICAgX3NldFRpbWVvdXQoX2Z1bmMsIHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXJJZCA9IHRoaXMuI25leHRUaW1lcisrO1xuICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICAgICAgICAgIF9mdW5jKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyOiBudWxsLCBmdW5jLCB0aW1lOiB0aW1lb3V0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyLCBmdW5jLCB0aW1lOiBnZXRUaW1lKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQZXJmb3JtICUlZnVuYyUlIG9uIGVhY2ggc3Vic2NyaWJlci5cbiAgICAgKi9cbiAgICBfZm9yRWFjaFN1YnNjcmliZXIoZnVuYykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmdW5jKHN1Yi5zdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gY3VzdG9taXplIHN1YnNjcmlwdGlvblxuICAgICAqICBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBuZXcgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMucG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgY2FzZSBcInRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHRoaXMsIHN1Yi5oYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXZlbnQ6ICR7c3ViLnR5cGV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhIFtbU3Vic2NyaWJlcl1dIGZhaWxzIGFuZCBuZWVkcyB0byByZXBsYWNlIGl0c2VsZiwgdGhpc1xuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIHRoaXMgaXMgdXNlZCBmb3IgcHJvdmlkZXJzIHdoZW4gdXNpbmcgdGhlXG4gICAgICogIGBgZXRoX2dldEZpbHRlckNoYW5nZXNgYCBtZXRob2QsIHdoaWNoIGNhbiByZXR1cm4gbnVsbCBpZiBzdGF0ZVxuICAgICAqICBmaWx0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLCBhbGxvd2luZyB0aGUgU3Vic2NyaWJlclxuICAgICAqICB0byBzd2FwIGluIGEgW1tQb2xsaW5nRXZlbnRTdWJzY3JpYmVyXV0uXG4gICAgICovXG4gICAgX3JlY292ZXJTdWJzY3JpYmVyKG9sZFN1YiwgbmV3U3ViKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3Vic2NyaWJlciA9PT0gb2xkU3ViKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIgPSBuZXdTdWI7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjaGFzU3ViKGV2ZW50LCBlbWl0QXJncykge1xuICAgICAgICBsZXQgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxvZyB0aGF0IGlzIHJlbW92aW5nIGFuIGV4aXN0aW5nIGxvZzsgd2UgYWN0dWFsbHkgd2FudFxuICAgICAgICAvLyB0byBlbWl0IGFuIG9ycGhhbiBldmVudCBmb3IgdGhlIHJlbW92ZWQgbG9nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiICYmIGVtaXRBcmdzICYmIGVtaXRBcmdzLmxlbmd0aCA+IDAgJiYgZW1pdEFyZ3NbMF0ucmVtb3ZlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzogZW1pdEFyZ3NbMF0gfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3N1YnMuZ2V0KHN1Yi50YWcpIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jICNnZXRTdWIoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gUHJldmVudCB0YW1wZXJpbmcgd2l0aCBvdXIgdGFnIGluIGFueSBzdWJjbGFzcycgX2dldFN1YnNjcmliZXJcbiAgICAgICAgY29uc3QgdGFnID0gc3Vic2NyaXB0aW9uLnRhZztcbiAgICAgICAgbGV0IHN1YiA9IHRoaXMuI3N1YnMuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5fZ2V0U3Vic2NyaWJlcihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2FibGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgY29uc3QgbmFtZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHN1YiA9IHsgc3Vic2NyaWJlciwgdGFnLCBhZGRyZXNzYWJsZU1hcCwgbmFtZU1hcCwgc3RhcnRlZDogZmFsc2UsIGxpc3RlbmVyczogW10gfTtcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuc2V0KHRhZywgc3ViKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHN1YnNjcmlwdGlvbiBvciBpZiBhIHJlY2VudCBlbWl0IHJlbW92ZWRcbiAgICAgICAgLy8gdGhlIGxhc3Qgb2YgdGhlbSAod2hpY2ggYWxzbyBkZWxldGVkIHRoZSBzdWIpIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCFzdWIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEV2ZW50UGF5bG9hZCh0aGlzLCAob25jZSA/IG51bGwgOiBsaXN0ZW5lciksIGV2ZW50KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY291bnQgPiAwKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaXN0ZW5lciB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCBzdGFydGVkLCBzdWJzY3JpYmVyIH0gPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHsgc3RhcnRlZCwgc3Vic2NyaWJlciB9XSBvZiB0aGlzLiNzdWJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGlzIHByb3ZpZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCB1c2luZyB0aGUgW1tkZXN0cm95XV0gbWV0aG9kLlxuICAgICAqXG4gICAgICogIE9uY2UgZGVzdHJveWVkLCBhbGwgcmVzb3VyY2VzIGFyZSByZWNsYWltZWQsIGludGVybmFsIGV2ZW50IGxvb3BzXG4gICAgICogIGFuZCB0aW1lcnMgYXJlIGNsZWFuZWQgdXAgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgbWF5IGJlIHNlbnQgdG9cbiAgICAgKiAgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXN0cm95ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgdXNlIHRoaXMgdG8gc2h1dGRvd24gYW55IHNvY2tldHMgb3IgcmVsZWFzZSB0aGVpclxuICAgICAqICByZXNvdXJjZXMgYW5kIHJlamVjdCBhbnkgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIGBgc3VwZXIuZGVzdHJveSgpYGAuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIFNodXQgZG93biBhbGwgdGllbXJzXG4gICAgICAgIGZvciAoY29uc3QgdGltZXJJZCBvZiB0aGlzLiN0aW1lcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIHByb3ZpZGVyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICpcbiAgICAgKiAgQSBwYXVzZWQgcHJvdmlkZXIgd2lsbCBub3QgZW1pdCBhbnkgZXZlbnRzLCBhbmQgZ2VuZXJhbGx5IHNob3VsZFxuICAgICAqICBub3QgbWFrZSBhbnkgcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmssIGJ1dCB0aGF0IGlzIHVwIHRvIHN1Yi1jbGFzc2VzXG4gICAgICogIHRvIG1hbmFnZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIGBgcGF1c2VkID0gdHJ1ZWBgIGlzIGlkZW50aWNhbCB0byBjYWxsaW5nIGBgLnBhdXNlKGZhbHNlKWBgLFxuICAgICAqICB3aGljaCB3aWxsIGJ1ZmZlciBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgcGF1c2VkIHVudGlsIHRoZVxuICAgICAqICBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkgeyByZXR1cm4gKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpOyB9XG4gICAgc2V0IHBhdXNlZChwYXVzZSkge1xuICAgICAgICBpZiAoISFwYXVzZSA9PT0gdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGF1c2UgdGhlIHByb3ZpZGVyLiBJZiAlJWRyb3BXaGlsZVBhdXNlZCUlLCBhbnkgZXZlbnRzIHRoYXQgb2NjdXJcbiAgICAgKiAgd2hpbGUgcGF1c2VkIGFyZSBkcm9wcGVkLCBvdGhlcndpc2UgYWxsIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgb25jZVxuICAgICAqICB0aGUgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09ICEhZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBjaGFuZ2UgcGF1c2UgdHlwZTsgcmVzdW1lIGZpcnN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF1c2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucGF1c2UoZHJvcFdoaWxlUGF1c2VkKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gISFkcm9wV2hpbGVQYXVzZWQ7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgdGltZXJcbiAgICAgICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgZm9yIHdoZW4gd2UgYmVjb21lIHVucGF1c2VkXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpIC0gdGltZXIudGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzdW1lIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSB3aGVuIHdlIHdlcmUgcGF1c2VkXG4gICAgICAgICAgICBsZXQgdGltZW91dCA9IHRpbWVyLnRpbWU7XG4gICAgICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRpbWUgKGluIGNhdXNlIHBhdXNlZCwgc28gd2UgY29uIGNvbXB1dGUgcmVtYWluaW5mIHRpbWUpXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVyLmZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpO1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGFzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgLy8gQWRkIHBsYWNlLWhvbGRlcnMgZm9yIHBvaW50ZXJzIGFzIHdlIGFkZCBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW1wdHkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KHJlc3VsdCk7XG59XG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXG4gICAgfTtcbiAgICBhc3NlcnQoZGF0YUxlbmd0aChkYXRhKSA+PSA1ICogMzIsIFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2VuZGVyID0gZGF0YVNsaWNlKGRhdGEsIDAsIDMyKTtcbiAgICBhc3NlcnQoZGF0YVNsaWNlKHNlbmRlciwgMCwgMTIpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VuZGVyID0gZGF0YVNsaWNlKHNlbmRlciwgMTIpO1xuICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmxzID0gW107XG4gICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpO1xuICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0LCB1cmxzT2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVybHMgPSB1cmxzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDY0KTtcbiAgICAgICAgaWYgKGNhbGxkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jYWxsZGF0YSA9IGNhbGxkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICBhc3NlcnQoZGF0YVNsaWNlKGRhdGEsIDEwMCwgMTI4KSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAyOCksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZWxlY3RvciA9IGRhdGFTbGljZShkYXRhLCA5NiwgMTAwKTtcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC5lcnJvckFyZ3MgPSBcInNlbmRlcix1cmxzLGNhbGxkYXRhLHNlbGVjdG9yLGV4dHJhRGF0YVwiLnNwbGl0KC8sLykubWFwKChrKSA9PiByZXN1bHRba10pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsInJlc29sdmVBZGRyZXNzIiwiWmVyb0FkZHJlc3MiLCJDb250cmFjdCIsIm5hbWVoYXNoIiwiVHJhbnNhY3Rpb24iLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZGF0YVNsaWNlIiwiaGV4bGlmeSIsImlzSGV4U3RyaW5nIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJnZXROdW1iZXIiLCJpc0NhbGxFeGNlcHRpb24iLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJGZXRjaFJlcXVlc3QiLCJ0b0JlQXJyYXkiLCJ0b1F1YW50aXR5IiwiZGVmaW5lUHJvcGVydGllcyIsIkV2ZW50UGF5bG9hZCIsInJlc29sdmVQcm9wZXJ0aWVzIiwidG9VdGY4U3RyaW5nIiwiRW5zUmVzb2x2ZXIiLCJmb3JtYXRCbG9jayIsImZvcm1hdExvZyIsImZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJOZXR3b3JrIiwiY29weVJlcXVlc3QiLCJCbG9jayIsIkZlZURhdGEiLCJMb2ciLCJUcmFuc2FjdGlvblJlY2VpcHQiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciIsIlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIiLCJCTl8yIiwiQmlnSW50IiwiTUFYX0NDSVBfUkVESVJFQ1RTIiwiaXNQcm9taXNlIiwidmFsdWUiLCJ0aGVuIiwiZ2V0VGFnIiwicHJlZml4IiwiSlNPTiIsInN0cmluZ2lmeSIsImsiLCJ2IiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwicmVkdWNlIiwiYWNjdW0iLCJrZXkiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwic3RhcnQiLCJzdG9wIiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJjb3B5IiwicGFyc2UiLCJjb25jaXNpZnkiLCJpdGVtcyIsImZyb20iLCJTZXQiLCJ2YWx1ZXMiLCJnZXRTdWJzY3JpcHRpb24iLCJfZXZlbnQiLCJwcm92aWRlciIsIkVycm9yIiwidG9waWNzIiwidHlwZSIsInRhZyIsImhhc2giLCJvcnBoYW4iLCJldmVudCIsImZpbHRlciIsImFkZHJlc3MiLCJtYXAiLCJ0IiwiYWRkcmVzc2VzIiwicHJvbWlzZXMiLCJhZGRBZGRyZXNzIiwiYWRkciIsInB1c2giLCJmb3JFYWNoIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsImEiLCJnZXRUaW1lIiwiRGF0ZSIsImRlZmF1bHRPcHRpb25zIiwiY2FjaGVUaW1lb3V0IiwicG9sbGluZ0ludGVydmFsIiwiQWJzdHJhY3RQcm92aWRlciIsInN1YnMiLCJwbHVnaW5zIiwicGF1c2VkU3RhdGUiLCJkZXN0cm95ZWQiLCJuZXR3b3JrUHJvbWlzZSIsImFueU5ldHdvcmsiLCJwZXJmb3JtQ2FjaGUiLCJsYXN0QmxvY2tOdW1iZXIiLCJuZXh0VGltZXIiLCJ0aW1lcnMiLCJkaXNhYmxlQ2NpcFJlYWQiLCJvcHRpb25zIiwiX25ldHdvcmsiLCJhc3NpZ24iLCJuZXR3b3JrIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlbWl0IiwiTWFwIiwiYXR0YWNoUGx1Z2luIiwicGx1Z2luIiwiZ2V0Iiwic2V0IiwiY29ubmVjdCIsImdldFBsdWdpbiIsInBlcmZvcm0iLCJyZXEiLCJ0aW1lb3V0IiwiX3BlcmZvcm0iLCJtZXRob2QiLCJkZWxldGUiLCJjY2lwUmVhZEZldGNoIiwidHgiLCJjYWxsZGF0YSIsInVybHMiLCJ0byIsInNlbmRlciIsImRhdGEiLCJlcnJvck1lc3NhZ2VzIiwiaSIsInVybCIsImhyZWYiLCJyZXBsYWNlIiwicmVxdWVzdCIsImluZGV4T2YiLCJib2R5IiwiYWN0aW9uIiwiaW5kZXgiLCJlcnJvck1lc3NhZ2UiLCJyZXNwIiwic2VuZCIsInJlc3VsdCIsImJvZHlKc29uIiwibWVzc2FnZSIsImVycm9yIiwic3RhdHVzQ29kZSIsInJlYXNvbiIsInRyYW5zYWN0aW9uIiwiaW5mbyIsIm0iLCJqb2luIiwiX3dyYXBCbG9jayIsIl93cmFwTG9nIiwiX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQiLCJfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZGV0ZWN0TmV0d29yayIsIm9wZXJhdGlvbiIsImdldEJsb2NrTnVtYmVyIiwiYmxvY2tOdW1iZXIiLCJfZ2V0QWRkcmVzcyIsIl9nZXRCbG9ja1RhZyIsImJsb2NrVGFnIiwiYiIsIl9nZXRGaWx0ZXIiLCJibG9ja0hhc2giLCJ1bmRlZmluZWQiLCJfYWRkcmVzcyIsImZyb21CbG9jayIsInRvQmxvY2siLCJfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0IiwiX3JlcXVlc3QiLCJnZXROZXR3b3JrIiwiZGV0ZWN0TmV0d29yayIsImNsb25lIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGFpbklkIiwiZ2V0RmVlRGF0YSIsImdldEZlZURhdGFGdW5jIiwiX2Jsb2NrIiwiZ2FzUHJpY2UiLCJnZXRCbG9jayIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiYmxvY2siLCJiYXNlRmVlUGVyR2FzIiwiZmVlRGF0YSIsInByb2Nlc3NGdW5jIiwiZXN0aW1hdGVHYXMiLCJfdHgiLCJjYWxsIiwiYXR0ZW1wdCIsImVuYWJsZUNjaXBSZWFkIiwidHhTZW5kZXIiLCJjY2lwQXJncyIsInBhcnNlT2ZmY2hhaW5Mb29rdXAiLCJpbnZvY2F0aW9uIiwicmV2ZXJ0Iiwic2lnbmF0dXJlIiwiYXJncyIsImVycm9yQXJncyIsImNjaXBSZXN1bHQiLCJzZWxlY3RvciIsImVuY29kZUJ5dGVzIiwiZXh0cmFEYXRhIiwiY2hlY2tOZXR3b3JrIiwicHJvbWlzZSIsImdldEFjY291bnRWYWx1ZSIsIl9ibG9ja1RhZyIsImdldEJhbGFuY2UiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwiZ2V0Q29kZSIsImdldFN0b3JhZ2UiLCJfcG9zaXRpb24iLCJwb3NpdGlvbiIsImJyb2FkY2FzdFRyYW5zYWN0aW9uIiwic2lnbmVkVHgiLCJzaWduZWRUcmFuc2FjdGlvbiIsInJlcGxhY2VhYmxlVHJhbnNhY3Rpb24iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwicHJlZmV0Y2hUeHMiLCJwYXJhbXMiLCJnZXRUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiZ2V0VHJhbnNhY3Rpb25SZXN1bHQiLCJnZXRMb2dzIiwiX2ZpbHRlciIsInAiLCJfZ2V0UHJvdmlkZXIiLCJnZXRSZXNvbHZlciIsImZyb21OYW1lIiwiZ2V0QXZhdGFyIiwicmVzb2x2ZXIiLCJyZXNvbHZlTmFtZSIsImxvb2t1cEFkZHJlc3MiLCJub2RlIiwic3Vic3RyaW5nIiwiZW5zQWRkciIsImdldEVuc0FkZHJlc3MiLCJlbnNDb250cmFjdCIsInJlc29sdmVyQ29udHJhY3QiLCJjaGVjayIsIndhaXRGb3JUcmFuc2FjdGlvbiIsIl9jb25maXJtcyIsImNvbmZpcm1zIiwicmVqZWN0IiwidGltZXIiLCJsaXN0ZW5lciIsInJlY2VpcHQiLCJjbGVhclRpbWVvdXQiLCJjb25zb2xlIiwibG9nIiwib25jZSIsIm9mZiIsIndhaXRGb3JCbG9jayIsIl9jbGVhclRpbWVvdXQiLCJ0aW1lcklkIiwiX3NldFRpbWVvdXQiLCJfZnVuYyIsImZ1bmMiLCJwYXVzZWQiLCJ0aW1lIiwiX2ZvckVhY2hTdWJzY3JpYmVyIiwic3ViIiwic3Vic2NyaWJlciIsIl9nZXRTdWJzY3JpYmVyIiwiX3JlY292ZXJTdWJzY3JpYmVyIiwib2xkU3ViIiwibmV3U3ViIiwic3RhcnRlZCIsImhhc1N1YiIsImVtaXRBcmdzIiwicmVtb3ZlZCIsImdldFN1YiIsInN1YnNjcmlwdGlvbiIsImFkZHJlc3NhYmxlTWFwIiwiV2Vha01hcCIsIm5hbWVNYXAiLCJsaXN0ZW5lcnMiLCJvbiIsImNvdW50IiwicGF5bG9hZCIsImxpc3RlbmVyQ291bnQiLCJ0b3RhbCIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJkZXN0cm95IiwicyIsIl9wYXJzZVN0cmluZyIsImJ5dGVzIiwiX3BhcnNlQnl0ZXMiLCJvZmZzZXQiLCJudW1QYWQiLCJwYWRkZWQiLCJVaW50OEFycmF5IiwiYnl0ZXNQYWQiLCJNYXRoIiwiY2VpbCIsImVtcHR5IiwiZGF0YXMiLCJieXRlQ291bnQiLCJ6ZXJvcyIsInVybHNPZmZzZXQiLCJ1cmxzTGVuZ3RoIiwidXJsc0RhdGEiLCJ1Iiwic3BsaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: () => (/* binding */ AbstractSigner),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */ \n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then(([address, from])=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */ class AbstractSigner {\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */ constructor(provider){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            provider: provider || null\n        });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await this.provider.getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        } else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    pop.type = 2;\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    } else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                } else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            } else if (pop.type === 2) {\n                // Explicitly using EIP-1559\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */ class VoidSigner extends AbstractSigner {\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */ constructor(address, provider){\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            address\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n} //# sourceMappingURL=abstract-signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDb0Q7QUFDQztBQUNxRDtBQUMvRDtBQUM1QyxTQUFTUSxjQUFjQyxNQUFNLEVBQUVDLFNBQVM7SUFDcEMsSUFBSUQsT0FBT0UsUUFBUSxFQUFFO1FBQ2pCLE9BQU9GLE9BQU9FLFFBQVE7SUFDMUI7SUFDQU4sdURBQU1BLENBQUMsT0FBTyxvQkFBb0IseUJBQXlCO1FBQUVLO0lBQVU7QUFDM0U7QUFDQSxlQUFlRSxTQUFTSCxNQUFNLEVBQUVJLEVBQUU7SUFDOUIsSUFBSUMsTUFBTVAseURBQVdBLENBQUNNO0lBQ3RCLElBQUlDLElBQUlDLEVBQUUsSUFBSSxNQUFNO1FBQ2hCRCxJQUFJQyxFQUFFLEdBQUdmLGlFQUFjQSxDQUFDYyxJQUFJQyxFQUFFLEVBQUVOO0lBQ3BDO0lBQ0EsSUFBSUssSUFBSUUsSUFBSSxJQUFJLE1BQU07UUFDbEIsTUFBTUEsT0FBT0YsSUFBSUUsSUFBSTtRQUNyQkYsSUFBSUUsSUFBSSxHQUFHQyxRQUFRQyxHQUFHLENBQUM7WUFDbkJULE9BQU9VLFVBQVU7WUFDakJuQixpRUFBY0EsQ0FBQ2dCLE1BQU1QO1NBQ3hCLEVBQUVXLElBQUksQ0FBQyxDQUFDLENBQUNDLFNBQVNMLEtBQUs7WUFDcEJWLCtEQUFjQSxDQUFDZSxRQUFRQyxXQUFXLE9BQU9OLEtBQUtNLFdBQVcsSUFBSSw2QkFBNkIsV0FBV047WUFDckcsT0FBT0s7UUFDWDtJQUNKLE9BQ0s7UUFDRFAsSUFBSUUsSUFBSSxHQUFHUCxPQUFPVSxVQUFVO0lBQ2hDO0lBQ0EsT0FBTyxNQUFNZixrRUFBaUJBLENBQUNVO0FBQ25DO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNUztJQUtUOztLQUVDLEdBQ0RDLFlBQVliLFFBQVEsQ0FBRTtRQUNsQlQsaUVBQWdCQSxDQUFDLElBQUksRUFB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SSxDQUFDN0IsT0FBTyxFQUFFVjtJQUN4QztJQUNBLENBQUN5QyxnQkFBZ0IsQ0FBQ0MsTUFBTSxFQUFFM0MsU0FBUztRQUMvQkwsdURBQU1BLENBQUMsT0FBTyxDQUFDLHVCQUF1QixFQUFFZ0QsT0FBTyxDQUFDLEVBQUUseUJBQXlCO1lBQUUzQztRQUFVO0lBQzNGO0lBQ0EsTUFBTXVDLGdCQUFnQnBDLEVBQUUsRUFBRTtRQUN0QixJQUFJLENBQUMsQ0FBQ3VDLGdCQUFnQixDQUFDLGdCQUFnQjtJQUMzQztJQUNBLE1BQU1FLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixJQUFJLENBQUMsQ0FBQ0gsZ0JBQWdCLENBQUMsWUFBWTtJQUN2QztJQUNBLE1BQU1JLGNBQWNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7UUFDdEMsSUFBSSxDQUFDLENBQUNQLGdCQUFnQixDQUFDLGNBQWM7SUFDekM7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcz9lZDhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEdlbmVyYWxseSB0aGUgW1tXYWxsZXRdXSBhbmQgW1tKc29uUnBjU2lnbmVyXV0gYW5kIHRoZWlyIHN1Yi1jbGFzc2VzXG4gKiAgYXJlIHN1ZmZpY2VudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9IHJlc29sdmVBZGRyZXNzKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICByZXNvbHZlQWRkcmVzcyhmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gZ2V0QmlnSW50KHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBhc3NlcnQoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCB0aGV5IGFyZSB0cnlpbmcgdG8gdXNlIEVJUC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KCFoYXNFaXAxNTU5LCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogTWF5YmUgdGhpcyBzaG9sZCBhbGxvdyB0eXBlIDE/XG4gICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0BUT09EOiBEb24ndCBhd2FpdCBhbGwgb3ZlciB0aGUgcGxhY2U7IHNhdmUgdGhlbSB1cCBmb3JcbiAgICAgICAgLy8gdGhlIGVuZCBmb3IgYmV0dGVyIGJhdGNoaW5nXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImVzdGltYXRlR2FzXCIpLmVzdGltYXRlR2FzKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwodHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJjYWxsXCIpLmNhbGwoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBkZWxldGUgcG9wLmZyb207XG4gICAgICAgIGNvbnN0IHR4T2JqID0gVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24oYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHhPYmopKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVpc2duZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVBZGRyZXNzIiwiVHJhbnNhY3Rpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImNvcHlSZXF1ZXN0IiwiY2hlY2tQcm92aWRlciIsInNpZ25lciIsIm9wZXJhdGlvbiIsInByb3ZpZGVyIiwicG9wdWxhdGUiLCJ0eCIsInBvcCIsInRvIiwiZnJvbSIsIlByb21pc2UiLCJhbGwiLCJnZXRBZGRyZXNzIiwidGhlbiIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsIkFic3RyYWN0U2lnbmVyIiwiY29uc3RydWN0b3IiLCJnZXROb25jZSIsImJsb2NrVGFnIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsInBvcHVsYXRlQ2FsbCIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJub25jZSIsImdhc0xpbWl0IiwiZXN0aW1hdGVHYXMiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJoYXNFaXAxNTU5IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJnYXNQcmljZSIsInR5cGUiLCJmZWVEYXRhIiwiZ2V0RmVlRGF0YSIsImNhbGwiLCJyZXNvbHZlTmFtZSIsIm5hbWUiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0eE9iaiIsImJyb2FkY2FzdFRyYW5zYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwiVm9pZFNpZ25lciIsImNvbm5lY3QiLCJ0aHJvd1Vuc3VwcG9ydGVkIiwic3VmZml4Iiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnblR5cGVkRGF0YSIsImRvbWFpbiIsInR5cGVzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: () => (/* binding */ BasicMulticoinProviderPlugin),\n/* harmony export */   EnsResolver: () => (/* binding */ EnsResolver),\n/* harmony export */   MulticoinProviderPlugin: () => (/* binding */ MulticoinProviderPlugin)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contract/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/fetch.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */ \n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */ class MulticoinProviderPlugin {\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            name\n        });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */ supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */ async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */ async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */ class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */ constructor(){\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */ class EnsResolver {\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            provider,\n            address,\n            name\n        });\n        this.#supports2544 = null;\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\"\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */ async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async ()=>{\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: {\n                    funcName\n                }\n            });\n            params = [\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.dnsEncode)(this.name),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        } catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */ async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            } catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [\n                ethCoinType\n            ]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins){\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [\n            coinType\n        ]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: {\n                coinType,\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */ async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [\n            key\n        ]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */ async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: {\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */ async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */ async _getAvatar() {\n        const linkage = [\n            {\n                type: \"name\",\n                value: this.name\n            }\n        ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({\n                    type: \"!avatar\",\n                    value: \"\"\n                });\n                return {\n                    url: null,\n                    linkage\n                };\n            }\n            linkage.push({\n                type: \"avatar\",\n                value: avatar\n            });\n            for(let i = 0; i < matchers.length; i++){\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch(scheme){\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({\n                            type: \"url\",\n                            value: avatar\n                        });\n                        return {\n                            linkage,\n                            url: avatar\n                        };\n                    case \"ipfs\":\n                        {\n                            const url = getIpfsLink(avatar);\n                            linkage.push({\n                                type: \"ipfs\",\n                                value: avatar\n                            });\n                            linkage.push({\n                                type: \"url\",\n                                value: url\n                            });\n                            return {\n                                linkage,\n                                url\n                            };\n                        }\n                    case \"erc721\":\n                    case \"erc1155\":\n                        {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                            linkage.push({\n                                type: scheme,\n                                value: avatar\n                            });\n                            // The owner of this name\n                            const owner = await this.getAddress();\n                            if (owner == null) {\n                                linkage.push({\n                                    type: \"!owner\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                linkage.push({\n                                    type: `!${scheme}caip`,\n                                    value: match[2] || \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const tokenId = comps[1];\n                            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(comps[0], [\n                                // ERC-721\n                                \"function tokenURI(uint) view returns (string)\",\n                                \"function ownerOf(uint) view returns (address)\",\n                                // ERC-1155\n                                \"function uri(uint) view returns (string)\",\n                                \"function balanceOf(address, uint256) view returns (uint)\"\n                            ], this.provider);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                const tokenOwner = await contract.ownerOf(tokenId);\n                                if (owner !== tokenOwner) {\n                                    linkage.push({\n                                        type: \"!owner\",\n                                        value: tokenOwner\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"owner\",\n                                    value: tokenOwner\n                                });\n                            } else if (scheme === \"erc1155\") {\n                                const balance = await contract.balanceOf(owner, tokenId);\n                                if (!balance) {\n                                    linkage.push({\n                                        type: \"!balance\",\n                                        value: \"0\"\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"balance\",\n                                    value: balance.toString()\n                                });\n                            }\n                            // Call the token contract for the metadata URL\n                            let metadataUrl = await contract[selector](tokenId);\n                            if (metadataUrl == null || metadataUrl === \"0x\") {\n                                linkage.push({\n                                    type: \"!metadata-url\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata-url-base\",\n                                value: metadataUrl\n                            });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeHex)(tokenId, 32).substring(2));\n                                linkage.push({\n                                    type: \"metadata-url-expanded\",\n                                    value: metadataUrl\n                                });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({\n                                type: \"metadata-url\",\n                                value: metadataUrl\n                            });\n                            // Get the token metadata\n                            let metadata = {};\n                            const response = await new _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest(metadataUrl).send();\n                            response.assertOk();\n                            try {\n                                metadata = response.bodyJson;\n                            } catch (error) {\n                                try {\n                                    linkage.push({\n                                        type: \"!metadata\",\n                                        value: response.bodyText\n                                    });\n                                } catch (error) {\n                                    const bytes = response.body;\n                                    if (bytes) {\n                                        linkage.push({\n                                            type: \"!metadata\",\n                                            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes)\n                                        });\n                                    }\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (!metadata) {\n                                linkage.push({\n                                    type: \"!metadata\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata\",\n                                value: JSON.stringify(metadata)\n                            });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof imageUrl !== \"string\") {\n                                linkage.push({\n                                    type: \"!imageUrl\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                            } else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    linkage.push({\n                                        type: \"!imageUrl-ipfs\",\n                                        value: imageUrl\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"imageUrl-ipfs\",\n                                    value: imageUrl\n                                });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({\n                                type: \"url\",\n                                value: imageUrl\n                            });\n                            return {\n                                linkage,\n                                url: imageUrl\n                            };\n                        }\n                }\n            }\n        } catch (error) {}\n        return {\n            linkage,\n            url: null\n        };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\",\n            info: {\n                network\n            }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */ static async fromName(provider, name) {\n        let currentName = name;\n        while(true){\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !await resolver.supportsWildcard()) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n} //# sourceMappingURL=ens-resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ2dEO0FBQ0c7QUFDSjtBQUNPO0FBQzBGO0FBQ2pKLHFEQUFxRDtBQUNyRCxpRUFBaUU7QUFDakUsU0FBU2MsWUFBWUMsSUFBSTtJQUNyQixJQUFJQSxLQUFLQyxLQUFLLENBQUMsc0JBQXNCO1FBQ2pDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSyxJQUFJRixLQUFLQyxLQUFLLENBQUMsZ0JBQWdCO1FBQ2hDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSztRQUNETiwrREFBY0EsQ0FBQyxPQUFPLDJCQUEyQixRQUFRSTtJQUM3RDtJQUNBLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsS0FBSyxDQUFDO0FBQ2xEOzs7QUFHQTs7Q0FFQyxHQUNNLE1BQU1HO0lBS1Q7O0tBRUMsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2RaLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVk7UUFBSztJQUNsQztJQUNBQyxRQUFRQyxRQUFRLEVBQUU7UUFDZCxPQUFPLElBQUk7SUFDZjtJQUNBOztLQUVDLEdBQ0RDLGlCQUFpQkMsUUFBUSxFQUFFO1FBQ3ZCLE9BQU87SUFDWDtJQUNBOztLQUVDLEdBQ0QsTUFBTUMsY0FBY0QsUUFBUSxFQUFFRSxPQUFPLEVBQUU7UUFDbkMsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxjQUFjSixRQUFRLEVBQUVLLElBQUksRUFBRTtRQUNoQyxNQUFNLElBQUlGLE1BQU07SUFDcEI7QUFDSjtBQUNBLE1BQU1HLHlCQUF5QjtBQUMvQjs7OztDQUlDLEdBQ00sTUFBTUMscUNBQXFDYjtJQUM5Qzs7S0FFQyxHQUNEQyxhQUFjO1FBQ1YsS0FBSyxDQUFDVztJQUNWO0FBQ0o7QUFDQSxNQUFN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QUdxRSxJQUFJLENBQUM7UUFDdkQ7SUFDSjtBQUNKLEVBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzP2M0YzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRU5TIGlzIGEgc2VydmljZSB3aGljaCBhbGxvd3MgZWFzeS10by1yZW1lbWJlciBuYW1lcyB0byBtYXAgdG9cbiAqICBuZXR3b3JrIGFkZHJlc3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Vucy1yZXNvbHZlcjpFTlMgUmVzb2x2ZXIgIFthYm91dC1lbnMtcnNvbHZlcl1cbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b0JlSGV4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIEZldGNoUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIHVzZSB0aGUgZmV0Y2gtZGF0YTppcGZzIGdhdGV3YXlcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIGBodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvJHtsaW5rfWA7XG59XG47XG47XG4vKipcbiAqICBBIHByb3ZpZGVyIHBsdWdpbiBzdXBlci1jbGFzcyBmb3IgcHJvY2Vzc2luZyBtdWx0aWNvaW4gYWRkcmVzcyB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvaXZkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvdmxlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZUFkZHJlc3MoY29pblR5cGUsIGFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc292bGVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xuLyoqXG4gKiAgQSAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKiBwcm92aWRlcyBzZXJ2aWNlIGZvciBjb21tb25cbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcbiAqICBkZWNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihCYXNpY011bHRpY29pblBsdWdpbklkKTtcbiAgICB9XG59XG5jb25zdCBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG5jb25zdCBtYXRjaGVycyA9IFtcbiAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihkYXRhKTooLiopJFwiLCBcImlcIiksXG4gICAgbWF0Y2hlcklwZnMsXG4gICAgbmV3IFJlZ0V4cChcIl5laXAxNTU6WzAtOV0rLyhlcmNbMC05XSspOiguKikkXCIsIFwiaVwiKSxcbl07XG4vKipcbiAqICBBIGNvbm5lY3RlZCBvYmplY3QgdG8gYSByZXNvbHZlZCBFTlMgbmFtZSByZXNvbHZlciwgd2hpY2ggY2FuIGJlXG4gKiAgdXNlZCB0byBxdWVyeSBhZGRpdGlvbmFsIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSByZXNvbHZlci5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSB0aGlzIHJlc29sdmVyIHdhcyByZXNvbHZlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLy8gRm9yIEVJUC0yNTQ0IG5hbWVzLCB0aGUgYW5jZXN0b3IgdGhhdCBwcm92aWRlZCB0aGUgcmVzb2x2ZXJcbiAgICAjc3VwcG9ydHMyNTQ0O1xuICAgICNyZXNvbHZlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XG4gICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVyID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIFtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmUoYnl0ZXMsIGJ5dGVzKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiB0ZXh0KGJ5dGVzMzIsIHN0cmluZykgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGNvbnRlbnRoYXNoKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQgZnV0dXJlIGF0dGVtcHRzIHRyeSBhZ2Fpbi4uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzdXBwb3J0czI1NDQ7XG4gICAgfVxuICAgIGFzeW5jICNmZXRjaChmdW5jTmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVycyBpcyBhbHdheXMgdGhlIG5vZGVoYXNoXG4gICAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWVoYXNoKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGZ1bmNOYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGRuc0VuY29kZSh0aGlzLm5hbWUpLFxuICAgICAgICAgICAgICAgIGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcGFyYW1zKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZ1bmNOYW1lID0gXCJyZXNvbHZlKGJ5dGVzLGJ5dGVzKVwiO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVzb2x2ZXJbZnVuY05hbWVdKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdClbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVjb2luVHlwZSUlIG9yIG51bGwgaWYgdGhlXG4gICAgICogIHByb3ZpZGVkICUlY29pblR5cGUlJSBoYXMgbm90IGJlZW4gY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKGNvaW5UeXBlKSB7XG4gICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luVHlwZSA9PT0gNjApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIpXCIpO1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcbiAgICAgICAgaWYgKGNvaW5UeXBlID49IDAgJiYgY29pblR5cGUgPCAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICBsZXQgZXRoQ29pblR5cGUgPSBjb2luVHlwZSArIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgMjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvaW5QbHVnaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnByb3ZpZGVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmICghKHBsdWdpbiBpbnN0YW5jZW9mIE11bHRpY29pblByb3ZpZGVyUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvaW5QbHVnaW4gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5QbHVnaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtjb2luVHlwZV0pO1xuICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb2luUGx1Z2luLmRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpO1xuICAgICAgICBpZiAoYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIGNvaW4gZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgIGluZm86IHsgY29pblR5cGUsIGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBFSVAtNjM0IHRleHQgcmVjb3JkIGZvciAlJWtleSUlLCBvciBgYG51bGxgYFxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSc29sdmVzIHRvIHRoZSBjb250ZW50LWhhc2ggb3IgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xuICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImNvbnRlbnRoYXNoKGJ5dGVzMzIpXCIpO1xuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiA3MD1EQUctUEIsIDcyPWxpYnAycC1rZXkpXG4gICAgICAgIGNvbnN0IGlwZnMgPSBkYXRhLm1hdGNoKC9eMHgoZTMwMTAxNzB8ZTUwMTAxNzIpKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IChpcGZzWzFdID09PSBcImUzMDEwMTcwXCIpID8gXCJpcGZzXCIgOiBcImlwbnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbNF0sIDE2KTtcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzY2hlbWV9Oi9cXC8ke2VuY29kZUJhc2U1OChcIjB4XCIgKyBpcGZzWzJdKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBkYXRhLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGBieno6L1xcLyR7c3dhcm1bMV19YDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcbiAgICAgICAgICAgIGluZm86IHsgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGF2YXRhciB1cmwgb3IgYGBudWxsYGAgaWYgdGhlIGF2YXRhciBpcyBlaXRoZXJcbiAgICAgKiAgdW5jb25maWd1cmVkIG9yIGluY29ycmVjdGx5IGNvbmZpZ3VyZWQgKGUuZy4gcmVmZXJlbmNlcyBhbiBORlRcbiAgICAgKiAgbm90IG93bmVkIGJ5IHRoZSBhZGRyZXNzKS5cbiAgICAgKlxuICAgICAqICBJZiBkaWFnbm9zaW5nIGlzc3VlcyB3aXRoIGNvbmZpZ3VyYXRpb25zLCB0aGUgW1tfZ2V0QXZhdGFyXV1cbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VmdWwuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLl9nZXRBdmF0YXIoKTtcbiAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGVuIHJlc29sdmluZyBhbiBhdmF0YXIsIHRoZXJlIGFyZSBtYW55IHN0ZXBzIGludm9sdmVkLCBzdWNoXG4gICAgICogIGZldGNoaW5nIG1ldGFkYXRhIGFuZCBwb3NzaWJseSB2YWxpZGF0aW5nIG93bmVyc2hpcCBvZiBhblxuICAgICAqICBORlQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZXhhbWluZSBlYWNoIHN0ZXAgYW5kIHRoZSB2YWx1ZSBpdFxuICAgICAqICB3YXMgd29ya2luZyBmcm9tLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRlc3QgZGF0YSBmb3IgcmljbW9vLmV0aFxuICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWF2YXRhclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYXZhdGFyXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpcGZzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldElwZnNMaW5rKGF2YXRhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcInRva2VuVVJJKHVpbnQyNTYpXCIgOiBcInVyaSh1aW50MjU2KVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG93bmVyIG9mIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogYCEke3NjaGVtZX1jYWlwYCwgdmFsdWU6IChtYXRjaFsyXSB8fCBcIlwiKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBjb21wc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbXBzWzBdLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTcyMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBvd25lck9mKHVpbnQpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MsIHVpbnQyNTYpIHZpZXcgcmV0dXJucyAodWludClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSBhd2FpdCBjb250cmFjdC5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZihvd25lciwgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwgfHwgbWV0YWRhdGFVcmwgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhLXVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b0JlSGV4KHRva2VuSWQsIDMyKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gZ2V0SXBmc0xpbmsobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChuZXcgRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiByZXNwb25zZS5ib2R5VGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogaGV4bGlmeShieXRlcykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpbWFnZVVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVVybC5tYXRjaCgvXihodHRwczpcXC9cXC98ZGF0YTopL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmwgPSBnZXRJcGZzTGluayhpbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBudWxsIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBnZXRFbnNBZGRyZXNzKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGVuc1BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgYXNzZXJ0KGVuc1BsdWdpbiwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRFbnNBZGRyZXNzXCIsIGluZm86IHsgbmV0d29yayB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5zUGx1Z2luLmFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgY29udHJhY3QucmVzb2x2ZXIobmFtZWhhc2gobmFtZSksIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMiksXG4gICAgICAgICAgICAvLyBzbyBwcm9iYWJseSBhIGxpbmsgZXJyb3JcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgRU5TIHJlc29sdmVyIGZvciAlJW5hbWUlJSB1c2luZyAlJXByb3ZpZGVyJSUgb3JcbiAgICAgKiAgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tTmFtZShwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXJkIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLiNnZXRSZXNvbHZlcihwcm92aWRlciwgY3VycmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gRm91bmQgYSByZXNvbHZlciFcbiAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBFbnNSZXNvbHZlcihwcm92aWRlciwgYWRkciwgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKGF3YWl0IHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zLXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiWmVyb0FkZHJlc3MiLCJDb250cmFjdCIsImRuc0VuY29kZSIsIm5hbWVoYXNoIiwiaGV4bGlmeSIsImlzSGV4U3RyaW5nIiwidG9CZUhleCIsImRlZmluZVByb3BlcnRpZXMiLCJlbmNvZGVCYXNlNTgiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImlzRXJyb3IiLCJGZXRjaFJlcXVlc3QiLCJnZXRJcGZzTGluayIsImxpbmsiLCJtYXRjaCIsInN1YnN0cmluZyIsIk11bHRpY29pblByb3ZpZGVyUGx1Z2luIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29ubmVjdCIsInByb2l2ZGVyIiwic3VwcG9ydHNDb2luVHlwZSIsImNvaW5UeXBlIiwiZW5jb2RlQWRkcmVzcyIsImFkZHJlc3MiLCJFcnJvciIsImRlY29kZUFkZHJlc3MiLCJkYXRhIiwiQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCIsIkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJtYXRjaGVySXBmcyIsIlJlZ0V4cCIsIm1hdGNoZXJzIiwiRW5zUmVzb2x2ZXIiLCJzdXBwb3J0czI1NDQiLCJyZXNvbHZlciIsInByb3ZpZGVyIiwic3VwcG9ydHNXaWxkY2FyZCIsInN1cHBvcnRzSW50ZXJmYWNlIiwiZXJyb3IiLCJmZXRjaCIsImZ1bmNOYW1lIiwicGFyYW1zIiwic2xpY2UiLCJpZmFjZSIsImludGVyZmFjZSIsInVuc2hpZnQiLCJmcmFnbWVudCIsImdldEZ1bmN0aW9uIiwiaW5mbyIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInB1c2giLCJlbmFibGVDY2lwUmVhZCIsInJlc3VsdCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiZXRoQ29pblR5cGUiLCJjb2luUGx1Z2luIiwicGx1Z2luIiwicGx1Z2lucyIsIm9wZXJhdGlvbiIsImdldFRleHQiLCJrZXkiLCJnZXRDb250ZW50SGFzaCIsImlwZnMiLCJzY2hlbWUiLCJsZW5ndGgiLCJwYXJzZUludCIsInN3YXJtIiwiZ2V0QXZhdGFyIiwiYXZhdGFyIiwiX2dldEF2YXRhciIsInVybCIsImxpbmthZ2UiLCJ0eXBlIiwidmFsdWUiLCJpIiwidG9Mb3dlckNhc2UiLCJzZWxlY3RvciIsIm93bmVyIiwiY29tcHMiLCJzcGxpdCIsInRva2VuSWQiLCJjb250cmFjdCIsInRva2VuT3duZXIiLCJvd25lck9mIiwiYmFsYW5jZSIsImJhbGFuY2VPZiIsInRvU3RyaW5nIiwibWV0YWRhdGFVcmwiLCJyZXBsYWNlIiwibWV0YWRhdGEiLCJyZXNwb25zZSIsInNlbmQiLCJhc3NlcnRPayIsImJvZHlKc29uIiwiYm9keVRleHQiLCJieXRlcyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1hZ2VVcmwiLCJpbWFnZSIsImdldEVuc0FkZHJlc3MiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImVuc1BsdWdpbiIsImdldFBsdWdpbiIsImdldFJlc29sdmVyIiwiZW5zQWRkciIsImFkZHIiLCJmcm9tTmFtZSIsImN1cnJlbnROYW1lIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/ens-resolver.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/format.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/format.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: () => (/* binding */ allowNull),\n/* harmony export */   arrayOf: () => (/* binding */ arrayOf),\n/* harmony export */   formatBlock: () => (/* binding */ formatBlock),\n/* harmony export */   formatBoolean: () => (/* binding */ formatBoolean),\n/* harmony export */   formatData: () => (/* binding */ formatData),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   formatLog: () => (/* binding */ formatLog),\n/* harmony export */   formatReceiptLog: () => (/* binding */ formatReceiptLog),\n/* harmony export */   formatTransactionReceipt: () => (/* binding */ formatTransactionReceipt),\n/* harmony export */   formatTransactionResponse: () => (/* binding */ formatTransactionResponse),\n/* harmony export */   formatUint256: () => (/* binding */ formatUint256),\n/* harmony export */   object: () => (/* binding */ object)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  @_ignore\n */ \n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return function(value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    };\n}\nfunction arrayOf(format) {\n    return (array)=>{\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i)=>format(i));\n    };\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return (value)=>{\n        const result = {};\n        for(const key in format){\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]){\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            } catch (error) {\n                const message = error instanceof Error ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", {\n                    value\n                });\n            }\n        }\n        return result;\n    };\n}\nfunction formatBoolean(value) {\n    switch(value){\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx)=>{\n        if (typeof tx === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockHash: formatHash\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\n        \"gasPrice\"\n    ],\n    hash: [\n        \"transactionHash\"\n    ],\n    index: [\n        \"transactionIndex\"\n    ]\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        type: (value)=>{\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify, null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        //confirmations: allowNull(getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null)\n    }, {\n        data: [\n            \"input\"\n        ],\n        gasLimit: [\n            \"gas\"\n        ]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_5__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(value.signature);\n    } else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */ // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n} //# sourceMappingURL=format.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9mb3JtYXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ2tFO0FBQ3BCO0FBQ1M7QUFDNkQ7QUFDckgsTUFBTVcsT0FBT0MsT0FBTztBQUNiLFNBQVNDLFVBQVVDLE1BQU0sRUFBRUMsU0FBUztJQUN2QyxPQUFRLFNBQVVDLEtBQUs7UUFDbkIsSUFBSUEsU0FBUyxNQUFNO1lBQ2YsT0FBT0Q7UUFDWDtRQUNBLE9BQU9ELE9BQU9FO0lBQ2xCO0FBQ0o7QUFDTyxTQUFTQyxRQUFRSCxNQUFNO0lBQzFCLE9BQVEsQ0FBQ0k7UUFDTCxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtZQUN2QixNQUFNLElBQUlHLE1BQU07UUFDcEI7UUFDQSxPQUFPSCxNQUFNSSxHQUFHLENBQUMsQ0FBQ0MsSUFBTVQsT0FBT1M7SUFDbkM7QUFDSjtBQUNBLCtEQUErRDtBQUMvRCxrRUFBa0U7QUFDbEUsaURBQWlEO0FBQzFDLFNBQVNDLE9BQU9WLE1BQU0sRUFBRVcsUUFBUTtJQUNuQyxPQUFRLENBQUNUO1FBQ0wsTUFBTVUsU0FBUyxDQUFDO1FBQ2hCLElBQUssTUFBTUMsT0FBT2IsT0FBUTtZQUN0QixJQUFJYyxTQUFTRDtZQUNiLElBQUlGLFlBQVlFLE9BQU9GLFlBQVksQ0FBRUcsQ0FBQUEsVUFBVVosS0FBSSxHQUFJO2dCQUNuRCxLQUFLLE1BQU1hLFVBQVVKLFFBQVEsQ0FBQ0UsSUFBSSxDQUFFO29CQUNoQyxJQUFJRSxVQUFVYixPQUFPO3dCQUNqQlksU0FBU0M7d0JBQ1Q7b0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLElBQUk7Z0JBQ0EsTUFBTUMsS0FBS2hCLE1BQU0sQ0FBQ2EsSUFBSSxDQUFDWCxLQUFLLENBQUNZLE9BQU87Z0JBQ3BDLElBQUlFLE9BQU9DLFdBQVc7b0JBQ2xCTCxNQUFNLENBQUNDLElBQUksR0FBR0c7Z0JBQ2xC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QVMsQ0FBQ0MsYUFBYTtRQUM5QyxJQUFJRixXQUFXLE1BQU07WUFDakI1RCxPQUFPNEQsT0FBTyxHQUFHQTtRQUNyQjtJQUNKO0lBQ0EsdUJBQXVCO0lBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdDQSxHQUNBLG9DQUFvQztJQUNwQyxJQUFJNUQsT0FBT2dCLFNBQVMsSUFBSXRDLDBEQUFTQSxDQUFDc0IsT0FBT2dCLFNBQVMsTUFBTS9CLE1BQU07UUFDMURlLE9BQU9nQixTQUFTLEdBQUc7SUFDdkI7SUFDQSxPQUFPaEI7QUFDWCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcz83OGMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MsIGdldENyZWF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5leHBvcnQgZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQpIHtcbiAgICByZXR1cm4gKChhcnJheSkgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoaSkgPT4gZm9ybWF0KGkpKTtcbiAgICB9KTtcbn1cbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xuLy8gQW55IEZvcm1hdEZ1bmMgbWF5IHJldHVybiBgdW5kZWZpbmVkYCB0byBoYXZlIHRoZSB2YWx1ZSBvbWl0dGVkXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KGZvcm1hdCwgYWx0TmFtZXMpIHtcbiAgICByZXR1cm4gKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybWF0KSB7XG4gICAgICAgICAgICBsZXQgc3JjS2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGFsdE5hbWVzICYmIGtleSBpbiBhbHROYW1lcyAmJiAhKHNyY0tleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsdEtleSBvZiBhbHROYW1lc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHRLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0tleSA9IGFsdEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudiA9IGZvcm1hdFtrZXldKHZhbHVlW3NyY0tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChudiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBcIm5vdC1hbi1lcnJvclwiO1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCb29sZWFuKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBib29sZWFuOyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRhKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpLCBcImludmFsaWQgZGF0YVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SGFzaCh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCAzMiksIFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVaW50MjU2KHZhbHVlKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgIH1cbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHZhbHVlLCAzMik7XG59XG5jb25zdCBfZm9ybWF0TG9nID0gb2JqZWN0KHtcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByZW1vdmVkOiBhbGxvd051bGwoZm9ybWF0Qm9vbGVhbiwgZmFsc2UpLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXG4gICAgcGFyZW50SGFzaDogZm9ybWF0SGFzaCxcbiAgICBudW1iZXI6IGdldE51bWJlcixcbiAgICB0aW1lc3RhbXA6IGdldE51bWJlcixcbiAgICBub25jZTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGRpZmZpY3VsdHk6IGdldEJpZ0ludCxcbiAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBtaW5lcjogYWxsb3dOdWxsKGdldEFkZHJlc3MpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QmxvY2sodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBfZm9ybWF0QmxvY2sodmFsdWUpO1xuICAgIHJlc3VsdC50cmFuc2FjdGlvbnMgPSB2YWx1ZS50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IF9mb3JtYXRSZWNlaXB0TG9nID0gb2JqZWN0KHtcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFJlY2VpcHRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IG9iamVjdCh7XG4gICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBmcm9tOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgY29udHJhY3RBZGRyZXNzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByb290OiBhbGxvd051bGwoaGV4bGlmeSksXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGxvZ3NCbG9vbTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgIGxvZ3M6IGFycmF5T2YoZm9ybWF0UmVjZWlwdExvZyksXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgIHN0YXR1czogYWxsb3dOdWxsKGdldE51bWJlciksXG4gICAgdHlwZTogYWxsb3dOdWxsKGdldE51bWJlciwgMClcbn0sIHtcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXG4gICAgaGFzaDogW1widHJhbnNhY3Rpb25IYXNoXCJdLFxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodmFsdWUpIHtcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICBpZiAodmFsdWUudG8gJiYgZ2V0QmlnSW50KHZhbHVlLnRvKSA9PT0gQk5fMCkge1xuICAgICAgICB2YWx1ZS50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9iamVjdCh7XG4gICAgICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFsbG93TnVsbChhY2Nlc3NMaXN0aWZ5LCBudWxsKSxcbiAgICAgICAgYmxvY2tIYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgICAgIGJsb2NrTnVtYmVyOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGdldEFkZHJlc3MsXG4gICAgICAgIC8vIGVpdGhlciAoZ2FzUHJpY2UpIG9yIChtYXhQcmlvcml0eUZlZVBlckdhcyArIG1heEZlZVBlckdhcykgbXVzdCBiZSBzZXRcbiAgICAgICAgZ2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXG4gICAgICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIHZhbHVlOiBnZXRCaWdJbnQsXG4gICAgICAgIG5vbmNlOiBnZXROdW1iZXIsXG4gICAgICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgICAgIGNyZWF0ZXM6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbClcbiAgICB9LCB7XG4gICAgICAgIGRhdGE6IFtcImlucHV0XCJdLFxuICAgICAgICBnYXNMaW1pdDogW1wiZ2FzXCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9IGdldENyZWF0ZUFkZHJlc3MocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICgodmFsdWUudHlwZSA9PT0gMSB8fCB2YWx1ZS50eXBlID09PSAyKSAmJiB2YWx1ZS5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgc2lnbmF0dXJlXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNvbWUgYmFja2VuZHMgb21pdCBDaGFpbklkIG9uIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGJ1dCB3ZSBjYW4gY29tcHV0ZSBpdFxuICAgIGlmIChyZXN1bHQuY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSByZXN1bHQuc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogY2hlY2sgY2hhaW5JRFxuICAgIC8qXG4gICAgaWYgKHZhbHVlLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUubmV0d29ya0lkO1xuXG4gICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHsgY2hhaW5JZCA9IDA7IH1cbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHsgY2hhaW5JZCA9IDA7IH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICAgICovXG4gICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgZ2V0QmlnSW50KHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsIlNpZ25hdHVyZSIsImFjY2Vzc0xpc3RpZnkiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJhbGxvd051bGwiLCJmb3JtYXQiLCJudWxsVmFsdWUiLCJ2YWx1ZSIsImFycmF5T2YiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwibWFwIiwiaSIsIm9iamVjdCIsImFsdE5hbWVzIiwicmVzdWx0Iiwia2V5Iiwic3JjS2V5IiwiYWx0S2V5IiwibnYiLCJ1bmRlZmluZWQiLCJlcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXRCb29sZWFuIiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdERhdGEiLCJmb3JtYXRIYXNoIiwiZm9ybWF0VWludDI1NiIsIl9mb3JtYXRMb2ciLCJhZGRyZXNzIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJkYXRhIiwiaW5kZXgiLCJyZW1vdmVkIiwidG9waWNzIiwidHJhbnNhY3Rpb25IYXNoIiwidHJhbnNhY3Rpb25JbmRleCIsImZvcm1hdExvZyIsIl9mb3JtYXRCbG9jayIsImhhc2giLCJwYXJlbnRIYXNoIiwibnVtYmVyIiwidGltZXN0YW1wIiwibm9uY2UiLCJkaWZmaWN1bHR5IiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwibWluZXIiLCJleHRyYURhdGEiLCJiYXNlRmVlUGVyR2FzIiwiZm9ybWF0QmxvY2siLCJ0cmFuc2FjdGlvbnMiLCJ0eCIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZm9ybWF0UmVjZWlwdExvZyIsImZvcm1hdFJlY2VpcHRMb2ciLCJfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwidG8iLCJmcm9tIiwiY29udHJhY3RBZGRyZXNzIiwicm9vdCIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwic3RhdHVzIiwidHlwZSIsImZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsImFjY2Vzc0xpc3QiLCJnYXNQcmljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwiY3JlYXRlcyIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJsZWdhY3lDaGFpbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/format.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/network.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/network.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */ \n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/ const Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */ class Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */ constructor(name, chainId){\n        this.#name = name;\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */ toJSON() {\n        return {\n            name: this.name,\n            chainId: String(this.chainId)\n        };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */ get name() {\n        return this.#name;\n    }\n    set name(value) {\n        this.#name = value;\n    }\n    /**\n     *  The network chain ID.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\");\n    }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */ matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof other === \"string\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return this.name === other;\n        }\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return false;\n        }\n        if (typeof other === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId);\n                } catch (error) {}\n                return false;\n            }\n            if (other.name != null) {\n                return this.name === other.name;\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */ getPlugins(basename) {\n        return this.plugins.filter((p)=>p.name.split(\"#\")[0] === basename);\n    }\n    /**\n     *  Create a copy of this Network.\n     */ clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin)=>{\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */ computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin();\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for(let i = 2; i < tx.data.length; i += 2){\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\n            for(const addr in accessList){\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */ static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof network === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof network === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof network.clone === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof network === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network(network.name, network.chainId);\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */ static register(nameOrChainId, networkFunc) {\n        if (typeof nameOrChainId === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while(comps[1].length < decimals){\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request)=>{\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(),\n                fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n            };\n            return feeData;\n        } catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", {\n                request,\n                response,\n                error\n            });\n        }\n    });\n}\n// Used by Optimism for a custom priority fee\nfunction getPriorityFeePlugin(maxPriorityFeePerGas) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(\"data:\", async (fetchFeeData, provider, request)=>{\n        const feeData = await fetchFeeData();\n        // This should always fail\n        if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {\n            return feeData;\n        }\n        // Compute the corrected baseFee to recompute the updated values\n        const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;\n        return {\n            gasPrice: feeData.gasPrice,\n            maxFeePerGas: baseFee + maxPriorityFeePerGas,\n            maxPriorityFeePerGas\n        };\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function() {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin)=>{\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name)=>{\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, {\n        ensNetwork: 1,\n        altNames: [\n            \"homestead\"\n        ]\n    });\n    registerEth(\"ropsten\", 3, {\n        ensNetwork: 3\n    });\n    registerEth(\"rinkeby\", 4, {\n        ensNetwork: 4\n    });\n    registerEth(\"goerli\", 5, {\n        ensNetwork: 5\n    });\n    registerEth(\"kovan\", 42, {\n        ensNetwork: 42\n    });\n    registerEth(\"sepolia\", 11155111, {});\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"bnb\", 56, {\n        ensNetwork: 1\n    });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, {\n        ensNetwork: 1\n    });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\n            \"maticMumbai\",\n            \"maticmum\"\n        ],\n        plugins: [\n            getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: [\n            getPriorityFeePlugin(BigInt(\"1000000\"))\n        ]\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"xdai\", 100, {\n        ensNetwork: 1\n    });\n} //# sourceMappingURL=network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDdUQ7QUFDYztBQUN3QjtBQUM5Rjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxHQUNBLE1BQU1PLFdBQVcsSUFBSUM7QUFDckI7OztDQUdDLEdBQ00sTUFBTUM7SUFDVCxDQUFDQyxJQUFJLENBQUM7SUFDTixDQUFDQyxPQUFPLENBQUM7SUFDVCxDQUFDQyxPQUFPLENBQUM7SUFDVDs7S0FFQyxHQUNEQyxZQUFZSCxJQUFJLEVBQUVDLE9BQU8sQ0FBRTtRQUN2QixJQUFJLENBQUMsQ0FBQ0QsSUFBSSxHQUFHQTtRQUNiLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUdWLDBEQUFTQSxDQUFDVTtRQUMxQixJQUFJLENBQUMsQ0FBQ0MsT0FBTyxHQUFHLElBQUlKO0lBQ3hCO0lBQ0E7O0tBRUMsR0FDRE0sU0FBUztRQUNMLE9BQU87WUFBRUosTUFBTSxJQUFJLENBQUNBLElBQUk7WUFBRUMsU0FBU0ksT0FBTyxJQUFJLENBQUNKLE9BQU87UUFBRTtJQUM1RDtJQUNBOzs7OztLQUtDLEdBQ0QsSUFBSUQsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7SUFBRTtJQUNoQyxJQUFJQSxLQUFLTSxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ04sSUFBSSxHQUFHTTtJQUFPO0lBQ3RDOztLQUVDLEdBQ0QsSUFBSUwsVUFBVTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLE9BQU87SUFBRTtJQUN0QyxJQUFJQSxRQUFRSyxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ0wsT0FBTyxHQUFHViwwREFBU0EsQ0FBQ2UsT0FBTztJQUFZO0lBQ2xFOzs7Ozs7S0FNQyxHQUNEQyxRQUFRQyxLQUFLLEVBQUU7UUFDWCxJQUFJQSxTQUFTLE1BQU07WUFDZixPQUFPO1FBQ1g7UUFDQSxJQUFJ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QUNyQ3pGLFNBQVM7WUFDTDhELG9CQUFvQjtTQUN2QjtJQUNMO0lBQ0F3QixZQUFZLFlBQVksSUFBSTtRQUN4QnRDLFlBQVk7UUFDWmhELFNBQVM7WUFDTG1GLHFCQUFxQnZDLE9BQU87U0FDL0I7SUFDTDtJQUNBMEMsWUFBWSxtQkFBbUIsS0FBSyxDQUFDO0lBQ3JDQSxZQUFZLFFBQVEsS0FBSztRQUFFdEMsWUFBWTtJQUFFO0FBQzdDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvbmV0d29yay5qcz8yY2EzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgKipOZXR3b3JrKiogZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgcmVxdWlyZWQgdG9cbiAqICBpbnRlcmFjdCB3aXRoIGEgc3BlY2lmaWMgY2hhaW4uXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVyczpOZXR3b3JrcyAgW25ldHdvcmtzXVxuICovXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1BsdWdpbiwgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiwgR2FzQ29zdFBsdWdpbiB9IGZyb20gXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiO1xuLyogKiAqICpcbi8vIE5ldHdvcmtzIHdoaWNoIG9wZXJhdGlvbiBhZ2FpbnN0IGFuIEwyIGNhbiB1c2UgdGhpcyBwbHVnaW4gdG9cbi8vIHNwZWNpZnkgaG93IHRvIGFjY2VzcyBMMSwgZm9yIHRoZSBwdXJwb3NlIG9mIHJlc29sdmluZyBFTlMsXG4vLyBmb3IgZXhhbXBsZS5cbmV4cG9ydCBjbGFzcyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSBwcm92aWRlciE6IFByb3ZpZGVyO1xuLy8gQFRPRE86IFJlbmFtZSB0byBDaGFpbkFjY2VzcyBhbmQgYWxsb3cgZm9yIGNvbm5lY3RpbmcgdG8gYW55IGNoYWluXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXI6IFByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLmxheWVyLW9uZS1jb25uZWN0aW9uXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzPExheWVyT25lQ29ubmVjdGlvblBsdWdpbj4odGhpcywgeyBwcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbih0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG59XG4qL1xuY29uc3QgTmV0d29ya3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqICBBICoqTmV0d29yayoqIHByb3ZpZGVzIGFjY2VzcyB0byBhIGNoYWluJ3MgcHJvcGVydGllcyBhbmQgYWxsb3dzXG4gKiAgZm9yIHBsdWctaW5zIHRvIGV4dGVuZCBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29yayB7XG4gICAgI25hbWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3BsdWdpbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrKiogZm9yICUlbmFtZSUlIGFuZCAlJWNoYWluSWQlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjaGFpbklkKSB7XG4gICAgICAgIHRoaXMuI25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KGNoYWluSWQpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIE5ldHdvcmsuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm5hbWUsIGNoYWluSWQ6IFN0cmluZyh0aGlzLmNoYWluSWQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjb21tb24gbmFtZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBjYW5vbmljYWwgbmFtZSwgYXMgbmV0d29ya3MgbWlnaCBoYXZlIG11bHRpcGxlXG4gICAgICogIG5hbWVzLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy4jbmFtZTsgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7IHRoaXMuI25hbWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlLCBcImNoYWluSWRcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBtYXRjaGVzIHRoaXMgbmV0d29yay4gQW55IGNoYWluIElEXG4gICAgICogIG11c3QgbWF0Y2gsIGFuZCBpZiBubyBjaGFpbiBJRCBpcyBwcmVzZW50LCB0aGUgbmFtZSBtdXN0IG1hdGNoLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGRvZXMgbm90IGN1cnJlbnRseSBjaGVjayBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLFxuICAgICAqICBzdWNoIGFzIEVOUyBhZGRyZXNzIG9yIHBsdWctaW4gY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICBtYXRjaGVzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKG90aGVyKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG90aGVyLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIuY2hhaW5JZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiBwbHVnaW5zIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3ICUlcGx1Z2luJSUgdG8gdGhpcyBOZXR3b3JrLiBUaGUgbmV0d29yayBuYW1lXG4gICAgICogIG11c3QgYmUgdW5pcXVlLCBleGNsdWRpbmcgYW55IGZyYWdtZW50LlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY2xvbmUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBwbHVnaW4sIGlmIGFueSwgbWF0Y2hpbmcgJSVuYW1lJSUgZXhhY3RseS4gUGx1Z2luc1xuICAgICAqICB3aXRoIGZyYWdtZW50cyB3aWxsIG5vdCBiZSByZXR1cm5lZCB1bmxlc3MgJSVuYW1lJSUgaW5jbHVkZXNcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyBhIGxpc3Qgb2YgYWxsIHBsdWdpbnMgdGhhdCBtYXRjaCAlJW5hbWUlJSwgd2l0aCBvdHIgd2l0aG91dFxuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbnMoYmFzZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBsdWdpbnMuZmlsdGVyKChwKSA9PiAocC5uYW1lLnNwbGl0KFwiI1wiKVswXSA9PT0gYmFzZW5hbWUpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgTmV0d29yayh0aGlzLm5hbWUsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgIGNsb25lLmF0dGFjaFBsdWdpbihwbHVnaW4uY2xvbmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEEgR2FzQ29zdFBsdWdpbiBjYW4gYmUgYXR0YWNoZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRcbiAgICAgKiAgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbXB1dGVJbnRyaW5zaWNHYXModHgpIHtcbiAgICAgICAgY29uc3QgY29zdHMgPSB0aGlzLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkdhc0Nvc3RcIikgfHwgKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICBsZXQgZ2FzID0gY29zdHMudHhCYXNlO1xuICAgICAgICBpZiAodHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4Q3JlYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHR4LmRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZGF0YS5zdWJzdHJpbmcoaSwgaSArIDIpID09PSBcIjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YVplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhTm9uemVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIGluIGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhBY2Nlc3NMaXN0QWRkcmVzcyArIGNvc3RzLnR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkgKiBhY2Nlc3NMaXN0W2FkZHJdLnN0b3JhZ2VLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBOZXR3b3JrIGZvciB0aGUgJSVuZXR3b3JrJSUgbmFtZSBvciBjaGFpbklkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5ldHdvcmspIHtcbiAgICAgICAgaW5qZWN0Q29tbW9uTmV0d29ya3MoKTtcbiAgICAgICAgLy8gRGVmYXVsdCBuZXR3b3JrXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oXCJtYWlubmV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbm9uaWNhbCBuYW1lIG9yIGNoYWluIElEXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gQmlnSW50KG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtGdW5jID0gTmV0d29ya3MuZ2V0KG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmtGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtGdW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29yayhcInVua25vd25cIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb25hYmxlIHdpdGggbmV0d29yay1saWtlIGFiaWxpdGllc1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IG5ldHdvcmsuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZihuZXR3b3JrLm5hbWUpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZihuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXR3b3JraXNoXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5ldHdvcmsubmFtZSkgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIChuZXR3b3JrLmNoYWluSWQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgbmV0d29yayBvYmplY3QgbmFtZSBvciBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbSA9IG5ldyBOZXR3b3JrKChuZXR3b3JrLm5hbWUpLCAobmV0d29yay5jaGFpbklkKSk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5lbnNBZGRyZXNzIHx8IG5ldHdvcmsuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG5ldHdvcmsuZW5zQWRkcmVzcywgbmV0d29yay5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmICgoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbigoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVnaXN0ZXIgJSVuYW1lT3JDaGFpbklkJSUgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcbiAgICAgKiAgYW4gaW5zdGFuY2Ugb2YgYSBOZXR3b3JrIHJlcHJlc2VudGluZyB0aGF0IGNoYWluLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlcihuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lT3JDaGFpbklkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmFtZU9yQ2hhaW5JZCA9IEJpZ0ludChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZyA9IE5ldHdvcmtzLmdldChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGNvbmZsaWN0aW5nIG5ldHdvcmsgZm9yICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcubmFtZSl9YCwgXCJuYW1lT3JDaGFpbklkXCIsIG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIE5ldHdvcmtzLnNldChuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYyk7XG4gICAgfVxufVxuLy8gV2UgZG9uJ3Qgd2FudCB0byBicmluZyBpbiBmb3JtYXRVbml0cyBiZWNhdXNlIGl0IGlzIGJhY2tlZCBieVxuLy8gRml4ZWROdW1iZXIgYW5kIHdlIHdhbnQgdG8ga2VlcCBOZXR3b3JrcyB0aW55LiBUaGUgdmFsdWVzXG4vLyBpbmNsdWRlZCBieSB0aGUgR2FzIFN0YXRpb25zIGFyZSBhbHNvIElFRUUgNzU0IHdpdGggbG90cyBvZlxuLy8gcm91bmRpbmcgaXNzdWVzIGFuZCBleGNlZWQgdGhlIHN0cmljdCBjaGVja3MgZm9ybWF0VW5pdHMgaGFzLlxuZnVuY3Rpb24gcGFyc2VVbml0cyhfdmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoX3ZhbHVlKTtcbiAgICBpZiAoIXZhbHVlLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIEJyZWFrIGludG8gWyB3aG9sZSwgZnJhY3Rpb24gXVxuICAgIGNvbnN0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29tcHMucHVzaChcIlwiKTtcbiAgICB9XG4gICAgLy8gTW9yZSB0aGFuIDEgZGVjaW1hbCBwb2ludCBvciB0b28gbWFueSBmcmFjdGlvbmFsIHBvc2l0aW9uc1xuICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIHRvIDkgZGVjaW1hbHBsYWNlc1xuICAgIHdoaWxlIChjb21wc1sxXS5sZW5ndGggPCBkZWNpbWFscykge1xuICAgICAgICBjb21wc1sxXSArPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gVG9vIG1hbnkgZGVjaW1hbHMgYW5kIHNvbWUgbm9uLXplcm8gZW5kaW5nLCB0YWtlIHRoZSBjZWlsaW5nXG4gICAgaWYgKGNvbXBzWzFdLmxlbmd0aCA+IDkpIHtcbiAgICAgICAgbGV0IGZyYWMgPSBCaWdJbnQoY29tcHNbMV0uc3Vic3RyaW5nKDAsIDkpKTtcbiAgICAgICAgaWYgKCFjb21wc1sxXS5zdWJzdHJpbmcoOSkubWF0Y2goL14wKyQvKSkge1xuICAgICAgICAgICAgZnJhYysrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBzWzFdID0gZnJhYy50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGNvbXBzWzBdICsgY29tcHNbMV0pO1xufVxuLy8gVXNlZCBieSBQb2x5Z29uIHRvIHVzZSBhIGdhcyBzdGF0aW9uIGZvciBmZWUgZGF0YVxuZnVuY3Rpb24gZ2V0R2FzU3RhdGlvblBsdWdpbih1cmwpIHtcbiAgICByZXR1cm4gbmV3IEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4odXJsLCBhc3luYyAoZmV0Y2hGZWVEYXRhLCBwcm92aWRlciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50IENsb3VkZmxhcmUgZnJvbSBibG9ja2luZyBvdXIgcmVxdWVzdCBpbiBub2RlLmpzXG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiVXNlci1BZ2VudFwiLCBcImV0aGVyc1wiKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW19yZXNwb25zZSwgX2ZlZURhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpLCBmZXRjaEZlZURhdGEoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IF9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXNwb25zZS5ib2R5SnNvbi5zdGFuZGFyZDtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IF9mZWVEYXRhLmdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heEZlZSwgOSksXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhQcmlvcml0eUZlZSwgOSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZlZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCB3aXRoIHBvbHlnb24gZ2FzIHN0YXRpb24gKCR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdC51cmwpfSlgLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gVXNlZCBieSBPcHRpbWlzbSBmb3IgYSBjdXN0b20gcHJpb3JpdHkgZmVlXG5mdW5jdGlvbiBnZXRQcmlvcml0eUZlZVBsdWdpbihtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgIHJldHVybiBuZXcgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbihcImRhdGE6XCIsIGFzeW5jIChmZXRjaEZlZURhdGEsIHByb3ZpZGVyLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBmZXRjaEZlZURhdGEoKTtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYWx3YXlzIGZhaWxcbiAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgfHwgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmVlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb3JyZWN0ZWQgYmFzZUZlZSB0byByZWNvbXB1dGUgdGhlIHVwZGF0ZWQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGJhc2VGZWUgPSBmZWVEYXRhLm1heEZlZVBlckdhcyAtIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnYXNQcmljZTogZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogKGJhc2VGZWUgKyBtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuLy8gU2VlOiBodHRwczovL2NoYWlubGlzdC5vcmdcbmxldCBpbmplY3RlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5qZWN0Q29tbW9uTmV0d29ya3MoKSB7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIC8vLyBSZWdpc3RlciBwb3B1bGFyIEV0aGVyZXVtIG5ldHdvcmtzXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdGgobmFtZSwgY2hhaW5JZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldyBOZXR3b3JrKG5hbWUsIGNoYWluSWQpO1xuICAgICAgICAgICAgLy8gV2UgdXNlIDAgdG8gZGlzYWJsZSBFTlNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obnVsbCwgb3B0aW9ucy5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgICAgIChvcHRpb25zLnBsdWdpbnMgfHwgW10pLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV0d29yayBieSBuYW1lIGFuZCBjaGFpbiBJRFxuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKGNoYWluSWQsIGZ1bmMpO1xuICAgICAgICBpZiAob3B0aW9ucy5hbHROYW1lcykge1xuICAgICAgICAgICAgb3B0aW9ucy5hbHROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRXRoKFwibWFpbm5ldFwiLCAxLCB7IGVuc05ldHdvcms6IDEsIGFsdE5hbWVzOiBbXCJob21lc3RlYWRcIl0gfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyb3BzdGVuXCIsIDMsIHsgZW5zTmV0d29yazogMyB9KTtcbiAgICByZWdpc3RlckV0aChcInJpbmtlYnlcIiwgNCwgeyBlbnNOZXR3b3JrOiA0IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiZ29lcmxpXCIsIDUsIHsgZW5zTmV0d29yazogNSB9KTtcbiAgICByZWdpc3RlckV0aChcImtvdmFuXCIsIDQyLCB7IGVuc05ldHdvcms6IDQyIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwic2Vwb2xpYVwiLCAxMTE1NTExMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY1wiLCA2MSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY0tvdHRpXCIsIDYsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtXCIsIDQyMTYxLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1nb2VybGlcIiwgNDIxNjEzLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xuICAgICAgICBhbHROYW1lczogW1wibWF0aWNNdW1iYWlcIiwgXCJtYXRpY211bVwiXSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldFByaW9yaXR5RmVlUGx1Z2luKEJpZ0ludChcIjEwMDAwMDBcIikpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtLWdvZXJsaVwiLCA0MjAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcInhkYWlcIiwgMTAwLCB7IGVuc05ldHdvcms6IDEgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrLmpzLm1hcCJdLCJuYW1lcyI6WyJhY2Nlc3NMaXN0aWZ5IiwiZ2V0QmlnSW50IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJFbnNQbHVnaW4iLCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIiwiR2FzQ29zdFBsdWdpbiIsIk5ldHdvcmtzIiwiTWFwIiwiTmV0d29yayIsIm5hbWUiLCJjaGFpbklkIiwicGx1Z2lucyIsImNvbnN0cnVjdG9yIiwidG9KU09OIiwiU3RyaW5nIiwidmFsdWUiLCJtYXRjaGVzIiwib3RoZXIiLCJlcnJvciIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImF0dGFjaFBsdWdpbiIsInBsdWdpbiIsImdldCIsIkVycm9yIiwic2V0IiwiY2xvbmUiLCJnZXRQbHVnaW4iLCJnZXRQbHVnaW5zIiwiYmFzZW5hbWUiLCJmaWx0ZXIiLCJwIiwic3BsaXQiLCJmb3JFYWNoIiwiY29tcHV0ZUludHJpbnNpY0dhcyIsInR4IiwiY29zdHMiLCJnYXMiLCJ0eEJhc2UiLCJ0byIsInR4Q3JlYXRlIiwiZGF0YSIsImkiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJ0eERhdGFaZXJvIiwidHhEYXRhTm9uemVybyIsImFjY2Vzc0xpc3QiLCJhZGRyIiwidHhBY2Nlc3NMaXN0QWRkcmVzcyIsInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkiLCJzdG9yYWdlS2V5cyIsIm5ldHdvcmsiLCJpbmplY3RDb21tb25OZXR3b3JrcyIsIkJpZ0ludCIsIm5ldHdvcmtGdW5jIiwiY3VzdG9tIiwiZW5zQWRkcmVzcyIsImVuc05ldHdvcmsiLCJyZWdpc3RlciIsIm5hbWVPckNoYWluSWQiLCJleGlzdGluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZVVuaXRzIiwiX3ZhbHVlIiwiZGVjaW1hbHMiLCJtYXRjaCIsImNvbXBzIiwicHVzaCIsImZyYWMiLCJ0b1N0cmluZyIsImdldEdhc1N0YXRpb25QbHVnaW4iLCJ1cmwiLCJmZXRjaEZlZURhdGEiLCJwcm92aWRlciIsInJlcXVlc3QiLCJzZXRIZWFkZXIiLCJyZXNwb25zZSIsIl9yZXNwb25zZSIsIl9mZWVEYXRhIiwiUHJvbWlzZSIsImFsbCIsInNlbmQiLCJwYXlsb2FkIiwiYm9keUpzb24iLCJzdGFuZGFyZCIsImZlZURhdGEiLCJnYXNQcmljZSIsIm1heEZlZVBlckdhcyIsIm1heEZlZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWUiLCJnZXRQcmlvcml0eUZlZVBsdWdpbiIsImJhc2VGZWUiLCJpbmplY3RlZCIsInJlZ2lzdGVyRXRoIiwib3B0aW9ucyIsImZ1bmMiLCJhbHROYW1lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/network.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: () => (/* binding */ EnsPlugin),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* binding */ FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* binding */ FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* binding */ GasCostPlugin),\n/* harmony export */   NetworkPlugin: () => (/* binding */ NetworkPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */ class NetworkPlugin {\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */ constructor(name){\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */ clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */ class GasCostPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */ constructor(effectiveBlock, costs){\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);\n        const props = {\n            effectiveBlock\n        };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof value === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */ class EnsPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */ constructor(address, targetNetwork){\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: address || EnsAddress,\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */ class FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */ get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */ constructor(feeDataFunc){\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */ async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */ get url() {\n        return this.#url;\n    }\n    /**\n     *  The callback to use when computing the FeeData.\n     */ get processFunc() {\n        return this.#processFunc;\n    }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */ constructor(url, processFunc){\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() {\n        return this;\n    }\n} /*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/  //# sourceMappingURL=plugins-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUNQO0FBQ25ELE1BQU1FLGFBQWE7QUFDbkI7O0NBRUMsR0FDTSxNQUFNQztJQVFUOztLQUVDLEdBQ0RDLFlBQVlDLElBQUksQ0FBRTtRQUNkTCxzRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVLO1FBQUs7SUFDbEM7SUFDQTs7S0FFQyxHQUNEQyxRQUFRO1FBQ0osT0FBTyxJQUFJSCxjQUFjLElBQUksQ0FBQ0UsSUFBSTtJQUN0QztBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUUsc0JBQXNCSjtJQWdDL0I7Ozs7S0FJQyxHQUNEQyxZQUFZSSxjQUFjLEVBQUVDLEtBQUssQ0FBRTtRQUMvQixJQUFJRCxrQkFBa0IsTUFBTTtZQUN4QkEsaUJBQWlCO1FBQ3JCO1FBQ0EsS0FBSyxDQUFDLENBQUMsbUNBQW1DLEVBQUdBLGtCQUFrQixFQUFHLENBQUM7UUFDbkUsTUFBTUUsUUFBUTtZQUFFRjtRQUFlO1FBQy9CLFNBQVNHLElBQUlOLElBQUksRUFBRU8sT0FBTztZQUN0QixJQUFJQyxRQUFRLENBQUNKLFNBQVMsQ0FBQyxFQUFFLENBQUNKLEtBQUs7WUFDL0IsSUFBSVEsU0FBUyxNQUFNO2dCQUNmQSxRQUFRRDtZQUNaO1lBQ0FYLCtEQUFjQSxDQUFDLE9BQVFZLFVBQVcsVUFBVSxDQUFDLGtCQUFrQixFQUFFUixLQUFLLENBQUMsRUFBRSxTQUFTSTtZQUNsRkMsS0FBSyxDQUFDTCxLQUFLLEdBQUdRO1FBQ2xCO1FBQ0FGLElBQUksVUFBVTtRQUNkQSxJQUFJLFlBQVk7UUFDaEJBLElBQUksY0FBYztRQUNsQkEsSUFBSSxpQkFBaUI7UUFDckJBLElBQUksMEJBQTBCO1FBQzlCQSxJQUFJLHVCQUF1QjtRQUMzQlgsc0VBQWdCQSxDQUFDLElBQUksRUFBRVU7SUFDM0I7SUFDQUosUUFBUTtRQUNKLE9BQU8sSUFBSUMsY0FBYyxJQUFJLENBQUNDLGNBQWMsRUFBRSxJQUFJO0lBQ3REO0FBQ0o7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1NLGtCQUFrQlg7SUFTM0I7Ozs7S0FJQyxHQUNEQyxZQUFZVyxPQUFPLEVBQUVDLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUM7UUFDTmhCLHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJlLFNBQVVBLFdBQVdiO1lBQ3JCYyxlQUFnQixpQkFBa0IsT0FBUSxJQUFJQTtRQUNsRDtJQUNKO0lBQ0FWLFFBQVE7UUFDSixPQUFPLElBQUlRLFVBQVUsSUFBSSxDQUFDQyxPQUFPLEVBQUUsSUFBSSxDQUFDQyxhQUFhO0lBQ3pEO0FBQ0o7QUFDQTs7Ozs7O0NBTUMsR0FDTSxNQUFNQyw2QkFBNkJkO0lBQ3RDLENBQUNlLFdBQVcsQ0FBQztJQUNiOztLQUVDLEdBQ0QsSUFBSUEsY0FBYztRQUNkLE9BQU8sSUFBSSxDQUFDLENBQUNBLFdBQVc7SUFDNUI7SUFDQTs7S0FFQyxHQUNEZCxZQUFZYyxXQUFXLENBQUU7UUFDckIsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7SUFDeEI7SUFDQTs7S0FFQyxHQUNELE1BQU1DLFdBQVdDLFFBQVEsRUFBRTtRQUN2QixPQUFPLE1BQU0sSUFBSSxDQUFDLENBQUNGLFdBQVcsQ0FBQ0U7SUFDbkM7SUFDQWQsUUFBUTtRQUNKLE9BQU8sSUFBSVcscUJBQXFCLElBQUksQ0FBQyxDQUFDQyxXQUFXO0lBQ3JEO0FBQ0o7QUFDTyxNQUFNRyxxQ0FBcUNsQjtJQUM5QyxDQUFDbUIsR0FBRyxDQUFDO0lBQ0wsQ0FBQ0MsV0FBVyxDQUFDO0lBQ2I7O0tBRUMsR0FDRCxJQUFJRCxNQUFNO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsR0FBRztJQUFFO0lBQzlCOztLQUVDLEdBQ0QsSUFBSUMsY0FBYztRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLFdBQVc7SUFBRTtJQUM5Qzs7O0tBR0MsR0FDRG5CLFlBQVlrQixHQUFHLEVBQUVDLFdBQVcsQ0FBRTtRQUMxQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUMsQ0FBQ0QsR0FBRyxHQUFHQTtRQUNaLElBQUksQ0FBQyxDQUFDQyxXQUFXLEdBQUdBO0lBQ3hCO0lBQ0EscURBQXFEO0lBQ3JEakIsUUFBUTtRQUFFLE9BQU8sSUFBSTtJQUFFO0FBQzNCLEVBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLElBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzPzg3NWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgRW5zQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCI7XG4vKipcbiAqICBBICoqTmV0d29ya1BsdWdpbioqIHByb3ZpZGVzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBvbiBhIFtbTmV0d29ya11dLlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHJldmVyc2UtZG9tYWluLW5vdGF0aW9uLCB3aGljaCBwZXJtaXRzXG4gICAgICogIHVuaXF1ZSBuYW1lcyB3aXRoIGEga25vd24gYXV0aG9yaXR5IGFzIHdlbGwgYXMgaGllcmFyY2hhbCBlbnRyaWVzLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtQbHVnaW4odGhpcy5uYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqR2FzQ29zdFBsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbHRlcm5hdGl2ZSB2YWx1ZXMgd2hlblxuICogIGNvbXB1dGluZyB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEdhc0Nvc3RQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciB0byB0cmVhdCB0aGVzZSB2YWx1ZXMgYXMgdmFsaWQgZnJvbS5cbiAgICAgKlxuICAgICAqICBUaGlzIGFsbG93cyBhIGhhcmRmb3JrIHRvIGhhdmUgdXBkYXRlZCB2YWx1ZXMgaW5jbHVkZWQgYXMgd2VsbCBhc1xuICAgICAqICBtdWx1dGlwbGUgaGFyZGZvcmtzIHRvIGJlIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBlZmZlY3RpdmVCbG9jaztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9ucyBiYXNlIGZlZS5cbiAgICAgKi9cbiAgICB0eEJhc2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZm9yIGNyZWF0aW5nIGEgbmV3IGFjY291bnQuXG4gICAgICovXG4gICAgdHhDcmVhdGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFaZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBub24temVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YU5vbnplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHN0b3JhZ2Uga2V5IGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBhZGRyZXNzIGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEdhc0Nvc3RQbHVnaW4gZnJvbSAlJWVmZmVjdGl2ZUJsb2NrJSUgdW50aWwgdGhlXG4gICAgICogIGxhdGVzdCBibG9jayBvciBhbm90aGVyIEdhc0Nvc3RQbHVnaW4gc3VwZXJjZWRlcyB0aGF0IGJsb2NrIG51bWJlcixcbiAgICAgKiAgd2l0aCB0aGUgYXNzb2NpYXRlZCAlJWNvc3RzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWZmZWN0aXZlQmxvY2ssIGNvc3RzKSB7XG4gICAgICAgIGlmIChlZmZlY3RpdmVCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBlZmZlY3RpdmVCbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYG9yZy5ldGhlcnMubmV0d29yay5wbHVnaW5zLkdhc0Nvc3QjJHsoZWZmZWN0aXZlQmxvY2sgfHwgMCl9YCk7XG4gICAgICAgIGNvbnN0IHByb3BzID0geyBlZmZlY3RpdmVCbG9jayB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQobmFtZSwgbnVsbGlzaCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGNvc3RzIHx8IHt9KVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsaXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIsIGBpbnZhbHVkIHZhbHVlIGZvciAke25hbWV9YCwgXCJjb3N0c1wiLCBjb3N0cyk7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldChcInR4QmFzZVwiLCAyMTAwMCk7XG4gICAgICAgIHNldChcInR4Q3JlYXRlXCIsIDMyMDAwKTtcbiAgICAgICAgc2V0KFwidHhEYXRhWmVyb1wiLCA0KTtcbiAgICAgICAgc2V0KFwidHhEYXRhTm9uemVyb1wiLCAxNik7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXlcIiwgMTkwMCk7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdEFkZHJlc3NcIiwgMjQwMCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcHMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXNDb3N0UGx1Z2luKHRoaXMuZWZmZWN0aXZlQmxvY2ssIHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcbiAqICBjb250cmFjdC5cbiAqXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcbiAqICBpbiBnZW5lcmFsLCB0aGUgbWFpbm5ldCBpbnN0YW5jZSBzdXBwb3J0cyBtdWx0aS1jaGFpbiBhZGRyZXNzZXMgYW5kXG4gKiAgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEVOUyBSZWdpc3RydHkgQ29udHJhY3QgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhhdCB0aGUgRU5TIGNvbnRyYWN0IGxpdmVzIG9uLlxuICAgICAqL1xuICAgIHRhcmdldE5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFbnNQbHVnaW4qKiBjb25uZWN0ZWQgdG8gJSVhZGRyZXNzJSUgb24gdGhlXG4gICAgICogICUldGFyZ2V0TmV0d29yayUlLiBUaGUgZGVmYXVsdCBFTlMgYWRkcmVzcyBhbmQgbWFpbm5ldCBpcyB1c2VkXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHRhcmdldE5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWRkcmVzczogKGFkZHJlc3MgfHwgRW5zQWRkcmVzcyksXG4gICAgICAgICAgICB0YXJnZXROZXR3b3JrOiAoKHRhcmdldE5ldHdvcmsgPT0gbnVsbCkgPyAxIDogdGFyZ2V0TmV0d29yaylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVuc1BsdWdpbih0aGlzLmFkZHJlc3MsIHRoaXMudGFyZ2V0TmV0d29yayk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFuZCBhbHRlcm5hdGVcbiAqICBtZWFucyB0byBzcGVjaWZ5IGl0cyBmZWUgZGF0YS5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgbmV0d29yayB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFtbbGluay1laXAtMTU1OV1dIG1heVxuICogIGNob29zZSB0byB1c2UgYSBHYXMgU3RhdGlvbiBzaXRlIHRvIGFwcHJveGltYXRlIHRoZSBnYXMgcHJpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICNmZWVEYXRhRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcbiAgICAgICAgdGhpcy4jZmVlRGF0YUZ1bmMgPSBmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBmZWUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZWVEYXRhRnVuYyhwcm92aWRlcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZURhdGFOZXR3b3JrUGx1Z2luKHRoaXMuI2ZlZURhdGFGdW5jKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICN1cmw7XG4gICAgI3Byb2Nlc3NGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgVVJMIHRvIGluaXRpYWxpemUgdGhlIEZldGNoUmVxdWVzdCB3aXRoIGluICUlcHJvY2Vzc0Z1bmMlJS5cbiAgICAgKi9cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjYWxsYmFjayB0byB1c2Ugd2hlbiBjb21wdXRpbmcgdGhlIEZlZURhdGEuXG4gICAgICovXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkgeyByZXR1cm4gdGhpcy4jcHJvY2Vzc0Z1bmM7IH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiB3aGljaCB3aWxsXG4gICAgICogIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIGZlZSBkYXRhIGZvciB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NGdW5jID0gcHJvY2Vzc0Z1bmM7XG4gICAgfVxuICAgIC8vIFdlIGFyZSBpbW11dGFibGUsIHNvIHdlIGNhbiBzZXJ2ZSBhcyBvdXIgb3duIGNsb25lXG4gICAgY2xvbmUoKSB7IHJldHVybiB0aGlzOyB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcbiAgICAgICAgdGhpcy4jYmxvY2tGdW5jID0gYmxvY2tGdW5jO1xuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcbiAgICB9XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiYXNzZXJ0QXJndW1lbnQiLCJFbnNBZGRyZXNzIiwiTmV0d29ya1BsdWdpbiIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsb25lIiwiR2FzQ29zdFBsdWdpbiIsImVmZmVjdGl2ZUJsb2NrIiwiY29zdHMiLCJwcm9wcyIsInNldCIsIm51bGxpc2giLCJ2YWx1ZSIsIkVuc1BsdWdpbiIsImFkZHJlc3MiLCJ0YXJnZXROZXR3b3JrIiwiRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJmZWVEYXRhRnVuYyIsImdldEZlZURhdGEiLCJwcm92aWRlciIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJ1cmwiLCJwcm9jZXNzRnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/plugins-network.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: () => (/* binding */ JsonRpcApiPollingProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* binding */ JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstract-provider.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./network.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */ // @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof value.getAddress === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(deepCopy);\n    }\n    if (typeof value === \"object\") {\n        return Object.keys(value).reduce((accum, key)=>{\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof value})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: 1 << 20,\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    constructor(provider, address){\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            address\n        });\n    }\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async ()=>{\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async ()=>{\n                tx.gasLimit = await this.provider.estimateGas({\n                    ...tx,\n                    from: this.address\n                });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async ()=>{\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [\n            hexTx\n        ]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await new Promise((resolve, reject)=>{\n            const timeouts = [\n                1000,\n                100\n            ];\n            const checkTx = async ()=>{\n                // Try getting the transaction\n                const tx = await this.provider.getTransaction(hash);\n                if (tx != null) {\n                    resolve(tx.replaceableTransaction(blockNumber));\n                    return;\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(()=>{\n                    checkTx();\n                }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        });\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [\n            hexTx\n        ]);\n    }\n    async signMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message),\n            this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, async (value)=>{\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(),\n            password,\n            null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */ class JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no hard in sending it immeidately\n        const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(()=>{\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while(payloads.length){\n                // Create payload batches that satisfy our batch constraints\n                const batch = [\n                    payloads.shift()\n                ];\n                while(payloads.length){\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push(payloads.shift());\n                    const bytes = JSON.stringify(batch.map((p)=>p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(batch.pop());\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async ()=>{\n                    const payload = batch.length === 1 ? batch[0].payload : batch.map((p)=>p.payload);\n                    this.emit(\"debug\", {\n                        action: \"sendRpcPayload\",\n                        payload\n                    });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcResult\",\n                            result\n                        });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch){\n                            if (this.destroyed) {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                                    operation: payload.method\n                                }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r)=>r.id === payload.id)[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result,\n                                    info: {\n                                        payload\n                                    }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    } catch (error) {\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcError\",\n                            error\n                        });\n                        for (const { reject } of batch){\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options){\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve)=>{\n                resolve = _resolve;\n            });\n            this.#notReady = {\n                promise,\n                resolve\n            };\n        }\n        // Make sure any static network is compatbile with the provided netwrok\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (staticNetwork) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */ _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */ get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */ async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, {\n                                type: undefined\n                            })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */ async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            return network;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            return _network_js__WEBPACK_IMPORTED_MODULE_10__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(await this.send(\"eth_chainId\", [])));\n        }\n        // We are not ready yet; use the primitive _send\n        const payload = {\n            id: this.#nextId++,\n            method: \"eth_chainId\",\n            params: [],\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"sendRpcPayload\",\n            payload\n        });\n        let result;\n        try {\n            result = (await this._send(payload))[0];\n        } catch (error) {\n            this.emit(\"debug\", {\n                action: \"receiveRpcError\",\n                error\n            });\n            throw error;\n        }\n        this.emit(\"debug\", {\n            action: \"receiveRpcResult\",\n            result\n        });\n        if (\"result\" in result) {\n            return _network_js__WEBPACK_IMPORTED_MODULE_10__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(result.result));\n        }\n        throw this.getRpcError(payload, result);\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */ _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async ()=>{\n            // Bootstrap the network\n            while(this.#network == null && !this.destroyed){\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                        event: \"initial-network-discovery\",\n                        info: {\n                            error\n                        }\n                    }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */ async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */ _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */ get ready() {\n        return this.#notReady == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */ getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_13__.accessListify)(tx.accessList);\n        }\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */ getRpcRequest(req) {\n        switch(req.method){\n            case \"chainId\":\n                return {\n                    method: \"eth_chainId\",\n                    args: []\n                };\n            case \"getBlockNumber\":\n                return {\n                    method: \"eth_blockNumber\",\n                    args: []\n                };\n            case \"getGasPrice\":\n                return {\n                    method: \"eth_gasPrice\",\n                    args: []\n                };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        \"0x\" + req.position.toString(16),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [\n                        req.signedTransaction\n                    ]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [\n                            req.blockTag,\n                            !!req.includeTransactions\n                        ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [\n                            req.blockHash,\n                            !!req.includeTransactions\n                        ]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [\n                        this.getRpcTransaction(req.transaction),\n                        req.blockTag\n                    ]\n                };\n            case \"estimateGas\":\n                {\n                    return {\n                        method: \"eth_estimateGas\",\n                        args: [\n                            this.getRpcTransaction(req.transaction)\n                        ]\n                    };\n                }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return {\n                    method: \"eth_getLogs\",\n                    args: [\n                        req.filter\n                    ]\n                };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */ getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_14__.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n            e.info = {\n                error,\n                payload\n            };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\"\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: actionMap[method] || \"unknown\",\n                reason: \"rejected\",\n                info: {\n                    payload,\n                    error\n                }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = payload.params[0];\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method,\n                    info: {\n                        transaction,\n                        info: {\n                            error\n                        }\n                    }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method,\n                info: {\n                    error,\n                    payload\n                }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n            error,\n            payload\n        });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */ send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: method\n            }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject)=>{\n            this.#payloads.push({\n                resolve,\n                reject,\n                payload: {\n                    method,\n                    params,\n                    id,\n                    jsonrpc: \"2.0\"\n                }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */ async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof address === \"number\") {\n            const accounts = await accountsPromise;\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        for (const account of accounts){\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a)=>new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads){\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n            }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */ class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options){\n        super(network, options);\n        this.#pollingInterval = 4000;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */ get pollingInterval() {\n        return this.#pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub)=>{\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */ class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options){\n        if (url == null) {\n            url = \"http://localhost:8545\";\n        }\n        super(network, options);\n        if (typeof url === \"string\") {\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_15__.FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [\n                resp\n            ];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(value.data)) {\n        return {\n            message: value.message,\n            data: value.data\n        };\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) {}\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) {}\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n} //# sourceMappingURL=provider-jsonrpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1qc29ucnBjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVM7QUFDVCx5QkFBeUI7QUFDekIseVFBQXlRO0FBQzlOO0FBQ3NCO0FBQ2I7QUFDSTtBQUMySDtBQUNwRztBQUN6QjtBQUNmO0FBQ3VEO0FBQzdCO0FBQ2pFLE1BQU11QixZQUFZLCtDQUErQ0MsS0FBSyxDQUFDO0FBQ3ZFLGdEQUFnRDtBQUNoRCxTQUFTQyxTQUFTQyxLQUFLO0lBQ25CLElBQUlBLFNBQVMsUUFBUUgsVUFBVUksT0FBTyxDQUFDLE9BQVFELFVBQVcsR0FBRztRQUN6RCxPQUFPQTtJQUNYO0lBQ0EsdUJBQXVCO0lBQ3ZCLElBQUksT0FBUUEsTUFBTXpCLFVBQVUsS0FBTSxZQUFZO1FBQzFDLE9BQU95QjtJQUNYO0lBQ0EsSUFBSUUsTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1FBQ3RCLE9BQVFBLE1BQU1JLEdBQUcsQ0FBQ0w7SUFDdEI7SUFDQSxJQUFJLE9BQVFDLFVBQVcsVUFBVTtRQUM3QixPQUFPSyxPQUFPQyxJQUFJLENBQUNOLE9BQU9PLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztZQUNyQ0QsS0FBSyxDQUFDQyxJQUFJLEdBQUdULEtBQUssQ0FBQ1MsSUFBSTtZQUN2QixPQUFPRDtRQUNYLEdBQUcsQ0FBQztJQUNSO0lBQ0EsTUFBTSxJQUFJRSxNQUFNLENBQUMsbUJBQW1CLEVBQUVWLE1BQU0sRUFBRSxFQUFFLE9BQVFBLE1BQU8sQ0FBQyxDQUFDO0FBQ3JFO0FBQ0EsU0FBU1csTUFBTUMsUUFBUTtJQUNuQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0M7UUFBY0MsV0FBV0QsU0FBU0Y7SUFBVztBQUNyRTtBQUNBLFNBQVNJLGFBQWFoQixLQUFLO0lBQ3ZCLElBQUlBLE9BQU87UUFDUCxPQUFPQSxNQUFNaUIsV0FB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LGdCQUFnQnJILEtBQUtvSCxLQUFLLENBQUM1TCxRQUFRZ0c7UUFDOUMsRUFDQSxPQUFPUSxPQUFPLENBQUU7SUFDcEI7QUFDSjtBQUNBLFNBQVNnRCxlQUFleEosS0FBSztJQUN6QixNQUFNZ0csU0FBUyxFQUFFO0lBQ2pCNkYsZ0JBQWdCN0wsT0FBT2dHO0lBQ3ZCLE9BQU9BO0FBQ1gsRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1qc29ucnBjLmpzPzMyYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgT25lIG9mIHRoZSBtb3N0IGNvbW1vbiB3YXlzIHRvIGludGVyYWN0IHdpdGggdGhlIGJsb2NrY2hhaW4gaXNcbiAqICBieSBhIG5vZGUgcnVubmluZyBhIEpTT04tUlBDIGludGVyZmFjZSB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHRvLFxuICogIGJhc2VkIG9uIHRoZSB0cmFuc3BvcnQsIHVzaW5nOlxuICpcbiAqICAtIEhUVFAgb3IgSFRUUFMgLSBbW0pzb25ScGNQcm92aWRlcl1dXG4gKiAgLSBXZWJTb2NrZXQgLSBbW1dlYlNvY2tldFByb3ZpZGVyXV1cbiAqICAtIElQQyAtIFtbSXBjU29ja2V0UHJvdmlkZXJdXVxuICpcbiAqIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9qc29ucnBjOkpTT04tUlBDIFByb3ZpZGVyICBbYWJvdXQtanNvbnJwY1Byb3ZpZGVyXVxuICovXG4vLyBAVE9ETzpcbi8vIC0gQWRkIHRoZSBiYXRjaGluZyBBUElcbi8vIGh0dHBzOi8vcGxheWdyb3VuZC5vcGVuLXJwYy5vcmcvP3NjaGVtYVVybD1odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXRoZXJldW0vZXRoMS4wLWFwaXMvYXNzZW1ibGVkLXNwZWMvb3BlbnJwYy5qc29uJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6c3BsaXRWaWV3JTVEPXRydWUmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTppbnB1dCU1RD1mYWxzZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmV4YW1wbGVzRHJvcGRvd24lNUQ9ZmFsc2VcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b1F1YW50aXR5LCB0b1V0ZjhCeXRlcywgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFByb3ZpZGVyLCBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0U2lnbmVyIH0gZnJvbSBcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgRmlsdGVySWRFdmVudFN1YnNjcmliZXIsIEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG5jb25zdCBQcmltaXRpdmUgPSBcImJpZ2ludCxib29sZWFuLGZ1bmN0aW9uLG51bWJlcixzdHJpbmcsc3ltYm9sXCIuc3BsaXQoLywvZyk7XG4vL2NvbnN0IE1ldGhvZHMgPSBcImdldEFkZHJlc3MsdGhlblwiLnNwbGl0KC8sL2cpO1xuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBQcmltaXRpdmUuaW5kZXhPZih0eXBlb2YgKHZhbHVlKSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIEtlZXAgYW55IEFkZHJlc3NhYmxlXG4gICAgaWYgKHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlLm1hcChkZWVwQ29weSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgc2hvdWxkIG5vdCBoYXBwZW46ICR7dmFsdWV9ICgke3R5cGVvZiAodmFsdWUpfSlgKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNQb2xsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5wb2xsaW5nSW50ZXJ2YWwpID09PSBcIm51bWJlclwiKTtcbn1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHBvbGxpbmc6IGZhbHNlLFxuICAgIHN0YXRpY05ldHdvcms6IG51bGwsXG4gICAgYmF0Y2hTdGFsbFRpbWU6IDEwLFxuICAgIGJhdGNoTWF4U2l6ZTogKDEgPDwgMjApLFxuICAgIGJhdGNoTWF4Q291bnQ6IDEwMCxcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vLyBAVE9ETzogVW5jaGVja2VkIFNpZ25lcnNcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIGFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCByZWNvbm5lY3QgSnNvblJwY1NpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgICB9XG4gICAgLy8gSlNPTi1SUEMgd2lsbCBhdXRvbWF0aWFsbHkgZmlsbCBpbiBub25jZSwgZXRjLiBzbyB3ZSBqdXN0IGNoZWNrIGZyb21cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMganVzdCB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgc2VudCwgd2hpY2ggaXMgd2hhdFxuICAgIC8vIHRoZSBiYXJlIEpTT04tUlBDIEFQSSBkb2VzO1xuICAgIGFzeW5jIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBfZnJvbSA9IHR4LmZyb207XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF9mcm9tLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xuICAgICAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHsgLi4udHgsIGZyb206IHRoaXMuYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBhZGRyZXNzIG1heSBiZSBhbiBFTlMgbmFtZSBvciBBZGRyZXNzYWJsZVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgX3RvID0gdHgudG87XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHgudG8gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhfdG8sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCB1bnRpbCBhbGwgb2Ygb3VyIHByb3BlcnRpZXMgYXJlIGZpbGxlZCBpblxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dHMgPSBbMTAwMCwgMTAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYW5vdGhlciA0IHNlY29uZHNcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9zZXRUaW1lb3V0KCgpID0+IHsgY2hlY2tUeCgpOyB9LCB0aW1lb3V0cy5wb3AoKSB8fCA0MDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja1R4KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW1xuICAgICAgICAgICAgaGV4bGlmeShtZXNzYWdlKSwgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENvcHkoX3ZhbHVlKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzICE9IG51bGwsIFwiVHlwZWREYXRhIGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhZGRyZXNzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShUeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyB1bmxvY2socGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG4gICAgYXN5bmMgX2xlZ2FjeVNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KG1lc3NhZ2UpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbi8qKlxuICogIFRoZSBKc29uUnBjQXBpUHJvdmlkZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kICoqTVVTVCoqIGJlXG4gKiAgc3ViLWNsYXNzZWQuXG4gKlxuICogIEl0IHByb3ZpZGVzIHRoZSBiYXNlIGZvciBhbGwgSlNPTi1SUEMtYmFzZWQgUHJvdmlkZXIgaW50ZXJhY3Rpb24uXG4gKlxuICogIFN1Yi1jbGFzc2luZyBOb3RlczpcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1Qgb3ZlcnJpZGUgX3NlbmRcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1QgY2FsbCB0aGUgYF9zdGFydCgpYCBtZXRob2Qgb25jZSBjb25uZWN0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQcm92aWRlciBleHRlbmRzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNvcHRpb25zO1xuICAgIC8vIFRoZSBuZXh0IElEIHRvIHVzZSBmb3IgdGhlIEpTT04tUlBDIElEIGZpZWxkXG4gICAgI25leHRJZDtcbiAgICAvLyBQYXlsb2FkcyBhcmUgcXVldWVkIGFuZCB0cmlnZ2VyZWQgaW4gYmF0Y2hlcyB1c2luZyB0aGUgZHJhaW5UaW1lclxuICAgICNwYXlsb2FkcztcbiAgICAjZHJhaW5UaW1lcjtcbiAgICAjbm90UmVhZHk7XG4gICAgI25ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJkIGluIHNlbmRpbmcgaXQgaW1tZWlkYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI25vdFJlYWR5ID0geyBwcm9taXNlLCByZXNvbHZlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBzdGF0aWMgbmV0d29yayBpcyBjb21wYXRiaWxlIHdpdGggdGhlIHByb3ZpZGVkIG5ldHdyb2tcbiAgICAgICAgY29uc3Qgc3RhdGljTmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmIChzdGF0aWNOZXR3b3JrKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChuZXR3b3JrID09IG51bGwgfHwgc3RhdGljTmV0d29yay5tYXRjaGVzKG5ldHdvcmspLCBcInN0YXRpY05ldHdvcmsgTVVTVCBtYXRjaCBuZXR3b3JrIG9iamVjdFwiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gc3RhdGljTmV0d29yaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcHRpb24gJSVrZXklJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBjYW4gdXNlIHRoaXMgdG8gaW5xdWlyZSBhYm91dCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgX2dldE9wdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnNba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgdGhlIFtbTmV0d29ya11dIHRoaXMgcHJvdmlkZXIgaGFzIGNvbW1pdHRlZCB0by4gT24gZWFjaCBjYWxsLCB0aGUgbmV0d29ya1xuICAgICAqICBpcyBkZXRlY3RlZCwgYW5kIGlmIGl0IGhhcyBjaGFuZ2VkLCB0aGUgY2FsbCB3aWxsIHJlamVjdC5cbiAgICAgKi9cbiAgICBnZXQgX25ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNuZXR3b3JrLCBcIm5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZSB5ZXRcIiwgXCJORVRXT1JLX0VSUk9SXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBub24tbm9ybWFsaXplZCB2YWx1ZSBieSBwZXJmb3JtaW5nICUlcmVxJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IGJlaGF2aW9yIG9mIGFjdGlvbnMsXG4gICAgICogIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGNhbGwgYGBzdXBlci5fcGVyZm9ybWBgIGFzIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImNhbGxcIiB8fCByZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGxldCB0eCA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgZ2V0QmlnSW50KHR4LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIG5vbi1FSVAtYTU1OVxuICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBPYmplY3QuYXNzaWduKHt9LCByZXEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgdHlwZTogdW5kZWZpbmVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRScGNSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpczsgaXQgZGV0ZWN0cyB0aGUgKmFjdHVhbCogbmV0d29yayB0aGF0XG4gICAgICogIHdlIGFyZSAqKmN1cnJlbnRseSoqIGNvbm5lY3RlZCB0by5cbiAgICAgKlxuICAgICAqICBLZWVwIGluIG1pbmQgdGhhdCBbW3NlbmRdXSBtYXkgb25seSBiZSB1c2VkIG9uY2UgW1tyZWFkeV1dLCBvdGhlcndpc2UgdGhlXG4gICAgICogIF9zZW5kIHByaW1pdGl2ZSBtdXN0IGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmIChuZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgcmVhZHksIHVzZSBgYHNlbmRgYCwgd2hpY2ggZW5hYmxlZCByZXF1ZXN0cyB0byBiZSBiYXRjaGVkXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChhd2FpdCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNuZXh0SWQrKywgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIHBhcmFtczogW10sIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKk1VU1QqKiBjYWxsIHRoaXMuIFVudGlsIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjYWxsc1xuICAgICAqICB3aWxsIGJlIHBhc3NlZCB0byBbW19zZW5kXV0gZnJvbSBbW3NlbmRdXS4gSWYgaXQgaXMgb3ZlcnJpZGRlbiwgdGhlblxuICAgICAqICBgYHN1cGVyLl9zdGFydCgpYGAgKipNVVNUKiogYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogIENhbGxpbmcgaXQgbXVsdGlwbGUgdGltZXMgaXMgc2FmZSBhbmQgaGFzIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsIHx8IHRoaXMuI25vdFJlYWR5LnJlc29sdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI25vdFJlYWR5LnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy4jbm90UmVhZHkgPSBudWxsO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHRoZSBuZXR3b3JrXG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jbmV0d29yayA9PSBudWxsICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBhd2FpdCB0aGlzLl9kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSnNvblJwY1Byb3ZpZGVyIGZhaWxlZCB0byBkZXRlY3QgbmV0d29yayBhbmQgY2Fubm90IHN0YXJ0IHVwOyByZXRyeSBpbiAxcyAocGVyaGFwcyB0aGUgVVJMIGlzIHdyb25nIG9yIHRoZSBub2RlIGlzIG5vdCBzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGJvb3RzdHJhcCBuZXR3b3JrIGRldGVjdGlvblwiLCBcIk5FVFdPUktfRVJST1JcIiwgeyBldmVudDogXCJpbml0aWFsLW5ldHdvcmstZGlzY292ZXJ5XCIsIGluZm86IHsgZXJyb3IgfSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGRpc3BhdGNoaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC4gVGhpcyBjYW4gYmUgdXNlZCBpblxuICAgICAqICBzdWItY2xhc3NlcyB0byBkZWZlciBzZW5kaW5nIGRhdGEgdW50aWwgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICAgKiAgZXN0YWJsaXNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3dhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNub3RSZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgU3Vic2NyaWJlciB0aGF0IHdpbGwgbWFuYWdlIHRoZSAlJXN1YiUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgKiAgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIC8vIFBlbmRpbmcgRmlsdGVycyBhcmVuJ3QgYXZhaWxibGUgdmlhIHBvbGxpbmdcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0T3B0aW9uKFwicG9sbGluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsdGVySWRFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3JwaGFuZWQgTG9ncyBhcmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5LCBieSB0aGUgZmlsdGVyLCBzaW5jZVxuICAgICAgICAvLyBsb2dzIHdpdGggcmVtb3ZlZCBhcmUgZW1pdHRlZCBieSBpdFxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwib3JwaGFuXCIgJiYgc3ViLmZpbHRlci5vcnBoYW4gPT09IFwiZHJvcC1sb2dcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKFwib3JwaGFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0U3Vic2NyaWJlcihzdWIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqL1xuICAgIGdldCByZWFkeSgpIHsgcmV0dXJuIHRoaXMuI25vdFJlYWR5ID09IG51bGw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyAlJXR4JSUgYXMgYSBub3JtYWxpemVkIEpTT04tUlBDIHRyYW5zYWN0aW9uIHJlcXVlc3QsXG4gICAgICogIHdoaWNoIGhhcyBhbGwgdmFsdWVzIGhleGxpZmllZCBhbmQgYW55IG51bWVyaWMgdmFsdWVzIGNvbnZlcnRlZFxuICAgICAqICB0byBRdWFudGl0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0UnBjVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG4gICAgICAgICAgICAgICAgZHN0S2V5ID0gXCJnYXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtkc3RLZXldID0gdG9RdWFudGl0eShnZXRCaWdJbnQodHhba2V5XSwgYHR4LiR7a2V5fWApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhZGRyZXNzZXMgYW5kIGRhdGEgYXJlIGxvd2VyY2FzZVxuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaGV4bGlmeSh0eFtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYWNjZXNzIGxpc3Qgb2JqZWN0XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhY2Nlc3NMaXN0XCJdID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcmVxdWVzdCBtZXRob2QgYW5kIGFyZ3VtZW50cyByZXF1aXJlZCB0byBwZXJmb3JtXG4gICAgICogICUlcmVxJSUuXG4gICAgICovXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9ibG9ja051bWJlclwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nYXNQcmljZVwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiMHhcIiArIHJlcS5wb3NpdGlvbi50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5zaWduZWRUcmFuc2FjdGlvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja1RhZywgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJibG9ja0hhc2hcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tIYXNoLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9lc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChyZXEuZmlsdGVyICYmIHJlcS5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcS5maWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IHJlcS5maWx0ZXIuYWRkcmVzcy5tYXAoZ2V0TG93ZXJDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShyZXEuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLCBhcmdzOiBbcmVxLmZpbHRlcl0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLXN0eWxlIEVycm9yIGZvciB0aGUgZ2l2ZW4gSlNPTi1SUEMgZXJyb3JcbiAgICAgKiAgJSVwYXlsb2FkJSUsIGNvYWxlc2NpbmcgdGhlIHZhcmlvdXMgc3RyaW5ncyBhbmQgZXJyb3Igc2hhcGVzXG4gICAgICogIHRoYXQgZGlmZmVyZW50IG5vZGVzIHJldHVybiwgY29lcmNpbmcgdGhlbSBpbnRvIGEgbWFjaGluZS1yZWFkYWJsZVxuICAgICAqICBzdGFuZGFyZGl6ZWQgZXJyb3IuXG4gICAgICovXG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgX2Vycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kIH0gPSBwYXlsb2FkO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBfZXJyb3I7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbXNnLm1hdGNoKC9yZXZlcnQvaSkgJiYgbXNnLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2NhbGxcIiB8fCBtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbigobWV0aG9kID09PSBcImV0aF9jYWxsXCIpID8gXCJjYWxsXCIgOiBcImVzdGltYXRlR2FzXCIsIChwYXlsb2FkLnBhcmFtc1swXSksIChyZXN1bHQgPyByZXN1bHQuZGF0YSA6IG51bGwpKTtcbiAgICAgICAgICAgIGUuaW5mbyA9IHsgZXJyb3IsIHBheWxvYWQgfTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgZXN0aW1hdGVHYXMgYW5kIGNhbGwgY2FuIHJldHVybiBhcmJpdHJhcnkgY29udHJhY3QtZGVmaW5lZCB0ZXh0LCBzbyBub3cgd2VcbiAgICAgICAgLy8gd2UgY2FuIHByb2Nlc3MgdGV4dCBzYWZlbHkuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShzcGVsdW5rTWVzc2FnZShlcnJvcikpO1xuICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZHxldGhlcnMtdXNlci1kZW5pZWQvaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk1hcCA9IHtcbiAgICAgICAgICAgICAgICBldGhfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIHBlcnNvbmFsX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDogXCJzaWduVHlwZWREYXRhXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UcmFuc2FjdGlvbjogXCJzaWduVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIHdhbGxldF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoYHVzZXIgcmVqZWN0ZWQgYWN0aW9uYCwgXCJBQ1RJT05fUkVKRUNURURcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKGFjdGlvbk1hcFttZXRob2RdIHx8IFwidW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICByZWFzb246IFwicmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKHBheWxvYWQucGFyYW1zWzBdKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZS9pKSAmJiBtZXNzYWdlLm1hdGNoKC90b28gbG93L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24vaSkgJiYgbWVzc2FnZS5tYXRjaCgvdW5kZXJwcmljZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogbWV0aG9kLCBpbmZvOiB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1bnN1cHBvcnRlZCA9ICEhbWVzc2FnZS5tYXRjaCgvdGhlIG1ldGhvZCAuKiBkb2VzIG5vdCBleGlzdC9pKTtcbiAgICAgICAgaWYgKCF1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmRldGFpbHMgJiYgZXJyb3IuZGV0YWlscy5zdGFydHNXaXRoKFwiVW5hdXRob3JpemVkIG1ldGhvZDpcIikpIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kLCBpbmZvOiB7IGVycm9yLCBwYXlsb2FkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJjb3VsZCBub3QgY29hbGVzY2UgZXJyb3JcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IsIHBheWxvYWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXF1ZXN0cyB0aGUgJSVtZXRob2QlJSB3aXRoICUlcGFyYW1zJSUgdmlhIHRoZSBKU09OLVJQQyBwcm90b2NvbFxuICAgICAqICBvdmVyIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogIG9uIHRoZSBiYWNrZW5kIHRoYXQgZG8gbm90IGhhdmUgYSBoaWdoLWxldmVsIEFQSSB3aXRoaW4gdGhlIFByb3ZpZGVyXG4gICAgICogIEFQSS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBxdWV1ZXMgcmVxdWVzdHMgYWNjb3JkaW5nIHRvIHRoZSBiYXRjaCBjb25zdHJhaW50c1xuICAgICAqICBpbiB0aGUgb3B0aW9ucywgYXNzaWducyB0aGUgcmVxdWVzdCBhIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqICAqKkRvIE5PVCBvdmVycmlkZSoqIHRoaXMgbWV0aG9kIGluIHN1Yi1jbGFzc2VzOyBpbnN0ZWFkXG4gICAgICogIG92ZXJyaWRlIFtbX3NlbmRdXSBvciBmb3JjZSB0aGUgb3B0aW9ucyB2YWx1ZXMgaW4gdGhlXG4gICAgICogIGNhbGwgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQFRPRE86IGNhY2hlIGNoYWluSWQ/PyBwdXJnZSBvbiBzd2l0Y2hfbmV0d29ya3NcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIGRlc3Ryb3llZDsgbm8gb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkIGFueW1vcmVcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuI25leHRJZCsrO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgbWV0aG9kLCBwYXJhbXMsIGlkLCBqc29ucnBjOiBcIjIuMFwiIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgcGVuZGluZyBkcmFpblRpbWVyLCBzZXQgb25lXG4gICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgW1tTaWduZXJdXSBhY2NvdW50IGZvciAgJSVhZGRyZXNzJSUgbWFuYWdlZCBieVxuICAgICAqICB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWFkZHJlc3MlJSBpcyBhIG51bWJlciwgaXQgaXMgdXNlZCBhcyBhbiBpbmRleCBpbiB0aGVcbiAgICAgKiAgdGhlIGFjY291bnRzIGZyb20gW1tsaXN0QWNjb3VudHNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgb24gY2xpZW50cyB3aGljaCBtYW5hZ2UgYWNjb3VudHMgKHN1Y2ggYXNcbiAgICAgKiAgR2V0aCB3aXRoIGltcG9ydGVkIGFjY291bnQgb3IgTWV0YU1hc2spLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgYWNjb3VudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzUHJvbWlzZSA9IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIC8vIEFjY291bnQgaW5kZXhcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IGFjY291bnRzUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA+PSBhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIGFjY291bnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWNjb3VudHNbYWRkcmVzc10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRzUHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWNjb3VudCBhZGRyZXNzXG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGFjY291bnQpID09PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWNjb3VudFwiKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEFjY291bnRzKCkge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKGEpID0+IG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGEpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBwcm9jZXNzaW5nIHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZHJhaW5UaW1lcik7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgZm9yIChjb25zdCB7IHBheWxvYWQsIHJlamVjdCB9IG9mIHRoaXMuI3BheWxvYWRzKSB7XG4gICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIC8vIFBhcmVudCBjbGVhbi11cFxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuLy8gQFRPRE86IHJlbW92ZSB0aGlzIGluIHY3LCBpdCBpcyBub3QgZXhwb3J0ZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uYWxpdHlcbi8vIGlzIGV4cG9zZWQgaW4gdGhlIEpzb25ScGNBcGlQcm92aWRlciBieSBzZXR0aW5nIHBvbGxpbmcgdG8gdHJ1ZS4gSXQgc2hvdWxkXG4vLyBiZSBzYWZlIHRvIHJlbW92ZSByZWdhcmRsZXNzLCBiZWNhdXNlIGl0IGlzbid0IHJlYWNoYWJsZSwgYnV0IGp1c3QgaW4gY2FzZS5cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XG4gICAgI3BvbGxpbmdJbnRlcnZhbDtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgIH1cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA0MDAwIG1zKVxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0LmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQWxsIHJlcXVlc3RzIGFyZSBvdmVyIEhUVFAsIHNvIHdlIGNhbiBqdXN0IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaGVyZSByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3Igc28gdGhhdCB3ZSBkb24ndCBzZW5kIGFueVxuICAgICAgICAvLyByZXF1ZXN0cyB0byB0aGUgbmV0d29yayAoaS5lLiBldGhfY2hhaW5JZCkgdW50aWwgd2UgYWJzb2x1dGVseSBoYXZlIHRvLlxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgUE9TVCBjb25uZWN0aW9uIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICBsZXQgcmVzcCA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcCkpIHtcbiAgICAgICAgICAgIHJlc3AgPSBbcmVzcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YTogdmFsdWUuZGF0YSB9O1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmtEYXRhKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZVtrZXldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF9zcGVsdW5rTWVzc2FnZShKU09OLnBhcnNlKHZhbHVlKSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtNZXNzYWdlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1qc29ucnBjLmpzLm1hcCJdLCJuYW1lcyI6WyJBYmlDb2RlciIsImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsIlR5cGVkRGF0YUVuY29kZXIiLCJhY2Nlc3NMaXN0aWZ5IiwiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsInRvUXVhbnRpdHkiLCJ0b1V0ZjhCeXRlcyIsIm1ha2VFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiRmV0Y2hSZXF1ZXN0IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJBYnN0cmFjdFByb3ZpZGVyIiwiVW5tYW5hZ2VkU3Vic2NyaWJlciIsIkFic3RyYWN0U2lnbmVyIiwiTmV0d29yayIsIkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIiwiRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJQcmltaXRpdmUiLCJzcGxpdCIsImRlZXBDb3B5IiwidmFsdWUiLCJpbmRleE9mIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjY3VtIiwia2V5IiwiRXJyb3IiLCJzdGFsbCIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0TG93ZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJpc1BvbGxhYmxlIiwicG9sbGluZ0ludGVydmFsIiwiZGVmYXVsdE9wdGlvbnMiLCJwb2xsaW5nIiwic3RhdGljTmV0d29yayIsImJhdGNoU3RhbGxUaW1lIiwiYmF0Y2hNYXhTaXplIiwiYmF0Y2hNYXhDb3VudCIsImNhY2hlVGltZW91dCIsIkpzb25ScGNTaWduZXIiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVyIiwiYWRkcmVzcyIsImNvbm5lY3QiLCJvcGVyYXRpb24iLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwidHgiLCJwb3B1bGF0ZUNhbGwiLCJzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24iLCJfdHgiLCJwcm9taXNlcyIsImZyb20iLCJfZnJvbSIsInB1c2giLCJnYXNMaW1pdCIsImVzdGltYXRlR2FzIiwidG8iLCJfdG8iLCJsZW5ndGgiLCJhbGwiLCJoZXhUeCIsImdldFJwY1RyYW5zYWN0aW9uIiwic2VuZCIsInNlbmRUcmFuc2FjdGlvbiIsImJsb2NrTnVtYmVyIiwiZ2V0QmxvY2tOdW1iZXIiLCJoYXNoIiwicmVqZWN0IiwidGltZW91dHMiLCJjaGVja1R4IiwiZ2V0VHJhbnNhY3Rpb24iLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiX3NldFRpbWVvdXQiLCJwb3AiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduTWVzc2FnZSIsIl9tZXNzYWdlIiwibWVzc2FnZSIsInNpZ25UeXBlZERhdGEiLCJkb21haW4iLCJ0eXBlcyIsIl92YWx1ZSIsInBvcHVsYXRlZCIsInJlc29sdmVOYW1lcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRQYXlsb2FkIiwidW5sb2NrIiwicGFzc3dvcmQiLCJfbGVnYWN5U2lnbk1lc3NhZ2UiLCJKc29uUnBjQXBpUHJvdmlkZXIiLCJvcHRpb25zIiwibmV4dElkIiwicGF5bG9hZHMiLCJkcmFpblRpbWVyIiwibm90UmVhZHkiLCJuZXR3b3JrIiwic2NoZWR1bGVEcmFpbiIsInN0YWxsVGltZSIsIl9nZXRPcHRpb24iLCJiYXRjaCIsInNoaWZ0IiwiYnl0ZXMiLCJwIiwicGF5bG9hZCIsInVuc2hpZnQiLCJlbWl0IiwiYWN0aW9uIiwicmVzdWx0IiwiX3NlbmQiLCJkZXN0cm95ZWQiLCJtZXRob2QiLCJyZXNwIiwiZmlsdGVyIiwiciIsImlkIiwiZXJyb3IiLCJpbmZvIiwiZ2V0UnBjRXJyb3IiLCJhc3NpZ24iLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJtYXRjaGVzIiwiX25ldHdvcmsiLCJfcGVyZm9ybSIsInJlcSIsInRyYW5zYWN0aW9uIiwidHlwZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0IiwiZ2V0UnBjUmVxdWVzdCIsImFyZ3MiLCJfZGV0ZWN0TmV0d29yayIsInJlYWR5IiwicGFyYW1zIiwianNvbnJwYyIsIl9zdGFydCIsImNvbnNvbGUiLCJsb2ciLCJldmVudCIsIl93YWl0VW50aWxSZWFkeSIsIl9nZXRTdWJzY3JpYmVyIiwic3ViIiwib3JwaGFuIiwiZm9yRWFjaCIsImRzdEtleSIsImFjY2Vzc0xpc3QiLCJibG9ja1RhZyIsInBvc2l0aW9uIiwidG9TdHJpbmciLCJzaWduZWRUcmFuc2FjdGlvbiIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJibG9ja0hhc2giLCJfZXJyb3IiLCJtc2ciLCJtYXRjaCIsInNwZWx1bmtEYXRhIiwiZSIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiZGF0YSIsInNwZWx1bmtNZXNzYWdlIiwiYWN0aW9uTWFwIiwiZXRoX3NpZ24iLCJwZXJzb25hbF9zaWduIiwiZXRoX3NpZ25UeXBlZERhdGFfdjQiLCJldGhfc2lnblRyYW5zYWN0aW9uIiwiZXRoX3NlbmRUcmFuc2FjdGlvbiIsImV0aF9yZXF1ZXN0QWNjb3VudHMiLCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzIiwicmVhc29uIiwidW5zdXBwb3J0ZWQiLCJkZXRhaWxzIiwic3RhcnRzV2l0aCIsImdldFNpZ25lciIsImFjY291bnRzUHJvbWlzZSIsImFjY291bnRzIiwiZ2V0TmV0d29yayIsImFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJhIiwiZGVzdHJveSIsImNsZWFyVGltZW91dCIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJzdWJzY3JpYmVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiX2ZvckVhY2hTdWJzY3JpYmVyIiwiSnNvblJwY1Byb3ZpZGVyIiwidXJsIiwiY2xvbmUiLCJfZ2V0Q29ubmVjdGlvbiIsImJvZHkiLCJzZXRIZWFkZXIiLCJyZXNwb25zZSIsImFzc2VydE9rIiwiYm9keUpzb24iLCJwYXJzZSIsIl9zcGVsdW5rTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/provider.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/provider.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        this.#transactions = block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            miner: block.miner,\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas)\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes.\n     */ get transactions() {\n        return this.#transactions.map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions for blocks which\n     *  prefetched them, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, nonce, number, parentHash, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            hash,\n            miner,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            transactions\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return this.#transactions.length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash === hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    #logs;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.#logs = Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            gasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return this.#logs;\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    #startBlock;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            accessList,\n            blockNumber,\n            blockHash,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDBEQUEwRDtBQUN5RjtBQUMzRjtBQUN4RCxNQUFNVSxPQUFPQyxPQUFPO0FBQ3BCLDBCQUEwQjtBQUMxQixTQUFTQyxTQUFTQyxLQUFLO0lBQ25CLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTQyxPQUFPRCxLQUFLO0lBQ2pCLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLE9BQU9BLE1BQU1FLFFBQVE7QUFDekI7QUFDQSwwREFBMEQ7QUFDMUQ7OztDQUdDLEdBQ00sTUFBTUM7SUE0QlQ7OztLQUdDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxvQkFBb0IsQ0FBRTtRQUN0RHBCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJrQixVQUFVTixTQUFTTTtZQUNuQkMsY0FBY1AsU0FBU087WUFDdkJDLHNCQUFzQlIsU0FBU1E7UUFDbkM7SUFDSjtJQUNBOztLQUVDLEdBQ0RDLFNBQVM7UUFDTCxNQUFNLEVBQUVILFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxvQkFBb0IsRUFBRSxHQUFHLElBQUk7UUFDN0QsT0FBTztZQUNIRSxPQUFPO1lBQ1BKLFVBQVVKLE9BQU9JO1lBQ2pCQyxjQUFjTCxPQUFPSztZQUNyQkMsc0JBQXNCTixPQUFPTTtRQUNqQztJQUNKO0FBQ0o7O0FBRUE7OztDQUdDLEdBQ00sU0FBU0csWUFBWUMsR0FBRztJQUMzQixNQUFNQyxTQUFTLENBQUM7SUFDaEIsc0RBQXNEO0lBQ3RELElBQUlELElBQUlFLEVBQUUsRUFBRTtRQUNSRCxPQUFPQyxFQUFFLEdBQUdGLElBQUlFLEVBQUU7SUFDdEI7SUFDQSxJQUFJRixJQUFJRyxJQUFJLEVBQUU7UUFDVkYsT0FBT0UsSUFBSSxHQUFHSCxJQUFJ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RyxzQkFBc0IsY0FBY0E7UUFDcEcsTUFBTXRFLEtBQUssSUFBSUMsb0JBQW9CLElBQUksRUFBRSxJQUFJLENBQUNILFFBQVE7UUFDdERFLEdBQUcsQ0FBQ3NFLFVBQVUsR0FBR0E7UUFDakIsT0FBT3RFO0lBQ1g7QUFDSjtBQUNBLFNBQVNtQywwQkFBMEJ0QyxLQUFLO0lBQ3BDLE9BQU87UUFBRXNILFFBQVE7UUFBY2pILE1BQU1MLE1BQU1LLElBQUk7UUFBRUMsUUFBUU4sTUFBTU0sTUFBTTtJQUFDO0FBQzFFO0FBQ0EsU0FBU2tFLGlDQUFpQ3JFLEVBQUUsRUFBRW9FLEtBQUs7SUFDL0MsT0FBTztRQUFFK0MsUUFBUTtRQUF1Qm5IO1FBQUlvRTtJQUFNO0FBQ3REO0FBQ0EsU0FBU0YsK0JBQStCbEUsRUFBRTtJQUN0QyxPQUFPO1FBQUVtSCxRQUFRO1FBQW9Cbkg7SUFBRztBQUM1QztBQUNBLFNBQVNtRCx1QkFBdUJkLEdBQUc7SUFDL0IsT0FBTztRQUFFOEUsUUFBUTtRQUFZOUUsS0FBSztZQUMxQkksaUJBQWlCSixJQUFJSSxlQUFlO1lBQ3BDQyxXQUFXTCxJQUFJSyxTQUFTO1lBQ3hCQyxhQUFhTixJQUFJTSxXQUFXO1lBQzVCRSxTQUFTUixJQUFJUSxPQUFPO1lBQ3BCM0QsTUFBTW1ELElBQUluRCxJQUFJO1lBQ2RvRCxRQUFRQyxPQUFPQyxNQUFNLENBQUNILElBQUlDLE1BQU0sQ0FBQ3ZCLEtBQUs7WUFDdENLLE9BQU9pQixJQUFJakIsS0FBSztRQUNwQjtJQUFFO0FBQ1YsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci5qcz8yNDM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9Kc29uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLy8gQFRPRE8/IDxUIGV4dGVuZHMgRmVlRGF0YSA9IHsgfT4gaW1wbGVtZW50cyBSZXF1aXJlZDxUPlxuLyoqXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcbiAqICB0aGUgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGEge1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlIGZvciBsZWdhY3kgbmV0d29ya3MuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyBpcyBkZWZpbmVkIGJ5IHRoZSBuZXR3b3JrIGFuZCBiYXNlZCBvblxuICAgICAqICBjb25nZXN0aW9uLCBpbmNyZWFzaW5nIHRoZSBjb3N0IGR1cmluZyB0aW1lcyBvZiBoZWF2eSBsb2FkXG4gICAgICogIGFuZCBsb3dlcmluZyB3aGVuIGxlc3MgYnVzeS5cbiAgICAgKlxuICAgICAqICBUaGUgYWN0dWFsIGZlZSBwZXIgZ2FzIHdpbGwgYmUgdGhlIGJhc2UgZmVlIGZvciB0aGUgYmxvY2tcbiAgICAgKiAgYW5kIHRoZSBwcmlvcml0eSBmZWUsIHVwIHRvIHRoZSBtYXggZmVlIHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRpdGlvbmFsIGFtb3V0IHRvIHBheSBwZXIgZ2FzIHRvIGVuY291cmFnZSBhIHZhbGlkYXRvclxuICAgICAqICB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGUgcHVycG9zZSBvZiB0aGlzIGlzIHRvIGNvbXBlbnNhdGUgdGhlIHZhbGlkYXRvciBmb3IgdGhlXG4gICAgICogIGFkanVzdGVkIHJpc2sgZm9yIGluY2x1ZGluZyBhIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgRmVlRGF0YSBmb3IgJSVnYXNQcmljZSUlLCAlJW1heEZlZVBlckdhcyUlIGFuZFxuICAgICAqICAlJW1heFByaW9yaXR5RmVlUGVyR2FzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBnYXNQcmljZTogZ2V0VmFsdWUoZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24oZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24obWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxuICogIHR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLy8gVGhlc2UgY291bGQgYmUgYWRkcmVzc2VzLCBFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzXG4gICAgaWYgKHJlcS50bykge1xuICAgICAgICByZXN1bHQudG8gPSByZXEudG87XG4gICAgfVxuICAgIGlmIChyZXEuZnJvbSkge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHJlcS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBoZXhsaWZ5KHJlcS5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJHYXMsbWF4UHJpb3JpdHlGZWVQZXJHYXMsdmFsdWVcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJpZ0ludEtleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRCaWdJbnQocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXJLZXlzID0gXCJ0eXBlLG5vbmNlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBudW1iZXJLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0TnVtYmVyKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyZXEuYWNjZXNzTGlzdCk7XG4gICAgfVxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja1RhZyA9IHJlcS5ibG9ja1RhZztcbiAgICB9XG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmVuYWJsZUNjaXBSZWFkID0gISFyZXEuZW5hYmxlQ2NpcFJlYWQ7XG4gICAgfVxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmN1c3RvbURhdGEgPSByZXEuY3VzdG9tRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipCbG9jayoqIHJlcHJlc2VudHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZnVsbCBibG9jayBvblxuICogIEV0aGVyZXVtLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2sge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBibG9jayB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXG4gICAgICogIHNlcXVlbnRpYWwgbnVtYmVyIHRoYXQgaXMgb25lIGhpZ2hlciB0aGFuIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhc2ggaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMsIHNvIGNhbiBiZSBzYWZlbHkgdXNlZCB0byBpZGVudGlmeVxuICAgICAqICBhbiBleGFjdCBzZXQgb2YgYmxvY2sgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiAgZXBvY2ggdGhhdCB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICB0aW1lc3RhbXA7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgcGFyZW50SGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcmFuZG9tIG51bWJlciBpbnNlcnRlZCB3aGljaFxuICAgICAqICBwZXJtaXR0ZWQgdGhlIGRpZmZpY3VsdHkgdGFyZ2V0IHRvIGJlIHJlYWNoZWQuXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBkaWZmaWN1bHR5IHRhcmdldC5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHByb29mLW9mLXdvcmsgdGFyZ2V0IHJlcXVpcmVkXG4gICAgICogIGZvciBhIGJsb2NrIHRvIG1lZXQgdGhlIHByb3RvY29sIHJ1bGVzIHRvIGJlIGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogIE9uIG1vZGVybiBuZXR3b3JrcywgdGhpcyBpcyBhIHJhbmRvbSBudW1iZXIgYXJyaXZlZCBhdCB1c2luZ1xuICAgICAqICByYW5kYW8uICBAVE9ETzogRmluZCBsaW5rcz9cbiAgICAgKi9cbiAgICBkaWZmaWN1bHR5O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZ2FzIGxpbWl0IGZvciB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc0xpbWl0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZ2FzIHVzZWQgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWluZXIgY29pbmJhc2UgYWRkcmVzcywgd2loY2ggcmVjZWl2ZXMgYW55IHN1YnNpZGllcyBmb3JcbiAgICAgKiAgaW5jbHVkaW5nIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgbWluZXI7XG4gICAgLyoqXG4gICAgICogIEFueSBleHRyYSBkYXRhIHRoZSB2YWxpZGF0b3Igd2lzaGVkIHRvIGluY2x1ZGUuXG4gICAgICovXG4gICAgZXh0cmFEYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyB0aGF0IGFsbCB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jayB3ZXJlXG4gICAgICogIGNoYXJnZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBhZGp1c3RzIGFmdGVyIGVhY2ggYmxvY2ssIGRlcGVuZGluZyBvbiBob3cgY29uZ2VzdGVkIHRoZSBuZXR3b3JrXG4gICAgICogIGlzLlxuICAgICAqL1xuICAgIGJhc2VGZWVQZXJHYXM7XG4gICAgI3RyYW5zYWN0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQmxvY2sqKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSBuZWNlc3NhcnkgYXMgdGhlIHVubGVzcyBpbXBsZW1lbnRpbmcgYVxuICAgICAqICBsb3ctbGV2ZWwgbGlicmFyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihibG9jaywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jdHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIGhhc2g6IGdldFZhbHVlKGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgbnVtYmVyOiBibG9jay5udW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxuICAgICAgICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCxcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogZ2V0VmFsdWUoYmxvY2suYmFzZUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGhhc2hlcy5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucyBmb3IgYmxvY2tzIHdoaWNoXG4gICAgICogIHByZWZldGNoZWQgdGhlbSwgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eHNbaW5kZXgrK10sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1qcy1kYXRlXV0gdGhpcyBibG9jayB3YXMgaW5jbHVkZWQgYXQuXG4gICAgICovXG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgdHJhbnNhY3Rpb24gYXQgJSVpbmRleGUlJSB3aXRoaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBpbnRlcm5hbCB2YWx1ZSBieSBpdHMgaW5kZXggb3IgaGFzaFxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdHggPSB0aGlzLiN0cmFuc2FjdGlvbnNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhICoqQmxvY2sqKiB3YXMgZmV0Y2hlZCB3aXRoIGEgcmVxdWVzdCB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgdGhpcyB3aWxsIGFsbG93IHN5bmNocm9ub3VzIGFjY2VzcyB0byB0aG9zZSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIG5vdCBwcmVmZXRjaGVkLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMucHJlZmV0Y2hlZFRyYW5zYWN0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleE9ySGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XG4gICAgICAgICAgICBpZiAodHguaGFzaCA9PT0gaW5kZXhPckhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwibm8gbWF0Y2hpbmcgdHJhbnNhY3Rpb25cIiwgXCJpbmRleE9ySGFzaFwiLCBpbmRleE9ySGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBiZWVuIG1pbmVkLiBUaGlzIHByb3ZpZGVzIGEgdHlwZSBndWFyZFxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkgeyByZXR1cm4gISF0aGlzLmhhc2g7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgYW4gW1tsaW5rLWVpcC0yOTMwXV0gYmxvY2suXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYmFzZUZlZVBlckdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIG9ycGhhbmVkRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb2dcbi8qKlxuICogIEEgKipMb2cqKiBpbiBFdGhlcmV1bSByZXByZXNlbnRzIGFuIGV2ZW50IHRoYXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYVxuICogIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBgYExPRypgYCBvcGNvZGVzLCB3aGljaCBhcmUgbW9zdCBjb21tb25seSB1c2VkIGJ5XG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRUcmFuc2FjdGlvbl1dIHRvIGdldCB0aGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBJdCBpcyBwcmVmZXJyZWRcbiAgICAgKiAgdG8gdXNlIHRoZSBbW0Jsb2NrLWhhc2hdXSB3aGVuIGZldGNoaW5nIHRoZSByZWxhdGVkIFtbQmxvY2tdXSxcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcbiAgICAgKiAgaGF2ZSBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgKipMb2cqKiByZXByZXNlbnRzIGEgYmxvY2sgdGhhdCB3YXMgcmVtb3ZlZCBkdWUgdG8gYW4gb3JwaGFuZWRcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdpdGhpbiBhbiBvcnBoYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgcmVtb3ZlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleGVkIHRvcGljcyBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogIEFsbCB0b3BpY3MgYXJlIGluY2x1ZGVkIGluIHRoZSBibG9vbSBmaWx0ZXJzLCBzbyB0aGV5IGNhbiBiZVxuICAgICAqICBlZmZpY2llbnRseSBmaWx0ZXJlZCB1c2luZyB0aGUgW1tQcm92aWRlci1nZXRMb2dzXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHRvcGljcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XG4gICAgICogIG5vdCB1c2VmdWwgdG8gZGV2ZWxvcGVycywgYnV0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHZhcmlvdXMgcm9vdHNcbiAgICAgKiAgdG8gcHJvb2YgaW5jbHVzaW9uIHdpdGhpbiBhIGJsb2NrLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkluZGV4O1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgdG9waWNzID0gT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3MsXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LCByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhYmxvY2ssIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCBmb3QgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpc1xuICAgICAqICBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRyYW5zYWN0aW9uIFJlY2VpcHRcbi8qXG5leHBvcnQgaW50ZXJmYWNlIExlZ2FjeVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiBmYWxzZTtcbiAgICBzdGF0dXM6IG51bGw7XG4gICAgcm9vdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ5emFudGl1bVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiB0cnVlO1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHJvb3Q6IG51bGw7XG59XG4qL1xuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYVxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gd2FzIHNlbmQgdG8uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZyb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGRpcmVjdGx5XG4gICAgICogIHJlc3BvbnNpYmxlIGZvciBkZXBsb3lpbmcgb25lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm9uLW51bGwgKipvbmx5KiogaWYgdGhlIGBgdG9gYCBpcyBlbXB0eSBhbmQgdGhlIGBgZGF0YWBgXG4gICAgICogIHdhcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgYXMgaW5pdGNvZGUuXG4gICAgICovXG4gICAgY29udHJhY3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggb2YgdGhpcyB0cmFuc2FjdGlvbiB3aXRoaW4gdGhlIGJsb2NrIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb29tIGZpbHRlciBieXRlcyB0aGF0IHJlcHJlc2VudCBhbGwgbG9ncyB0aGF0IG9jY3VycmVkIHdpdGhpblxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBtb3N0IGRldmVsb3BlcnMsXG4gICAgICogIGJ1dCBjYW4gYmUgdXNlZCB0byB2YWxpZGF0ZSB0aGUgaW5jbHVkZWQgbG9ncy5cbiAgICAgKi9cbiAgICBsb2dzQmxvb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgV2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uLCB0aGUgYW1vdW50IG9mIGdhcyB0aGF0IHdpbGwgYmUgdXNlZCBjYW5cbiAgICAgKiAgb25seSBiZSBhcHByb3hpbWF0ZWQsIGJ1dCB0aGUgc2VuZGVyIG11c3QgcGF5IHRoZSBnYXMgZmVlIGZvciB0aGVcbiAgICAgKiAgZW50aXJlIGdhcyBsaW1pdC4gQWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCB0aGUgZGlmZmVyZW5jZSBpcyByZWZ1bmRlZC5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICB0eXBlOiB0eC50eXBlLFxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcbiAgICAgICAgICAgIHN0YXR1czogdHguc3RhdHVzLFxuICAgICAgICAgICAgcm9vdDogdHgucm9vdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkgeyByZXR1cm4gdGhpcy4jbG9nczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSwgY29udHJhY3RBZGRyZXNzLCBoYXNoLCBpbmRleCwgYmxvY2tIYXNoLCBibG9ja051bWJlciwgbG9nc0Jsb29tLCBsb2dzLCAvL2J5emFudGl1bSwgXG4gICAgICAgIHN0YXR1cywgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgYmxvY2tIYXNoLCBibG9ja051bWJlcixcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0b0pzb24odGhpcy5jdW11bGF0aXZlR2FzVXNlZCksXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgI3N0YXJ0QmxvY2s7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYmxvY2tOdW1iZXIgPSAodHguYmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0eC5ibG9ja051bWJlciA6IG51bGw7XG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gKHR4LmJsb2NrSGFzaCAhPSBudWxsKSA/IHR4LmJsb2NrSGFzaCA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0eC5pbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gdHguZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHR4LnRvIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgdGhpcy5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB0aGlzLnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIHRoaXMuZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9ICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB0eC5zaWduYXR1cmU7XG4gICAgICAgIHRoaXMuYWNjZXNzTGlzdCA9ICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpID8gdHguYWNjZXNzTGlzdCA6IG51bGw7XG4gICAgICAgIHRoaXMuI3N0YXJ0QmxvY2sgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGJsb2NrSGFzaCwgaW5kZXgsIGhhc2gsIHR5cGUsIHRvLCBmcm9tLCBub25jZSwgZGF0YSwgc2lnbmF0dXJlLCBhY2Nlc3NMaXN0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgY2hhaW5JZDogdG9Kc29uKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBkYXRhLCBmcm9tLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgZXZpY3QgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UgaW5zdGFuY2Ugd2hpY2ggaGFzIHRoZSBhYmlsaXR5IHRvXG4gICAgICogIGRldGVjdCAoYW5kIHRocm93IGFuIGVycm9yKSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcmVwbGFjZWQsIHdoaWNoXG4gICAgICogIHdpbGwgYmVnaW4gc2Nhbm5pbmcgYXQgJSVzdGFydEJsb2NrJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGJ5IGRldmVsb3BlcnMgYW5kIGlzIGludGVuZGVkXG4gICAgICogIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLiBTZXR0aW5nIGFuIGluY29ycmVjdCAlJXN0YXJ0QmxvY2slJSBjYW5cbiAgICAgKiAgaGF2ZSBkZXZhc3RhdGluZyBwZXJmb3JtYW5jZSBjb25zZXF1ZW5jZXMgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgKi9cbiAgICByZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcihibG9jaykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWJsb2NrXCIsIGhhc2g6IGJsb2NrLmhhc2gsIG51bWJlcjogYmxvY2subnVtYmVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0eCwgb3RoZXIpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwicmVvcmRlci10cmFuc2FjdGlvblwiLCB0eCwgb3RoZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0eCkge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLXRyYW5zYWN0aW9uXCIsIHR4IH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKGxvZykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzOiBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSksXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4XG4gICAgICAgIH0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0TnVtYmVyIiwiaGV4bGlmeSIsInJlc29sdmVQcm9wZXJ0aWVzIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYWNjZXNzTGlzdGlmeSIsIkJOXzAiLCJCaWdJbnQiLCJnZXRWYWx1ZSIsInZhbHVlIiwidG9Kc29uIiwidG9TdHJpbmciLCJGZWVEYXRhIiwiY29uc3RydWN0b3IiLCJnYXNQcmljZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwidG9KU09OIiwiX3R5cGUiLCJjb3B5UmVxdWVzdCIsInJlcSIsInJlc3VsdCIsInRvIiwiZnJvbSIsImRhdGEiLCJiaWdJbnRLZXlzIiwic3BsaXQiLCJrZXkiLCJudW1iZXJLZXlzIiwiYWNjZXNzTGlzdCIsImJsb2NrVGFnIiwiZW5hYmxlQ2NpcFJlYWQiLCJjdXN0b21EYXRhIiwiQmxvY2siLCJ0cmFuc2FjdGlvbnMiLCJibG9jayIsInByb3ZpZGVyIiwibWFwIiwidHgiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiaGFzaCIsIm51bWJlciIsInRpbWVzdGFtcCIsInBhcmVudEhhc2giLCJub25jZSIsImRpZmZpY3VsdHkiLCJnYXNMaW1pdCIsImdhc1VzZWQiLCJtaW5lciIsImV4dHJhRGF0YSIsImJhc2VGZWVQZXJHYXMiLCJwcmVmZXRjaGVkVHJhbnNhY3Rpb25zIiwidHhzIiwic2xpY2UiLCJsZW5ndGgiLCJvcGVyYXRpb24iLCJTeW1ib2wiLCJpdGVyYXRvciIsImluZGV4IiwibmV4dCIsImRvbmUiLCJ1bmRlZmluZWQiLCJkYXRlIiwiRGF0ZSIsImdldFRyYW5zYWN0aW9uIiwiaW5kZXhPckhhc2giLCJ0b0xvd2VyQ2FzZSIsInYiLCJFcnJvciIsImdldFByZWZldGNoZWRUcmFuc2FjdGlvbiIsImlzTWluZWQiLCJpc0xvbmRvbiIsIm9ycGhhbmVkRXZlbnQiLCJjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyIiwiTG9nIiwibG9nIiwidG9waWNzIiwiT2JqZWN0IiwiZnJlZXplIiwidHJhbnNhY3Rpb25IYXNoIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJyZW1vdmVkIiwiYWRkcmVzcyIsInRyYW5zYWN0aW9uSW5kZXgiLCJnZXRCbG9jayIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInJlY2VpcHQiLCJyZW1vdmVkRXZlbnQiLCJjcmVhdGVSZW1vdmVkTG9nRmlsdGVyIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwibG9ncyIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiY29udHJhY3RBZGRyZXNzIiwibG9nc0Jsb29tIiwiY3VtdWxhdGl2ZUdhc1VzZWQiLCJ0eXBlIiwic3RhdHVzIiwicm9vdCIsImZlZSIsImdldFJlc3VsdCIsImdldFRyYW5zYWN0aW9uUmVzdWx0IiwiY29uZmlybWF0aW9ucyIsImdldEJsb2NrTnVtYmVyIiwiY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyIiwicmVvcmRlcmVkRXZlbnQiLCJvdGhlciIsImNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyIiwic3RhcnRCbG9jayIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJ3YWl0IiwiX2NvbmZpcm1zIiwiX3RpbWVvdXQiLCJjb25maXJtcyIsInRpbWVvdXQiLCJuZXh0U2NhbiIsInN0b3BTY2FubmluZyIsImNoZWNrUmVwbGFjZW1lbnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwibWluZWQiLCJpIiwicmVhc29uIiwiY2FuY2VsbGVkIiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiY2hlY2tSZWNlaXB0IiwiYWN0aW9uIiwiaW52b2NhdGlvbiIsInJldmVydCIsInRyYW5zYWN0aW9uIiwid2FpdGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWxsZXJzIiwiY2FuY2VsIiwiZm9yRWFjaCIsImMiLCJwdXNoIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidHhMaXN0ZW5lciIsImVycm9yIiwib2ZmIiwib24iLCJyZXBsYWNlTGlzdGVuZXIiLCJvbmNlIiwiaXNMZWdhY3kiLCJpc0JlcmxpbiIsIk51bWJlciIsImlzSW50ZWdlciIsIm9ycGhhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: () => (/* binding */ FilterIdEventSubscriber),\n/* harmony export */   FilterIdPendingSubscriber: () => (/* binding */ FilterIdPendingSubscriber),\n/* harmony export */   FilterIdSubscriber: () => (/* binding */ FilterIdSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */ _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */ _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */ _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [\n                filterId\n            ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId)=>{\n                this.#provider.send(\"eth_uninstallFilter\", [\n                    filterId\n                ]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */ constructor(provider, filter){\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [\n            this.#event\n        ]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(\"pending\", result);\n        }\n    }\n} //# sourceMappingURL=subscriber-filterid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ3FCO0FBQ2pFLFNBQVNFLEtBQUtDLEdBQUc7SUFDYixPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ0g7QUFDckM7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNSTtJQUNULENBQUNDLFFBQVEsQ0FBQztJQUNWLENBQUNDLGVBQWUsQ0FBQztJQUNqQixDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxPQUFPLENBQUM7SUFDVCxDQUFDQyxPQUFPLENBQUM7SUFDVCxDQUFDQyxLQUFLLENBQUM7SUFDUDs7OztLQUlDLEdBQ0RDLFlBQVlOLFFBQVEsQ0FBRTtRQUNsQixJQUFJLENBQUMsQ0FBQ0EsUUFBUSxHQUFHQTtRQUNqQixJQUFJLENBQUMsQ0FBQ0MsZUFBZSxHQUFHO1FBQ3hCLElBQUksQ0FBQyxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUNLLElBQUksQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDLENBQUNMLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQ0MsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDQyxLQUFLLEdBQUc7SUFDbEI7SUFDQTs7S0FFQyxHQUNESSxXQUFXVCxRQUFRLEVBQUU7UUFDakIsTUFBTSxJQUFJVSxNQUFNO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsYUFBYVgsUUFBUSxFQUFFWSxNQUFNLEVBQUU7UUFDM0IsTUFBTSxJQUFJRixNQUFNO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREcsU0FBU2IsUUFBUSxFQUFFO1FBQ2YsTUFBTSxJQUFJVSxNQUFNO0lBQ3BCO0lBQ0EsTUFBTSxDQUFDSCxJQUFJLENBQUNPLFdBQVc7UUFDbkIsSUFBSTtZQUNBLHlCQUF5QjtZQUN6QixJQUFJLElBQUksQ0FB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SztJQUFJO0FBQzdCO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1NLGdDQUFnQ2xDO0lBQ3pDLENBQUNtQyxLQUFLLENBQUM7SUFDUDs7O0tBR0MsR0FDRDVCLFlBQVlOLFFBQVEsRUFBRW1DLE1BQU0sQ0FBRTtRQUMxQixLQUFLLENBQUNuQztRQUNOLElBQUksQ0FBQyxDQUFDa0MsS0FBSyxHQUFHeEMsS0FBS3lDO0lBQ3ZCO0lBQ0F0QixTQUFTYixRQUFRLEVBQUU7UUFDZixPQUFPLElBQUlQLDBFQUFzQkEsQ0FBQ08sVUFBVSxJQUFJLENBQUMsQ0FBQ2tDLEtBQUs7SUFDM0Q7SUFDQSxNQUFNekIsV0FBV1QsUUFBUSxFQUFFO1FBQ3ZCLE1BQU1lLFdBQVcsTUFBTWYsU0FBU3FCLElBQUksQ0FBQyxpQkFBaUI7WUFBQyxJQUFJLENBQUMsQ0FBQ2EsS0FBSztTQUFDO1FBQ25FLE9BQU9uQjtJQUNYO0lBQ0EsTUFBTUosYUFBYVgsUUFBUSxFQUFFb0MsT0FBTyxFQUFFO1FBQ2xDLEtBQUssTUFBTXhCLFVBQVV3QixRQUFTO1lBQzFCcEMsU0FBU3FDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ0gsS0FBSyxFQUFFbEMsU0FBU3NDLFFBQVEsQ0FBQzFCLFFBQVFaLFNBQVN1QyxRQUFRO1FBQzFFO0lBQ0o7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNQyxrQ0FBa0N6QztJQUMzQyxNQUFNVSxXQUFXVCxRQUFRLEVBQUU7UUFDdkIsT0FBTyxNQUFNQSxTQUFTcUIsSUFBSSxDQUFDLG1DQUFtQyxFQUFFO0lBQ3BFO0lBQ0EsTUFBTVYsYUFBYVgsUUFBUSxFQUFFb0MsT0FBTyxFQUFFO1FBQ2xDLEtBQUssTUFBTXhCLFVBQVV3QixRQUFTO1lBQzFCcEMsU0FBU3FDLElBQUksQ0FBQyxXQUFXekI7UUFDN0I7SUFDSjtBQUNKLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcz83NzRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBTb21lIGJhY2tlbmRzIHN1cHBvcnQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzIHVzaW5nIGEgRmlsdGVyIElELlxuICpcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxuICogIC8vRmlsdGVyIElELy8uIEF0IHRoaXMgcG9pbnQgdGhlIG5vZGUgZGVkaWNhdGVzIHJlc291cmNlcyB0b1xuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgRmlsdGVyIElEOyBkb3duZ3JhZGUgdG9cbiAgICAgICAgICAgIC8vIHBvbGxpbmdcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWlkIGNoYW5nZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0UmVzdWx0cyh0aGlzLiNwcm92aWRlciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFRPRE9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICAjdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgaWYgKGZpbHRlcklkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiXSwibmFtZXMiOlsiaXNFcnJvciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJjb3B5Iiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiRmlsdGVySWRTdWJzY3JpYmVyIiwicHJvdmlkZXIiLCJmaWx0ZXJJZFByb21pc2UiLCJwb2xsZXIiLCJydW5uaW5nIiwibmV0d29yayIsImhhdWx0IiwiY29uc3RydWN0b3IiLCJwb2xsIiwiYmluZCIsIl9zdWJzY3JpYmUiLCJFcnJvciIsIl9lbWl0UmVzdWx0cyIsInJlc3VsdCIsIl9yZWNvdmVyIiwiYmxvY2tOdW1iZXIiLCJmaWx0ZXJJZCIsImVycm9yIiwib3BlcmF0aW9uIiwiX3JlY292ZXJTdWJzY3JpYmVyIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJzZW5kIiwiY29uc29sZSIsImxvZyIsIm9uY2UiLCJ0ZWFyZG93biIsInRoZW4iLCJzdGFydCIsInN0b3AiLCJvZmYiLCJwYXVzZSIsImRyb3BXaGlsZVBhdXNlZCIsInJlc3VtZSIsIkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIiwiZXZlbnQiLCJmaWx0ZXIiLCJyZXN1bHRzIiwiZW1pdCIsIl93cmFwTG9nIiwiX25ldHdvcmsiLCJGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: () => (/* binding */ OnBlockSubscriber),\n/* harmony export */   PollingBlockSubscriber: () => (/* binding */ PollingBlockSubscriber),\n/* harmony export */   PollingEventSubscriber: () => (/* binding */ PollingEventSubscriber),\n/* harmony export */   PollingOrphanSubscriber: () => (/* binding */ PollingOrphanSubscriber),\n/* harmony export */   PollingTransactionSubscriber: () => (/* binding */ PollingTransactionSubscriber),\n/* harmony export */   getPollingSubscriber: () => (/* binding */ getPollingSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\",\n        info: {\n            event\n        }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */ get pollingInterval() {\n        return this.#interval;\n    }\n    set pollingInterval(value) {\n        this.#interval = value;\n    }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for(let b = this.#blockNumber + 1; b <= blockNumber; b++){\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        } catch (error) {\n        // @TODO: Minor bump, add an \"error\" event to let subscribers\n        //        know things went awry.\n        //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber)=>{\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */ async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter){\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */ constructor(provider, hash){\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */ constructor(provider, filter){\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs){\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber)=>{\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n} //# sourceMappingURL=subscriber-polling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLXBvbGxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDeEQsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7O0NBSUMsR0FDTSxTQUFTSSxxQkFBcUJDLFFBQVEsRUFBRUMsS0FBSztJQUNoRCxJQUFJQSxVQUFVLFNBQVM7UUFDbkIsT0FBTyxJQUFJQyx1QkFBdUJGO0lBQ3RDO0lBQ0EsSUFBSVAsNERBQVdBLENBQUNRLE9BQU8sS0FBSztRQUN4QixPQUFPLElBQUlFLDZCQUE2QkgsVUFBVUM7SUFDdEQ7SUFDQVQsdURBQU1BLENBQUMsT0FBTyw2QkFBNkIseUJBQXlCO1FBQ2hFWSxXQUFXO1FBQXdCQyxNQUFNO1lBQUVKO1FBQU07SUFDckQ7QUFDSjtBQUNBLHVCQUF1QjtBQUN2Qjs7Ozs7Q0FLQyxHQUNNLE1BQU1DO0lBQ1QsQ0FBQ0YsUUFBUSxDQUFDO0lBQ1YsQ0FBQ00sTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNEQyxZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNNLE1BQU0sR0FBRztRQUNmLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQUc7UUFDakIsSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBRyxDQUFDO0lBQ3pCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJRSxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQUU7SUFDL0MsSUFBSUcsZ0JBQWdCQyxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ0osUUFBUSxHQUFHSTtJQUFPO0lBQ3JELE1BQU0sQ0FBQ0MsSUFBSTtRQUNQLElBQUk7WUFDQSxNQUFNSixjQUFjLE1BQU0sSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQ2EsY0FBYztZQUN2RCxtREFBbUQ7WUFDbkQsSUFBSSxJQUFJLENBQUMsQ0FBQ0wsV0FBVyxLQUFLLENBQUMsR0FBRztnQkFDMUIsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7Z0JBQ3BCO1lBQ0o7WUFDQSw2REFBNkQ7WUFDN0QsSUFBSUEsZ0JBQWdCLElBQUksQ0FBQyxDQUFDQSxXQUFXLEVBQUU7Z0JBQ25DLElBQUssSUFBSU0sSUFBSSxJQUFJLENBQUMsQ0FBQ04sV0FBVyxHQUFHLEdBQUdNLEtBQUtOLGFBQWFNLElBQUs7b0JBQ3ZELHVCQUF1QjtvQkFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQ1IsTUFBTSxJQUFJLE1BQU07d0JBQ3RCO29CQUNKO29CQUNBLE1BQU0sSUFBSSxDQUFDLENBQUNOLFFBQVEsQ0FBQ2UsSUFBSSxDQUFDLFNBQVNEO2dCQUN2QztnQkFDQSxJQUFJLENBQUMsQ0FBQ04sV0FBVyxHQUFHQTtZQUN4QjtRQUNKLEVBQ0EsT0FBT1EsT0FBTztRQUNWLDZEQUE2RDtRQUM3RCxnQ0FBZ0M7UUFDaEMscUJBQXFCO1FBQ3pCO1FBQ0EsdUJBQXVCO1FBQ3ZCLElBQUksSUFBSSxDQUFDLENBQUNWLE1BQU0sSUFBSSxNQUFNO1lBQ3RCO1FBQ0o7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDTixRQUFRLENBQUNpQixXQUFXLENBQUMsSUFBSSxDQUFDLENBQUNMLElBQUksQ0FBQ00sSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQ1gsUUFBUTtJQUNuRjtJQUNBWSxRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ2IsTUFBTSxFQUFFO1lBQ2Q7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDQSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUNOLFFBQVEsQ0FBQ2lCLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQ0wsSUFBSSxDQUFDTSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDWCxRQUFRO1FBQy9FLElBQUksQ0FBQyxDQUFDSyxJQUFJO0lBQ2Q7SUFDQVEsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxFQUFFO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDTixRQUFRLENBQUNxQixhQUFhLENBQUMsSUFBSSxDQUFDLENBQUNmLE1BQU07UUFDekMsSUFBSSxDQUFDLENBQUNBLE1BQU0sR0FBRztJQUNuQjtJQUNBZ0IsTUFBTUMsZUFBZSxFQUFFO1FBQ25CLElBQUksQ0FBQ0gsSUFBSTtRQUNULElBQUlHLGlCQUFpQjtZQUNqQixJQUFJLENBQUMsQ0FBQ2YsV0FBVyxHQUFHLENBQUM7UUFDekI7SUFDSjtJQUNBZ0IsU0FBUztRQUNMLElBQUksQ0FBQ0wsS0FBSztJQUNkO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1NO0lBQ1QsQ0FBQ3pCLFFBQVEsQ0FBQztJQUNWLENBQUNZLElBQUksQ0FBQztJQUNOLENBQUNjLE9BQU8sQ0FBQztJQUNUOztLQUVDLEdBQ0RqQixZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUMwQixPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNkLElBQUksR0FBRyxDQUFDSjtZQUNWLElBQUksQ0FBQ21CLEtBQUssQ0FBQ25CLGFBQWEsSUFBSSxDQUFDLENBQUNSLFFBQVE7UUFDMUM7SUFDSjtJQUNBOztLQUVDLEdBQ0QsTUFBTTJCLE1BQU1uQixXQUFXLEVBQUVSLFFBQVEsRUFBRTtRQUMvQixNQUFNLElBQUk0QixNQUFNO0lBQ3BCO0lBQ0FULFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQyxDQUFDTyxPQUFPLEVBQUU7WUFDZjtRQUNKO1FBQ0EsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQ2QsSUFBSSxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsQ0FBQ1osUUFBUSxDQUFDNkIsRUFBRSxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUNqQixJQUFJO0lBQ3pDO0lBQ0FRLE9BQU87UUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNNLE9BQU8sRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQzFCLFFBQVEsQ0FBQzhCLEdBQUcsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDbEIsSUFBSTtJQUMxQztJQUNBVSxNQUFNQyxlQUFlLEVBQUU7UUFBRSxJQUFJLENBQUNILElBQUk7SUFBSTtJQUN0Q0ksU0FBUztRQUFFLElBQUksQ0FBQ0wsS0FBSztJQUFJO0FBQzdCO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1ZLGdDQUFnQ047SUFDekMsQ0FBQ08sTUFBTSxDQUFDO0lBQ1J2QixZQUFZVCxRQUFRLEVBQUVnQyxNQUFNLENBQUU7UUFDMUIsS0FBSyxDQUFDaEM7UUFDTixJQUFJLENBQUMsQ0FBQ2dDLE1BQU0sR0FBR3RDLEtBQUtzQztJQUN4QjtJQUNBLE1BQU1MLE1BQU1uQixXQUFXLEVBQUVSLFFBQVEsRUFBRTtRQUMvQixNQUFNLElBQUk0QixNQUFNO1FBQ2hCSyxRQUFRQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNGLE1BQU07SUFDNUI7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sTUFBTTdCLHFDQUFxQ3NCO0lBQzlDLENBQUNVLElBQUksQ0FBQztJQUNOOzs7S0FHQyxHQUNEMUIsWUFBWVQsUUFBUSxFQUFFbUMsSUFBSSxDQUFFO1FBQ3hCLEtBQUssQ0FBQ25DO1FBQ04sSUFBSSxDQUFDLENBQUNtQyxJQUFJLEdBQUdBO0lBQ2pCO0lBQ0EsTUFBTVIsTUFBTW5CLFdBQVcsRUFBRVIsUUFBUSxFQUFFO1FBQy9CLE1BQU1vQyxLQUFLLE1BQU1wQyxTQUFTcUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUNGLElBQUk7UUFDMUQsSUFBSUMsSUFBSTtZQUNKcEMsU0FBU2UsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDb0IsSUFBSSxFQUFFQztRQUM5QjtJQUNKO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUU7SUFDVCxDQUFDdEMsUUFBUSxDQUFDO0lBQ1YsQ0FBQ2dDLE1BQU0sQ0FBQztJQUNSLENBQUMxQixNQUFNLENBQUM7SUFDUixDQUFDb0IsT0FBTyxDQUFDO0lBQ1QsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRCxDQUFDbEIsV0FBVyxDQUFDO0lBQ2I7OztLQUdDLEdBQ0RDLFlBQVlULFFBQVEsRUFBRWdDLE1BQU0sQ0FBRTtRQUMxQixJQUFJLENBQUMsQ0FBQ2hDLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNnQyxNQUFNLEdBQUd0QyxLQUFLc0M7UUFDcEIsSUFBSSxDQUFDLENBQUMxQixNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUNNLElBQUksQ0FBQ00sSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDLENBQUNRLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQ2xCLFdBQVcsR0FBRyxDQUFDO0lBQ3pCO0lBQ0EsTUFBTSxDQUFDSSxJQUFJLENBQUNKLFdBQVc7UUFDbkIsK0NBQStDO1FBQy9DLElBQUksSUFBSSxDQUFDLENBQUNBLFdBQVcsS0FBSyxDQUFDLEdBQUc7WUFDMUI7UUFDSjtRQUNBLE1BQU13QixTQUFTdEMsS0FBSyxJQUFJLENBQUMsQ0FBQ3NDLE1BQU07UUFDaENBLE9BQU9PLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQy9CLFdBQVcsR0FBRztRQUN2Q3dCLE9BQU9RLE9BQU8sR0FBR2hDO1FBQ2pCLE1BQU1pQyxPQUFPLE1BQU0sSUFBSSxDQUFDLENBQUN6QyxRQUFRLENBQUMwQyxPQUFPLENBQUNWO1FBQzFDLDZEQUE2RDtRQUM3RCw0REFBNEQ7UUFDNUQsSUFBSVMsS0FBS0UsTUFBTSxLQUFLLEdBQUc7WUFDbkIsSUFBSSxJQUFJLENBQUMsQ0FBQ25DLFdBQVcsR0FBR0EsY0FBYyxJQUFJO2dCQUN0QyxJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHQSxjQUFjO1lBQ3RDO1lBQ0E7UUFDSjtRQUNBLEtBQUssTUFBTTBCLE9BQU9PLEtBQU07WUFDcEIsSUFBSSxDQUFDLENBQUN6QyxRQUFRLENBQUNlLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2lCLE1BQU0sRUFBRUU7WUFDbEMsd0RBQXdEO1lBQ3hELHdEQUF3RDtZQUN4RCxvREFBb0Q7WUFDcEQsSUFBSSxDQUFDLENBQUMxQixXQUFXLEdBQUcwQixJQUFJMUIsV0FBVztRQUN2QztJQUNKO0lBQ0FXLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQyxDQUFDTyxPQUFPLEVBQUU7WUFDZjtRQUNKO1FBQ0EsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBRztRQUNoQixJQUFJLElBQUksQ0FBQyxDQUFDbEIsV0FBVyxLQUFLLENBQUMsR0FBRztZQUMxQixJQUFJLENBQUMsQ0FBQ1IsUUFBUSxDQUFDYSxjQUFjLEdBQUcrQixJQUFJLENBQUMsQ0FBQ3BDO2dCQUNsQyxJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHQTtZQUN4QjtRQUNKO1FBQ0EsSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQzZCLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDdkIsTUFBTTtJQUMzQztJQUNBYyxPQUFPO1FBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDTSxPQUFPLEVBQUU7WUFDaEI7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDQSxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUMxQixRQUFRLENBQUM4QixHQUFHLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQ3hCLE1BQU07SUFDNUM7SUFDQWdCLE1BQU1DLGVBQWUsRUFBRTtRQUNuQixJQUFJLENBQUNILElBQUk7UUFDVCxJQUFJRyxpQkFBaUI7WUFDakIsSUFBSSxDQUFDLENBQUNmLFdBQVcsR0FBRyxDQUFDO1FBQ3pCO0lBQ0o7SUFDQWdCLFNBQVM7UUFDTCxJQUFJLENBQUNMLEtBQUs7SUFDZDtBQUNKLEVBQ0EsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzP2YyY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBwb2xsaW5nIGV2ZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxuICAgIH0pO1xufVxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcbi8qKlxuICogIEEgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogcG9sbHMgYXQgYSByZWd1bGFyIGludGVydmFsIGZvciBhIGNoYW5nZVxuICogIGluIHRoZSBibG9jayBudW1iZXIuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjaW50ZXJ2YWw7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNpbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jaW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cbiAgICBhc3luYyAjcG9sbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCBwb2xsIHRvIHNldHVwIG91ciBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyICE9PSB0aGlzLiNibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSB0aGlzLiNibG9ja051bWJlciArIDE7IGIgPD0gYmxvY2tOdW1iZXI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTWlub3IgYnVtcCwgYWRkIGFuIFwiZXJyb3JcIiBldmVudCB0byBsZXQgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIC8vICAgICAgICBrbm93IHRoaW5ncyB3ZW50IGF3cnkuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICAgICAgdGhpcy4jcG9sbCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9jbGVhclRpbWVvdXQodGhpcy4jcG9sbGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cbiAqICBpbXBsbWVudGF0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGw7XG4gICAgI3J1bm5pbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk9uQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9sbChibG9ja051bWJlciwgdGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB0aGlzLnN0b3AoKTsgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNmaWx0ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiNmaWx0ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNoYXNoO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlaGFzaCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcbiAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2hhc2gsIHR4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIGZpbHRlciBmb3IgaXRzIGxvZ3MuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIFRoZSBpbml0aWFsIGJsb2NrIGhhc24ndCBiZWVuIGRldGVybWluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjb3B5KHRoaXMuI2ZpbHRlcik7XG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XG4gICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcbiAgICAgICAgLy8gc28gd2Uga2VlcCBhIHNsaWRpbmcgd2luZG93IG9mIDYwIGJsb2NrcyB0byBrZWVwIHNjYW5uaW5nXG4gICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWR2YW5jZSB0aGUgYmxvY2sgbnVtYmVyIHdoZW4gbG9ncyB3ZXJlIGZvdW5kIHRvXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBuZXR3b3JrcyAobGlrZSBCTkIgYW5kIFBvbHlnb24pIHdoaWNoIG1heVxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydCIsImlzSGV4U3RyaW5nIiwiY29weSIsIm9iaiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImdldFBvbGxpbmdTdWJzY3JpYmVyIiwicHJvdmlkZXIiLCJldmVudCIsIlBvbGxpbmdCbG9ja1N1YnNjcmliZXIiLCJQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIiwib3BlcmF0aW9uIiwiaW5mbyIsInBvbGxlciIsImludGVydmFsIiwiYmxvY2tOdW1iZXIiLCJjb25zdHJ1Y3RvciIsInBvbGxpbmdJbnRlcnZhbCIsInZhbHVlIiwicG9sbCIsImdldEJsb2NrTnVtYmVyIiwiYiIsImVtaXQiLCJlcnJvciIsIl9zZXRUaW1lb3V0IiwiYmluZCIsInN0YXJ0Iiwic3RvcCIsIl9jbGVhclRpbWVvdXQiLCJwYXVzZSIsImRyb3BXaGlsZVBhdXNlZCIsInJlc3VtZSIsIk9uQmxvY2tTdWJzY3JpYmVyIiwicnVubmluZyIsIl9wb2xsIiwiRXJyb3IiLCJvbiIsIm9mZiIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiZmlsdGVyIiwiY29uc29sZSIsImxvZyIsImhhc2giLCJ0eCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibG9ncyIsImdldExvZ3MiLCJsZW5ndGgiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/providers/subscriber-polling.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n} //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUNlO0FBQ2hFLFNBQVNHLGFBQWFDLElBQUksRUFBRUMsV0FBVztJQUNuQyxPQUFPO1FBQ0hDLFNBQVNOLDZEQUFVQSxDQUFDSTtRQUNwQkMsYUFBYUEsWUFBWUUsR0FBRyxDQUFDLENBQUNDLFlBQVlDO1lBQ3RDUiwrREFBY0EsQ0FBQ0MsNERBQVdBLENBQUNNLFlBQVksS0FBSyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUVDLE1BQU0sQ0FBQyxDQUFDLEVBQUVEO1lBQ3JGLE9BQU9BLFdBQVdFLFdBQVc7UUFDakM7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxTQUFTQyxjQUFjQyxLQUFLO0lBQy9CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN0QixPQUFPQSxNQUFNTCxHQUFHLENBQUMsQ0FBQ1EsS0FBS047WUFDbkIsSUFBSUksTUFBTUMsT0FBTyxDQUFDQyxNQUFNO2dCQUNwQmQsK0RBQWNBLENBQUNjLElBQUlDLE1BQU0sS0FBSyxHQUFHLG9CQUFvQixDQUFDLE1BQU0sRUFBRVAsTUFBTSxDQUFDLENBQUMsRUFBRU07Z0JBQ3hFLE9BQU9aLGFBQWFZLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFO1lBQ3RDO1lBQ0FkLCtEQUFjQSxDQUFDYyxPQUFPLFFBQVEsT0FBUUEsUUFBUyxVQUFVLDRCQUE0QixTQUFTSDtZQUM5RixPQUFPVCxhQUFhWSxJQUFJVCxPQUFPLEVBQUVTLElBQUlWLFdBQVc7UUFDcEQ7SUFDSjtJQUNBSiwrREFBY0EsQ0FBQ1csU0FBUyxRQUFRLE9BQVFBLFVBQVcsVUFBVSx1QkFBdUIsU0FBU0E7SUFDN0YsTUFBTUssU0FBU0MsT0FBT0MsSUFBSSxDQUFDUCxPQUFPTCxHQUFHLENBQUMsQ0FBQ0g7UUFDbkMsTUFBTUMsY0FBY08sS0FBSyxDQUFDUixLQUFLLENBQUNnQixNQUFNLENBQUMsQ0FBQ0MsT0FBT2I7WUFDM0NhLEtBQUssQ0FBQ2IsV0FBVyxHQUFHO1lBQ3BCLE9BQU9hO1FBQ1gsR0FBRyxDQUFDO1FBQ0osT0FBT2xCLGFBQWFDLE1BQU1jLE9BQU9DLElBQUksQ0FBQ2QsYUFBYWlCLElBQUk7SUFDM0Q7SUFDQUwsT0FBT0ssSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU9ELEVBQUVqQixPQUFPLENBQUNtQixhQUFhLENBQUNELEVBQUVsQixPQUFPO0lBQ3hELE9BQU9XO0FBQ1gsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanM/ZWQ0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWNjZXNzIGxpc3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiYXNzZXJ0QXJndW1lbnQiLCJpc0hleFN0cmluZyIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsImFkZHJlc3MiLCJtYXAiLCJzdG9yYWdlS2V5IiwiaW5kZXgiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc0xpc3RpZnkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInNldCIsImxlbmd0aCIsInJlc3VsdCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js":
/*!****************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/transaction/address.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */ function computeAddress(key) {\n    let pubkey;\n    if (typeof key === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */ function recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUQ7QUFDVTtBQUMzRDs7OztDQUlDLEdBQ00sU0FBU0csZUFBZUMsR0FBRztJQUM5QixJQUFJQztJQUNKLElBQUksT0FBUUQsUUFBUyxVQUFVO1FBQzNCQyxTQUFTSCx3REFBVUEsQ0FBQ0ksZ0JBQWdCLENBQUNGLEtBQUs7SUFDOUMsT0FDSztRQUNEQyxTQUFTRCxJQUFJRyxTQUFTO0lBQzFCO0lBQ0EsT0FBT1AsNkRBQVVBLENBQUNDLDJEQUFTQSxDQUFDLE9BQU9JLE9BQU9HLFNBQVMsQ0FBQyxJQUFJQSxTQUFTLENBQUM7QUFDdEU7QUFDQTs7O0NBR0MsR0FDTSxTQUFTQyxlQUFlQyxNQUFNLEVBQUVDLFNBQVM7SUFDNUMsT0FBT1IsZUFBZUQsd0RBQVVBLENBQUNVLGdCQUFnQixDQUFDRixRQUFRQztBQUM5RCxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcz9kYmIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlICUla2V5JSUuXG4gKlxuICogIFRoZSBrZXkgbWF5IGJlIGFueSBzdGFuZGFyZCBmb3JtIG9mIHB1YmxpYyBrZXkgb3IgYSBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwdWJrZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWJrZXkgPSBrZXkucHVibGljS2V5O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhrZWNjYWsyNTYoXCIweFwiICsgcHVia2V5LnN1YnN0cmluZyg0KSkuc3Vic3RyaW5nKDI2KSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSByZWNvdmVyZWQgYWRkcmVzcyBmb3IgdGhlIHByaXZhdGUga2V5IHRoYXQgd2FzXG4gKiAgdXNlZCB0byBzaWduICUlZGlnZXN0JSUgdGhhdCByZXN1bHRlZCBpbiAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwiU2lnbmluZ0tleSIsImNvbXB1dGVBZGRyZXNzIiwia2V5IiwicHVia2V5IiwiY29tcHV0ZVB1YmxpY0tleSIsInB1YmxpY0tleSIsInN1YnN0cmluZyIsInJlY292ZXJBZGRyZXNzIiwiZGlnZXN0Iiwic2lnbmF0dXJlIiwicmVjb3ZlclB1YmxpY0tleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/transaction/transaction.js":
/*!********************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accesslist.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./address.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(value);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    } else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[8], 32),\n            v\n        });\n        tx.hash = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\"\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from({\n        r,\n        s,\n        yParity\n    });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data));\n    const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n    const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\")\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    tx.hash = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\",\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n        \"0x02\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    tx.hash = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\",\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n        \"0x01\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */ class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */ get type() {\n        return this.#type;\n    }\n    set type(value) {\n        switch(value){\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */ get typeName() {\n        switch(this.type){\n            case 0:\n                return \"legacy\";\n            case 1:\n                return \"eip-2930\";\n            case 2:\n                return \"eip-1559\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */ get to() {\n        return this.#to;\n    }\n    set to(value) {\n        this.#to = value == null ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */ get nonce() {\n        return this.#nonce;\n    }\n    set nonce(value) {\n        this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value, \"value\");\n    }\n    /**\n     *  The gas limit.\n     */ get gasLimit() {\n        return this.#gasLimit;\n    }\n    set gasLimit(value) {\n        this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value);\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */ get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */ get data() {\n        return this.#data;\n    }\n    set data(value) {\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value);\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */ get value() {\n        return this.#value;\n    }\n    set value(value) {\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value);\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */ get signature() {\n        return this.#sig || null;\n    }\n    set signature(value) {\n        this.#sig = value == null ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */ get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2) {\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = value == null ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(value);\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */ constructor(){\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BigInt(0);\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BigInt(0);\n        this.#chainId = BigInt(0);\n        this.#sig = null;\n        this.#accessList = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */ get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */ get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */ get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_9__.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */ get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */ isSigned() {\n        //isSigned(): this is SignedTransaction {\n        return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */ get serialized() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */ get unsignedSerialized() {\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".unsignedSerialized\"\n        });\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */ inferType() {\n        return this.inferTypes().pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */ inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n        const hasAccessList = this.accessList != null;\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n                value: this\n            });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n            value: this\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n            value: this\n        });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        } else {\n            if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */ clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */ toJSON() {\n        const s = (v)=>{\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */ static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof tx === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx);\n            if (payload[0] >= 0x7f) {\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch(payload[0]){\n                case 1:\n                    return Transaction.from(_parseEip2930(payload));\n                case 2:\n                    return Transaction.from(_parseEip1559(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"from\"\n            });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNxQjtBQUNxRjtBQUMzRztBQUNGO0FBQzlDLE1BQU1pQixPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsTUFBTUUsUUFBUUYsT0FBTztBQUNyQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssY0FBY0wsT0FBTztBQUMzQixTQUFTTSxjQUFjQyxLQUFLO0lBQ3hCLElBQUlBLFVBQVUsTUFBTTtRQUNoQixPQUFPO0lBQ1g7SUFDQSxPQUFPekIsNkRBQVVBLENBQUN5QjtBQUN0QjtBQUNBLFNBQVNDLGlCQUFpQkQsS0FBSyxFQUFFRSxLQUFLO0lBQ2xDLElBQUk7UUFDQSxPQUFPWiw2REFBYUEsQ0FBQ1U7SUFDekIsRUFDQSxPQUFPRyxPQUFPO1FBQ1ZoQiwrREFBY0EsQ0FBQyxPQUFPZ0IsTUFBTUMsT0FBTyxFQUFFRixPQUFPRjtJQUNoRDtBQUNKO0FBQ0EsU0FBU0ssYUFBYUMsTUFBTSxFQUFFSixLQUFLO0lBQy9CLElBQUlJLFdBQVcsTUFBTTtRQUNqQixPQUFPO0lBQ1g7SUFDQSxPQUFPdEIsMERBQVNBLENBQUNzQixRQUFRSjtBQUM3QjtBQUNBLFNBQVNLLFdBQVdELE1BQU0sRUFBRUosS0FBSztJQUM3QixJQUFJSSxXQUFXLE1BQU07UUFDakIsT0FBT2Q7SUFDWDtJQUNBLE1BQU1RLFFBQVFqQiwwREFBU0EsQ0FBQ3VCLFFBQVFKO0lBQ2hDZiwrREFBY0EsQ0FBQ2EsU0FBU0YsYUFBYSwyQkFBMkJJLE9BQU9GO0lBQ3ZFLE9BQU9BO0FBQ1g7QUFDQSxTQUFTUSxhQUFhRixNQUFNLEVBQUVHLElBQUk7SUFDOUIsTUFBTVQsUUFBUWpCLDBEQUFTQSxDQUFDdUIsUUFBUTtJQUNoQyxNQUFNSSxTQUFTdEIs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T1o7SUFDWDtBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcz80NTk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduYXR1cmUsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlY29kZVJscCwgZW5jb2RlUmxwLCBnZXRCeXRlcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIHRvQmVBcnJheSwgemVyb1BhZFZhbHVlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4vYWNjZXNzbGlzdC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NMaXN0KHZhbHVlLCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcihfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TnVtYmVyKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIHBhcmFtKTtcbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gNiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9uXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMCxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1sxXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbM10pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNF0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgIT09IEJOXzAgfHwgKHYgPT09IEJOXzI3IHx8IHYgPT09IEJOXzI4KSwgXCJub24tY2Fub25pY2FsIGxlZ2FjeSB2XCIsIFwidlwiLCBmaWVsZHNbNl0pO1xuICAgICAgICB0eC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzddLCAzMiksXG4gICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzhdLCAzMiksXG4gICAgICAgICAgICB2XG4gICAgICAgIH0pO1xuICAgICAgICB0eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgIF07XG4gICAgbGV0IGNoYWluSWQgPSBCTl8wO1xuICAgIGlmICh0eC5jaGFpbklkICE9IEJOXzApIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IGdldEJpZ0ludCh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFncmVlIHdpdGggZWFjaCBvdGhlclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KGNoYWluSWQpKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xuICAgIC8vICAgICAgICBtYXRjaCBidXQgdGhhdCBsb2dpYyBjb3VsZCBicmVhayBleGlzdGluZyBjb2RlLCBzbyBzY2hlZHVsZVxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxuICAgIGxldCB2ID0gQmlnSW50KDI3ICsgc2lnLnlQYXJpdHkpO1xuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgIHYgPSBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgc2lnLnYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCaWdJbnQoc2lnLnYpICE9PSB2KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkodikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XG4gICAgbGV0IHlQYXJpdHk7XG4gICAgdHJ5IHtcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHlQYXJpdHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiLCBcInlQYXJpdHlcIiwgZmllbGRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgciA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMV0sIDMyKTtcbiAgICBjb25zdCBzID0gemVyb1BhZFZhbHVlKGZpZWxkc1syXSwgMzIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHsgciwgcywgeVBhcml0eSB9KTtcbiAgICB0eC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSAxMiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKTtcbiAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDIsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDkpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg4KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHR4LnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0eC50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHR4LmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDFcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvbioqIGRlc2NyaWJlcyBhbiBvcGVyYXRpb24gdG8gYmUgZXhlY3V0ZWQgb25cbiAqICBFdGhlcmV1bSBieSBhbiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuIEl0IGluY2x1ZGVzXG4gKiAgd2hvICh0aGUgW1t0b11dIGFkZHJlc3MpLCB3aGF0ICh0aGUgW1tkYXRhXV0pIGFuZCBob3cgbXVjaCAodGhlXG4gKiAgW1t2YWx1ZV1dIGluIGV0aGVyKSB0aGUgb3BlcmF0aW9uIHNob3VsZCBlbnRhaWwuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHR4LmRhdGEgPSBcIjB4MTIzNFwiO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgICN0eXBlO1xuICAgICN0bztcbiAgICAjZGF0YTtcbiAgICAjbm9uY2U7XG4gICAgI2dhc0xpbWl0O1xuICAgICNnYXNQcmljZTtcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgI21heEZlZVBlckdhcztcbiAgICAjdmFsdWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3NpZztcbiAgICAjYWNjZXNzTGlzdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiAgSWYgbnVsbCwgdGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGJhc2VkIG9uXG4gICAgICogIGV4cGxpY2l0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLiN0eXBlOyB9XG4gICAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSBcImxlZ2FjeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImJlcmxpblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0yOTMwXCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwibG9uZG9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTE1NTlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuI3RvOyB9XG4gICAgc2V0IHRvKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3RvID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIG5vbmNlLlxuICAgICAqL1xuICAgIGdldCBub25jZSgpIHsgcmV0dXJuIHRoaXMuI25vbmNlOyB9XG4gICAgc2V0IG5vbmNlKHZhbHVlKSB7IHRoaXMuI25vbmNlID0gZ2V0TnVtYmVyKHZhbHVlLCBcInZhbHVlXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgbGltaXQuXG4gICAgICovXG4gICAgZ2V0IGdhc0xpbWl0KCkgeyByZXR1cm4gdGhpcy4jZ2FzTGltaXQ7IH1cbiAgICBzZXQgZ2FzTGltaXQodmFsdWUpIHsgdGhpcy4jZ2FzTGltaXQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzIHRoaXMgZGVmaW5lcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBwYWlkLiBPblxuICAgICAqICBFSVAtMTU1OSBuZXR3b3JrcywgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGdhc1ByaWNlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2dhc1ByaWNlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAodGhpcy50eXBlID09PSAwIHx8IHRoaXMudHlwZSA9PT0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGdhc1ByaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJnYXNQcmljZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdG90YWwgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYGBpbml0YGAgdHJhbnNhY3Rpb25zIHRoaXMgaXMgdGhlXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gaGV4bGlmeSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBldGhlciAoaW4gd2VpKSB0byBzZW5kIGluIHRoaXMgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbHVlOyB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZ2V0QmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgSWYgc2lnbmVkLCB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxuICAgIHNldCBzaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgVHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RvID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbm9uY2UgPSAwO1xuICAgICAgICB0aGlzLiNnYXNMaW1pdCA9IEJpZ0ludCgwKTtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBcIjB4XCI7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNzaWcgPSBudWxsO1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJlLWltYWdlIGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgc2lnbmVkLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcbiAgICAgKiAgdHJhbnNhY3Rpb24gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICAvL2lzU2lnbmVkKCk6IHRoaXMgaXMgU2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmUgIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5zaWduYXR1cmUgIT0gbnVsbCwgXCJjYW5ub3Qgc2VyaWFsaXplIHVuc2lnbmVkIHRyYW5zYWN0aW9uOyBtYXliZSB5b3UgbWVhbnQgLnVuc2lnbmVkU2VyaWFsaXplZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodGhpcywgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlLlxuICAgICAqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cbiAgICAgKiAgYXV0aG9yaXplIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmluZmVyVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcyk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIudW5zaWduZWRTZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIG1vc3QgXCJsaWtlbHlcIiB0eXBlOyBjdXJyZW50bHkgdGhlIGhpZ2hlc3RcbiAgICAgKiAgc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgaW5mZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5mZXJUeXBlcygpLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlcyB0aGUgZXhwbGljaXQgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGF0aWJsZVxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpbmZlclR5cGVzKCkge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0ZlZSA9ICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xuICAgICAgICAvL2lmIChoYXNHYXNQcmljZSAmJiBoYXNGZWUpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2UgYW5kIG1heEZlZVBlckdhc1wiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMubWF4RmVlUGVyR2FzID49IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsIFwicHJpb3JpdHlGZWUgY2Fubm90IGJlIG1vcmUgdGhhbiBtYXhGZWVcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZVwiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGFzc2VydCghaGFzRmVlIHx8ICh0aGlzLnR5cGUgIT09IDAgJiYgdGhpcy50eXBlICE9PSAxKSwgXCJ0cmFuc2FjdGlvbiB0eXBlIGNhbm5vdCBoYXZlIG1heEZlZVBlckdhcyBvciBtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGFzc2VydCh0aGlzLnR5cGUgIT09IDAgfHwgIWhhc0FjY2Vzc0xpc3QsIFwibGVnYWN5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGFjY2Vzc0xpc3RcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICAvLyBFeHBsaWNpdCB0eXBlXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0ZlZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR5cGVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGJlcmxpbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgdHJhbnNhY2l0b24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgSlNPTi1mcmllbmRseSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzID0gKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNMaW1pdDogcyh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBzKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHModGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHModGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgdmFsdWU6IHModGhpcy52YWx1ZSksXG4gICAgICAgICAgICBjaGFpbklkOiBzKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBzaWc6IHRoaXMuc2lnbmF0dXJlID8gdGhpcy5zaWduYXR1cmUudG9KU09OKCkgOiBudWxsLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSAqKlRyYW5zYWN0aW9uKiogZnJvbSBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb3IgYVxuICAgICAqICBUcmFuc2FjdGlvbi1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eCkge1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGdldEJ5dGVzKHR4KTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkWzBdID49IDB4N2YpIHsgLy8gQFRPRE86ID4gdnMgPj0gPz9cbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VMZWdhY3kocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAyOTMwKHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDE1NTkocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZnJvbVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodHgudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50byA9IHR4LnRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odHguc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmhhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSBoYXNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0Lmhhc2ggPT09IHR4Lmhhc2gsIFwiaGFzaCBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lIGZyb21cIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuZnJvbS50b0xvd2VyQ2FzZSgpID09PSAodHguZnJvbSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLCBcImZyb20gbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImtlY2NhazI1NiIsIlNpZ25hdHVyZSIsIlNpZ25pbmdLZXkiLCJjb25jYXQiLCJkZWNvZGVSbHAiLCJlbmNvZGVSbHAiLCJnZXRCeXRlcyIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsInRvQmVBcnJheSIsInplcm9QYWRWYWx1ZSIsImFjY2Vzc0xpc3RpZnkiLCJyZWNvdmVyQWRkcmVzcyIsIkJOXzAiLCJCaWdJbnQiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwiQk5fTUFYX1VJTlQiLCJoYW5kbGVBZGRyZXNzIiwidmFsdWUiLCJoYW5kbGVBY2Nlc3NMaXN0IiwicGFyYW0iLCJlcnJvciIsIm1lc3NhZ2UiLCJoYW5kbGVOdW1iZXIiLCJfdmFsdWUiLCJoYW5kbGVVaW50IiwiZm9ybWF0TnVtYmVyIiwibmFtZSIsInJlc3VsdCIsImxlbmd0aCIsImZvcm1hdEFjY2Vzc0xpc3QiLCJtYXAiLCJzZXQiLCJhZGRyZXNzIiwic3RvcmFnZUtleXMiLCJfcGFyc2VMZWdhY3kiLCJkYXRhIiwiZmllbGRzIiwiQXJyYXkiLCJpc0FycmF5IiwidHgiLCJ0eXBlIiwibm9uY2UiLCJnYXNQcmljZSIsImdhc0xpbWl0IiwidG8iLCJjaGFpbklkIiwidiIsInIiLCJzIiwic2lnbmF0dXJlIiwiZnJvbSIsImhhc2giLCJfc2VyaWFsaXplTGVnYWN5Iiwic2lnIiwibmV0d29ya1YiLCJsZWdhY3lDaGFpbklkIiwibGVnYWN5IiwicHVzaCIsInlQYXJpdHkiLCJnZXRDaGFpbklkViIsIl9wYXJzZUVpcFNpZ25hdHVyZSIsIkVycm9yIiwiX3BhcnNlRWlwMTU1OSIsInNsaWNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJhY2Nlc3NMaXN0IiwiX3NlcmlhbGl6ZUVpcDE1NTkiLCJfcGFyc2VFaXAyOTMwIiwiX3NlcmlhbGl6ZUVpcDI5MzAiLCJUcmFuc2FjdGlvbiIsInR5cGVOYW1lIiwiY29uc3RydWN0b3IiLCJzZXJpYWxpemVkIiwidW5zaWduZWRIYXNoIiwidW5zaWduZWRTZXJpYWxpemVkIiwiZnJvbVB1YmxpY0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJpc1NpZ25lZCIsIm9wZXJhdGlvbiIsImluZmVyVHlwZSIsImluZmVyVHlwZXMiLCJwb3AiLCJoYXNHYXNQcmljZSIsImhhc0ZlZSIsImhhc0FjY2Vzc0xpc3QiLCJ0eXBlcyIsInNvcnQiLCJpc0xlZ2FjeSIsImlzQmVybGluIiwiaXNMb25kb24iLCJjbG9uZSIsInRvSlNPTiIsInRvU3RyaW5nIiwicGF5bG9hZCIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/transaction/transaction.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/base58.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/base58.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: () => (/* binding */ decodeBase58),\n/* harmony export */   encodeBase58: () => (/* binding */ encodeBase58)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */ \n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for(let i = 0; i < Alphabet.length; i++){\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */ function encodeBase58(_value) {\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_value));\n    let result = \"\";\n    while(value){\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */ function decodeBase58(value) {\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n} //# sourceMappingURL=base58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U1OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNvQztBQUNRO0FBQ1A7QUFDdEMsTUFBTUcsV0FBVztBQUNqQixJQUFJQyxTQUFTO0FBQ2IsU0FBU0MsU0FBU0MsTUFBTTtJQUNwQixJQUFJRixVQUFVLE1BQU07UUFDaEJBLFNBQVMsQ0FBQztRQUNWLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJSixTQUFTSyxNQUFNLEVBQUVELElBQUs7WUFDdENILE1BQU0sQ0FBQ0QsUUFBUSxDQUFDSSxFQUFFLENBQUMsR0FBR0UsT0FBT0Y7UUFDakM7SUFDSjtJQUNBLE1BQU1HLFNBQVNOLE1BQU0sQ0FBQ0UsT0FBTztJQUM3QkwsMERBQWNBLENBQUNTLFVBQVUsTUFBTSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsVUFBVUo7SUFDakUsT0FBT0k7QUFDWDtBQUNBLE1BQU1DLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsUUFBUUgsT0FBTztBQUNyQjs7Q0FFQyxHQUNNLFNBQVNJLGFBQWFDLE1BQU07SUFDL0IsSUFBSUMsUUFBUWIsbURBQVFBLENBQUNGLGtEQUFRQSxDQUFDYztJQUM5QixJQUFJSixTQUFTO0lBQ2IsTUFBT0ssTUFBTztRQUNWTCxTQUFTUCxRQUFRLENBQUNhLE9BQU9ELFFBQVFILE9BQU8sR0FBR0Y7UUFDM0NLLFNBQVNIO0lBQ2I7SUFDQSxPQUFPRjtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTTyxhQUFhRixLQUFLO0lBQzlCLElBQUlMLFNBQVNDO0lBQ2IsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlRLE1BQU1QLE1BQU0sRUFBRUQsSUFBSztRQUNuQ0csVUFBVUU7UUFDVkYsVUFBVUwsU0FBU1UsS0FBSyxDQUFDUixFQUFFO0lBQy9CO0lBQ0EsT0FBT0c7QUFDWCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzPzAxZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIFtCYXNlNTggRW5jb2RpbmddKGxpbmstYmFzZTU4KSBzY2hlbWUgYWxsb3dzIGEgKipudW1lcmljKiogdmFsdWVcbiAqICB0byBiZSBlbmNvZGVkIGFzIGEgY29tcGFjdCBzdHJpbmcgdXNpbmcgYSByYWRpeCBvZiA1OCB1c2luZyBvbmx5XG4gKiAgYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLiBDb25mdXNpbmdseSBzaW1pbGFyIGNoYXJhY3RlcnMgYXJlIG9taXR0ZWRcbiAqICAoaS5lLiBgYFwibDBPXCJgYCkuXG4gKlxuICogIE5vdGUgdGhhdCBCYXNlNTggZW5jb2RlcyBhICoqbnVtZXJpYyoqIHZhbHVlLCBub3QgYXJiaXRyYXJ5IGJ5dGVzLFxuICogIHNpbmNlIGFueSB6ZXJvLWJ5dGVzIG9uIHRoZSBsZWZ0IHdvdWxkIGdldCByZW1vdmVkLiBUbyBtaXRpZ2F0ZSB0aGlzXG4gKiAgaXNzdWUgbW9zdCBzY2hlbWVzIHRoYXQgdXNlIEJhc2U1OCBjaG9vc2Ugc3BlY2lmaWMgaGlnaC1vcmRlciB2YWx1ZXNcbiAqICB0byBlbnN1cmUgbm9uLXplcm8gcHJlZml4ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOkJhc2U1OCBFbmNvZGluZyBbYWJvdXQtYmFzZTU4XVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xubGV0IExvb2t1cCA9IG51bGw7XG5mdW5jdGlvbiBnZXRBbHBoYShsZXR0ZXIpIHtcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcbiAgICAgICAgTG9va3VwID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0ICE9IG51bGwsIGBpbnZhbGlkIGJhc2U1OCB2YWx1ZWAsIFwibGV0dGVyXCIsIGxldHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl81OCA9IEJpZ0ludCg1OCk7XG4vKipcbiAqICBFbmNvZGUgJSV2YWx1ZSUlIGFzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSkpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIERlY29kZSB0aGUgQmFzZTU4LWVuY29kZWQgJSV2YWx1ZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTU4KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IEJOXzA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKj0gQk5fNTg7XG4gICAgICAgIHJlc3VsdCArPSBnZXRBbHBoYSh2YWx1ZVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNTguanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJ0b0JpZ0ludCIsIkFscGhhYmV0IiwiTG9va3VwIiwiZ2V0QWxwaGEiLCJsZXR0ZXIiLCJpIiwibGVuZ3RoIiwiQmlnSW50IiwicmVzdWx0IiwiQk5fMCIsIkJOXzU4IiwiZW5jb2RlQmFzZTU4IiwiX3ZhbHVlIiwidmFsdWUiLCJOdW1iZXIiLCJkZWNvZGVCYXNlNTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/base58.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/base64.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/base64.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode\n *  arbitrary bytes into a string using 65 printable symbols, the\n *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,\n *  ``\"+\"`` and ``\"/\"`` with the ``\"=\"`` used for padding.\n *\n *  @_subsection: api/utils:Base64 Encoding  [about-base64]\n */ \n/**\n *  Decodes the base-64 encoded %%value%%.\n *\n *  @example:\n *    // The decoded value is always binary data...\n *    result = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n *    //_result:\n *\n *    // ...use toUtf8String to convert it to a string.\n *    toUtf8String(result)\n *    //_result:\n *\n *    // Decoding binary data\n *    decodeBase64(\"EjQ=\")\n *    //_result:\n */ function decodeBase64(value) {\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(Buffer.from(value, \"base64\"));\n}\n;\n/**\n *  Encodes %%data%% as a base-64 encoded string.\n *\n *  @example:\n *    // Encoding binary data as a hexstring\n *    encodeBase64(\"0x1234\")\n *    //_result:\n *\n *    // Encoding binary data as a Uint8Array\n *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n *    //_result:\n *\n *    // The input MUST be data...\n *    encodeBase64(\"Hello World!!\")\n *    //_error:\n *\n *    // ...use toUtf8Bytes for this.\n *    encodeBase64(toUtf8Bytes(\"Hello World!!\"))\n *    //_result:\n */ function encodeBase64(data) {\n    return Buffer.from((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data)).toString(\"base64\");\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ2tEO0FBQ25EOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLFNBQVNFLGFBQWFDLEtBQUs7SUFDOUIsT0FBT0Ysc0RBQVlBLENBQUNHLE9BQU9DLElBQUksQ0FBQ0YsT0FBTztBQUMzQzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNHLGFBQWFDLElBQUk7SUFDN0IsT0FBT0gsT0FBT0MsSUFBSSxDQUFDTCxrREFBUUEsQ0FBQ08sT0FBT0MsUUFBUSxDQUFDO0FBQ2hELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQuanM/MDg5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBbQmFzZTY0IGVuY29kaW5nXShsaW5rLXdpa2ktYmFzZTY0KSB1c2luZyA2LWJpdCB3b3JkcyB0byBlbmNvZGVcbiAqICBhcmJpdHJhcnkgYnl0ZXMgaW50byBhIHN0cmluZyB1c2luZyA2NSBwcmludGFibGUgc3ltYm9scywgdGhlXG4gKiAgdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSBhbHBoYWJldCwgdGhlIGRpZ2l0cyBgYDBgYCB0aHJvdWdoIGBgOWBgLFxuICogIGBgXCIrXCJgYCBhbmQgYGBcIi9cImBgIHdpdGggdGhlIGBgXCI9XCJgYCB1c2VkIGZvciBwYWRkaW5nLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNjQgRW5jb2RpbmcgIFthYm91dC1iYXNlNjRdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzLCBnZXRCeXRlc0NvcHkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG4vKipcbiAqICBEZWNvZGVzIHRoZSBiYXNlLTY0IGVuY29kZWQgJSV2YWx1ZSUlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBiaW5hcnkgZGF0YS4uLlxuICogICAgcmVzdWx0ID0gZGVjb2RlQmFzZTY0KFwiU0dWc2JHOGdWMjl5YkdRaElRPT1cIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4U3RyaW5nIHRvIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuXG4gKiAgICB0b1V0ZjhTdHJpbmcocmVzdWx0KVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIERlY29kaW5nIGJpbmFyeSBkYXRhXG4gKiAgICBkZWNvZGVCYXNlNjQoXCJFalE9XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjQodmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKSk7XG59XG47XG4vKipcbiAqICBFbmNvZGVzICUlZGF0YSUlIGFzIGEgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBFbmNvZGluZyBiaW5hcnkgZGF0YSBhcyBhIGhleHN0cmluZ1xuICogICAgZW5jb2RlQmFzZTY0KFwiMHgxMjM0XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRW5jb2RpbmcgYmluYXJ5IGRhdGEgYXMgYSBVaW50OEFycmF5XG4gKiAgICBlbmNvZGVCYXNlNjQobmV3IFVpbnQ4QXJyYXkoWyAweDEyLCAweDM0IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRoZSBpbnB1dCBNVVNUIGJlIGRhdGEuLi5cbiAqICAgIGVuY29kZUJhc2U2NChcIkhlbGxvIFdvcmxkISFcIilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIC4uLnVzZSB0b1V0ZjhCeXRlcyBmb3IgdGhpcy5cbiAqICAgIGVuY29kZUJhc2U2NCh0b1V0ZjhCeXRlcyhcIkhlbGxvIFdvcmxkISFcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCYXNlNjQoZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShnZXRCeXRlcyhkYXRhKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiZGVjb2RlQmFzZTY0IiwidmFsdWUiLCJCdWZmZXIiLCJmcm9tIiwiZW5jb2RlQmFzZTY0IiwiZGF0YSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/base64.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/data.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/data.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDb0Q7QUFDckQsU0FBU0UsVUFBVUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDaEMsSUFBSUYsaUJBQWlCRyxZQUFZO1FBQzdCLElBQUlELE1BQU07WUFDTixPQUFPLElBQUlDLFdBQVdIO1FBQzFCO1FBQ0EsT0FBT0E7SUFDWDtJQUNBLElBQUksT0FBUUEsVUFBVyxZQUFZQSxNQUFNSSxLQUFLLENBQUMsNkJBQTZCO1FBQ3hFLE1BQU1DLFNBQVMsSUFBSUYsV0FBVyxDQUFDSCxNQUFNTSxNQUFNLEdBQUcsS0FBSztRQUNuRCxJQUFJQyxTQUFTO1FBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE9BQU9DLE1BQU0sRUFBRUUsSUFBSztZQUNwQ0gsTUFBTSxDQUFDRyxFQUFFLEdBQUdDLFNBQVNULE1BQU1VLFNBQVMsQ0FBQ0gsUUFBUUEsU0FBUyxJQUFJO1lBQzFEQSxVQUFVO1FBQ2Q7UUFDQSxPQUFPRjtJQUNYO0lBQ0FQLDBEQUFjQSxDQUFDLE9BQU8sMkJBQTJCRyxRQUFRLFNBQVNEO0FBQ3RFO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1csU0FBU1gsS0FBSyxFQUFFQyxJQUFJO0lBQ2hDLE9BQU9GLFVBQVVDLE9BQU9DLE1BQU07QUFDbEM7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxhQUFhWixLQUFLLEVBQUVDLElBQUk7SUFDcEMsT0FBT0YsVUFBVUMsT0FBT0MsTUFBTTtBQUNsQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNZLFlBQVliLEtBQUssRUFBRU0sTUFBTTtJQUNyQyxJQUFJLE9BQVFOLFVBQVcsWUFBWSxDQUFDQSxNQUFNSSxLQUFLLENBQUMscUJBQXFCO1FBQ2pFLE9BQU87SUFDWDtJQUNBLElBQUksT0FBUUUsV0FBWSxZQUFZTixNQUFNTSxNQUFNLEtBQUssSUFBSSxJQUFJQSxRQUFRO1FBQ2pFLE9BQU87SUFDWDtJQUNBLElBQUlBLFdBQVcsUUFBUSxNQUFPQSxNQUFNLEdBQUcsTUFBTyxHQUFHO1FBQzdDLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNRLFlBQVlkLEtBQUs7SUFDN0IsT0FBUWEsWUFBWWIsT0FBTyxTQUFVQSxpQkFBaUJHO0FBQzFEO0FBQ0EsTUFBTVksZ0JBQWdCO0FBQ3RCOztDQUVDLEdBQ00sU0FBU0MsUUFBUUMsSUFBSTtJQUN4QixNQUFNQyxRQUFRUCxTQUFTTTtJQUN2QixJQUFJWixTQUFTO0lBQ2IsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlVLE1BQU1aLE1BQU0sRUFBRUUsSUFBSztRQUNuQyxNQUFNVyxJQUFJRCxLQUFLLENBQUNWLEVBQUU7UUFDbEJILFVBQVVVLGFBQWEsQ0FBQyxDQUFDSSxJQUFJLElBQUcsS0FBTSxFQUFFLEdBQUdKLGFBQWEsQ0FBQ0ksSUFBSSxLQUFLO0lBQ3RFO0lBQ0EsT0FBT2Q7QUFDWDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNlLE9BQU9DLEtBQUs7SUFDeEIsT0FBTyxPQUFPQSxNQUFNQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTVAsUUFBUU8sR0FBR2IsU0FBUyxDQUFDLElBQUljLElBQUksQ0FBQztBQUNqRTtBQUNBOztDQUVDLEdBQ00sU0FBU0MsV0FBV1IsSUFBSTtJQUMzQixJQUFJSixZQUFZSSxNQUFNLE9BQU87UUFDekIsT0FBTyxDQUFDQSxLQUFLWCxNQUFNLEdBQUcsS0FBSztJQUMvQjtJQUNBLE9BQU9LLFNBQVNNLE1BQU1YLE1BQU07QUFDaEM7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNvQixVQUFVVCxJQUFJLEVBQUVVLEtBQUssRUFBRUMsR0FBRztJQUN0QyxNQUFNVixRQUFRUCxTQUFTTTtJQUN2QixJQUFJVyxPQUFPLFFBQVFBLE1BQU1WLE1BQU1aLE1BQU0sRUFBRTtRQUNuQ1Qsa0RBQU1BLENBQUMsT0FBTyxtQ0FBbUMsa0JBQWtCO1lBQy9EZ0MsUUFBUVg7WUFBT1osUUFBUVksTUFBTVosTUFBTTtZQUFFQyxRQUFRcUI7UUFDakQ7SUFDSjtJQUNBLE9BQU9aLFFBQVFFLE1BQU1ZLEtBQUssQ0FBQyxTQUFVLE9BQVEsSUFBSUgsT0FBTyxPQUFRLE9BQVFULE1BQU1aLE1BQU0sR0FBR3NCO0FBQzNGO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0csZUFBZWQsSUFBSTtJQUMvQixJQUFJQyxRQUFRRixRQUFRQyxNQUFNUCxTQUFTLENBQUM7SUFDcEMsTUFBT1EsTUFBTWMsVUFBVSxDQUFDLE1BQU87UUFDM0JkLFFBQVFBLE1BQU1SLFNBQVMsQ0FBQztJQUM1QjtJQUNBLE9BQU8sT0FBT1E7QUFDbEI7QUFDQSxTQUFTZSxRQUFRaEIsSUFBSSxFQUFFWCxNQUFNLEVBQUU0QixJQUFJO0lBQy9CLE1BQU1oQixRQUFRUCxTQUFTTTtJQUN2QnBCLGtEQUFNQSxDQUFDUyxVQUFVWSxNQUFNWixNQUFNLEVBQUUsK0JBQStCLGtCQUFrQjtRQUM1RXVCLFFBQVEsSUFBSTFCLFdBQVdlO1FBQ3ZCWixRQUFRQTtRQUNSQyxRQUFRRCxTQUFTO0lBQ3JCO0lBQ0EsTUFBTUQsU0FBUyxJQUFJRixXQUFXRztJQUM5QkQsT0FBTzhCLElBQUksQ0FBQztJQUNaLElBQUlELE1BQU07UUFDTjdCLE9BQU8rQixHQUFHLENBQUNsQixPQUFPWixTQUFTWSxNQUFNWixNQUFNO0lBQzNDLE9BQ0s7UUFDREQsT0FBTytCLEdBQUcsQ0FBQ2xCLE9BQU87SUFDdEI7SUFDQSxPQUFPRixRQUFRWDtBQUNuQjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVNnQyxhQUFhcEIsSUFBSSxFQUFFWCxNQUFNO0lBQ3JDLE9BQU8yQixRQUFRaEIsTUFBTVgsUUFBUTtBQUNqQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVNnQyxhQUFhckIsSUFBSSxFQUFFWCxNQUFNO0lBQ3JDLE9BQU8yQixRQUFRaEIsTUFBTVgsUUFBUTtBQUNqQyxFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcz84OWY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoWzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJfZ2V0Qnl0ZXMiLCJ2YWx1ZSIsIm5hbWUiLCJjb3B5IiwiVWludDhBcnJheSIsIm1hdGNoIiwicmVzdWx0IiwibGVuZ3RoIiwib2Zmc2V0IiwiaSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJpc0hleFN0cmluZyIsImlzQnl0ZXNMaWtlIiwiSGV4Q2hhcmFjdGVycyIsImhleGxpZnkiLCJkYXRhIiwiYnl0ZXMiLCJ2IiwiY29uY2F0IiwiZGF0YXMiLCJtYXAiLCJkIiwiam9pbiIsImRhdGFMZW5ndGgiLCJkYXRhU2xpY2UiLCJzdGFydCIsImVuZCIsImJ1ZmZlciIsInNsaWNlIiwic3RyaXBaZXJvc0xlZnQiLCJzdGFydHNXaXRoIiwiemVyb1BhZCIsImxlZnQiLCJmaWxsIiwic2V0IiwiemVyb1BhZFZhbHVlIiwiemVyb1BhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(rsc)/../../node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map(stringify).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return value.toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */ function makeError(message, code, info) {\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FDd0M7QUFDVTtBQUNuRCxTQUFTRSxVQUFVQyxLQUFLO0lBQ3BCLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN0QixPQUFPLE9BQU8sTUFBT0csR0FBRyxDQUFDSixXQUFZSyxJQUFJLENBQUMsUUFBUTtJQUN0RDtJQUNBLElBQUlKLGlCQUFpQkssWUFBWTtRQUM3QixNQUFNQyxNQUFNO1FBQ1osSUFBSUMsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUixNQUFNUyxNQUFNLEVBQUVELElBQUs7WUFDbkNELFVBQVVELEdBQUcsQ0FBQ04sS0FBSyxDQUFDUSxFQUFFLElBQUksRUFBRTtZQUM1QkQsVUFBVUQsR0FBRyxDQUFDTixLQUFLLENBQUNRLEVBQUUsR0FBRyxJQUFJO1FBQ2pDO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLElBQUksT0FBUVAsVUFBVyxZQUFZLE9BQVFBLE1BQU1VLE1BQU0sS0FBTSxZQUFZO1FBQ3JFLE9BQU9YLFVBQVVDLE1BQU1VLE1BQU07SUFDakM7SUFDQSxPQUFRLE9BQVFWO1FBQ1osS0FBSztRQUNMLEtBQUs7WUFDRCxPQUFPQSxNQUFNVyxRQUFRO1FBQ3pCLEtBQUs7WUFDRCxPQUFPQyxPQUFPWixPQUFPVyxRQUFRO1FBQ2pDLEtBQUs7WUFDRCxPQUFPLE1BQVFBLFFBQVE7UUFDM0IsS0FBSztZQUNELE9BQU9FLEtBQUtkLFNBQVMsQ0FBQ0M7UUFDMUIsS0FBSztZQUFVO2dCQUNYLE1BQU1jLE9BQU9DLE9BQU9ELElBQUksQ0FBQ2Q7Z0JBQ3pCYyxLQUFLRSxJQUFJO2dCQUNULE9BQU8sT0FBT0YsS0FBS1gsR0FBRyxDQUFDLENBQUNjLElBQU0sQ0FBQyxFQUFFbEIs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QUFTLENBQUNELFVBQVUsUUFBUTtZQUNuQyxNQUFNLElBQUlqQixNQUFNO1FBQ3BCOztRQUVBLGtCQUFrQixHQUNsQixJQUFJaUIsU0FBUyxPQUFPO1lBQ2hCLE1BQU1WLFFBQVFZLE9BQU9DLFlBQVksQ0FBQyxNQUFNRixTQUFTLENBQUM7WUFDbEQsTUFBTUcsV0FBV0YsT0FBT0MsWUFBWSxDQUFDLE1BQU07WUFDM0MsbUJBQW1CLEdBQ25CLElBQUliLFVBQVVjLFVBQVU7Z0JBQ3BCLE1BQU0sSUFBSXJCLE1BQU07WUFDcEI7UUFDQSxrQkFBa0IsR0FDdEI7UUFDQWdCLE1BQU1kLElBQUksQ0FBQ2U7SUFDZixFQUNBLE9BQU94QixPQUFPLENBQUU7SUFDaEIsT0FBT3VCO0FBQ1gsR0FBRyxFQUFFO0FBQ0w7O0NBRUMsR0FDTSxTQUFTTSxnQkFBZ0JMLElBQUk7SUFDaENYLE9BQU9RLGdCQUFnQlMsT0FBTyxDQUFDTixTQUFTLEdBQUcsK0NBQStDLHlCQUF5QjtRQUMvR08sV0FBVztRQUE4QjFCLE1BQU07WUFBRW1CO1FBQUs7SUFDMUQ7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sU0FBU1EsY0FBY0MsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLFNBQVM7SUFDdEQsSUFBSUEsYUFBYSxNQUFNO1FBQ25CQSxZQUFZO0lBQ2hCO0lBQ0EsSUFBSUYsZUFBZUMsT0FBTztRQUN0QixJQUFJRSxTQUFTRCxXQUFXSixZQUFZO1FBQ3BDLElBQUlJLFdBQVc7WUFDWEMsVUFBVTtZQUNWTCxhQUFhLE1BQU1JO1FBQ3ZCO1FBQ0F0QixPQUFPLE9BQU8sQ0FBQyx5QkFBeUIsRUFBRXVCLE9BQU8sYUFBYSxDQUFDLEVBQUUseUJBQXlCO1lBQ3RGTDtRQUNKO0lBQ0o7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzPzQ2YjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoc3RyaW5naWZ5KSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGspfTogJHtzdHJpbmdpZnkodmFsdWVba10pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52b3Jub21lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvYW5sIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcG5lZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lZWFnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBpbmZvIHx8IFwiY29kZVwiIGluIGluZm8gfHwgXCJuYW1lXCIgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVtjb3VsZCBub3Qgc2VyaWFsaXplIG9iamVjdF1cIik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XG4gICAgICAgIGlmIChkZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBcIklOVkFMSURfQVJHVU1FTlRcIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTlVNRVJJQ19GQVVMVFwiOlxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IGNvZGUgfSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwgaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndWVtbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VlbW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwic3RyaW5naWZ5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJqb2luIiwiVWludDhBcnJheSIsIkhFWCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJ0b0pTT04iLCJ0b1N0cmluZyIsIkJpZ0ludCIsIkpTT04iLCJrZXlzIiwiT2JqZWN0Iiwic29ydCIsImsiLCJpc0Vycm9yIiwiZXJyb3IiLCJjb2RlIiwiaXNDYWxsRXhjZXB0aW9uIiwibWFrZUVycm9yIiwibWVzc2FnZSIsImluZm8iLCJkZXRhaWxzIiwiRXJyb3IiLCJrZXkiLCJwdXNoIiwiVHlwZUVycm9yIiwiUmFuZ2VFcnJvciIsImFzc2lnbiIsImFzc2VydCIsImNoZWNrIiwiYXNzZXJ0QXJndW1lbnQiLCJuYW1lIiwiYXJndW1lbnQiLCJhc3NlcnRBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiX25vcm1hbGl6ZUZvcm1zIiwicmVkdWNlIiwiYWNjdW0iLCJmb3JtIiwibm9ybWFsaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhwZWN0ZWQiLCJhc3NlcnROb3JtYWxpemUiLCJpbmRleE9mIiwib3BlcmF0aW9uIiwiYXNzZXJ0UHJpdmF0ZSIsImdpdmVuR3VhcmQiLCJndWFyZCIsImNsYXNzTmFtZSIsIm1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/events.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/events.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ \n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNrRDtBQUNuRDs7OztDQUlDLEdBQ00sTUFBTUM7SUFTVCxDQUFDQyxRQUFRLENBQUM7SUFDVjs7O0tBR0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFRixRQUFRLEVBQUVHLE1BQU0sQ0FBRTtRQUNuQyxJQUFJLENBQUMsQ0FBQ0gsUUFBUSxHQUFHQTtRQUNqQkYsZ0VBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFSTtZQUFTQztRQUFPO0lBQzdDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxpQkFBaUI7UUFDbkIsSUFBSSxJQUFJLENBQUMsQ0FBQ0osUUFBUSxJQUFJLE1BQU07WUFDeEI7UUFDSjtRQUNBLE1BQU0sSUFBSSxDQUFDRSxPQUFPLENBQUNHLEdBQUcsQ0FBQyxJQUFJLENBQUNGLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQ0gsUUFBUTtJQUN0RDtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanM/NWY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBmaWx0ZXIuXG4gICAgICovXG4gICAgZmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgKipFdmVudEVtaXR0ZXJhYmxlKiouXG4gICAgICovXG4gICAgZW1pdHRlcjtcbiAgICAjbGlzdGVuZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkV2ZW50UGF5bG9hZCoqIGZvciAlJWVtaXR0ZXIlJSB3aXRoXG4gICAgICogIHRoZSAlJWxpc3RlbmVyJSUgYW5kIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVtaXR0ZXIsIGZpbHRlciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVucmVnaXN0ZXIgdGhlIHRyaWdnZXJlZCBsaXN0ZW5lciBmb3IgZnV0dXJlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZmlsdGVyLCB0aGlzLiNsaXN0ZW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiRXZlbnRQYXlsb2FkIiwibGlzdGVuZXIiLCJjb25zdHJ1Y3RvciIsImVtaXR0ZXIiLCJmaWx0ZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/events.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/fetch.js":
/*!********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/fetch.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: () => (/* binding */ FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* binding */ FetchRequest),\n/* harmony export */   FetchResponse: () => (/* binding */ FetchResponse)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/base64.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/geturl.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction the each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retreive the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentcation, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */ \n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet getUrlFunc = _geturl_js__WEBPACK_IMPORTED_MODULE_0__.getUrl;\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n        }, match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3]));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */ function getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */ class FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request){\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, ()=>{\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners){\n                setTimeout(()=>{\n                    listener();\n                }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() {\n        return this.#cancelled;\n    }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */ class FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    /**\n     *  The fetch URI to requrest.\n     */ get url() {\n        return this.#url;\n    }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``) and the .\n     *\n     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrincis ``Content-Type`` is\n     *  set to ``application/json``.\n     */ get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof body === \"string\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof body === \"object\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */ get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any chnages will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */ get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */ setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */ clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */ get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */ setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */ get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */ get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complere response.\n     *  //(default: 5 minutes)//\n     */ get timeout() {\n        return this.#timeout;\n    }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */ get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */ get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */ get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */ constructor(url){\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */ setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\",\n            reason: \"timeout\",\n            request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof error.stall !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                    // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) {}\n            // Things won't get any better on another attempt; abort\n            return response;\n        } else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof error.stall !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */ send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.send\"\n        });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */ cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.cancel\"\n        });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */ redirect(location) {\n        // Redirection; for now we only support absolute locataions\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */ clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */ static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */ static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        getUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */ static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */ static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchREquest.\n */ class FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */ get statusCode() {\n        return this.#statusCode;\n    }\n    /**\n     *  The response status message.\n     */ get statusMessage() {\n        return this.#statusMessage;\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */ get headers() {\n        return Object.assign({}, this.#headers);\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */ get body() {\n        return this.#body == null ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */ get bodyText() {\n        try {\n            return this.#body == null ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */ get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request){\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k)=>{\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = body == null ? null : new Uint8Array(body);\n        this.#request = request || null;\n        this.#error = {\n            message: \"\"\n        };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */ makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = {\n            message,\n            error\n        };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */ throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, {\n            stall,\n            throttle: true\n        });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true of the response has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The request made for this response.\n     */ get request() {\n        return this.#request;\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */ ok() {\n        return this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */ assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: this.request || \"unknown request\",\n            response: this,\n            error\n        });\n    }\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDd0Q7QUFDckI7QUFDaUI7QUFDRjtBQUNHO0FBQ2pCO0FBQ3JDLE1BQU1TLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCLDZDQUE2QztBQUM3QyxJQUFJQyxhQUFhSCw4Q0FBTUE7QUFDdkIsTUFBTUksU0FBUyxJQUFJQyxPQUFPLG1DQUFtQztBQUM3RCxNQUFNQyxTQUFTLElBQUlELE9BQU8seUJBQTBCO0FBQ3BELDBDQUEwQztBQUMxQyxJQUFJRSxTQUFTO0FBQ2IsNkVBQTZFO0FBQzdFLGVBQWVDLGdCQUFnQkMsR0FBRyxFQUFFQyxNQUFNO0lBQ3RDLElBQUk7UUFDQSxNQUFNQyxRQUFRRixJQUFJRSxLQUFLLENBQUNQO1FBQ3hCLElBQUksQ0FBQ08sT0FBTztZQUNSLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSUMsY0FBYyxLQUFLLE1BQU07WUFDaEMsZ0JBQWlCRixLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ2pDLEdBQUlBLEtBQUssQ0FBQyxFQUFFLEdBQUduQix3REFBWUEsQ0FBQ21CLEtBQUssQ0FBQyxFQUFFLElBQUlHLFVBQVVILEtBQUssQ0FBQyxFQUFFO0lBQzlELEVBQ0EsT0FBT0ksT0FBTztRQUNWLE9BQU8sSUFBSUYsY0FBYyxLQUFLLG1DQUFtQyxDQUFDLEdBQUcsTUFBTSxJQUFJRyxhQUFhUDtJQUNoRztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU1EsbUJBQW1CQyxPQUFPO0lBQy9CLGVBQWVDLFlBQVlWLEdBQUcsRUFBRUMsTUFBTTtRQUNsQyxJQUFJO1lBQ0EsTUFBTUMsUUFBUUYsSUFBSUUsS0FBSyxDQUFDTDtZQUN4QixJQUFJLENBQUNLLE9BQU87Z0JBQ1IsTUFBTSxJQUFJQyxNQUFNO1lBQ3BCO1lBQ0EsT0FB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QyxPQUFPdUksU0FBUyxnQkFBZ0I7WUFDbkN2RyxTQUFVLElBQUksQ0FBQ0EsT0FBTyxJQUFJO1lBQW9CdUUsVUFBVSxJQUFJO1lBQUVuRjtRQUNsRTtJQUNKO0FBQ0o7QUFDQSxTQUFTMkU7SUFBWSxPQUFPLElBQUs2QyxPQUFRN0MsT0FBTztBQUFJO0FBQ3BELFNBQVM1RSxVQUFVZ0QsS0FBSztJQUNwQixPQUFPaEUscURBQVdBLENBQUNnRSxNQUFNMEUsT0FBTyxDQUFDLHlCQUF5QixDQUFDQyxLQUFLQztRQUM1RCxPQUFPM0YsT0FBTzRGLFlBQVksQ0FBQzVCLFNBQVMyQixNQUFNO0lBQzlDO0FBQ0o7QUFDQSxTQUFTOUMsS0FBS04sS0FBSztJQUNmLE9BQU8sSUFBSXNELFFBQVEsQ0FBQ0MsVUFBWS9HLFdBQVcrRyxTQUFTdkQ7QUFDeEQsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2ZldGNoLmpzP2MwY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRmV0Y2hpbmcgY29udGVudCBmcm9tIHRoZSB3ZWIgaXMgZW52aXJvbm1lbnQtc3BlY2lmaWMsIHNvIEV0aGVyc1xuICogIHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIHRoZSBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxuICogIHRoaXMgc2VydmljZS5cbiAqXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cbiAqICBjcmVhdGUgYSByZXF1ZXN0IG9iamVjdCwgcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGFuZCBwcm9jZXNzIGRhdGFcbiAqICBhbmQgcG9wdWxhdGUgdGhlIFtbRmV0Y2hSZXNwb25zZV1dLlxuICpcbiAqICBJbiBhIGJyb3dzZXIsIHRoZSBbRE9NIGZldGNoXShsaW5rLWpzLWZldGNoKSBpcyB1c2VkLCBhbmQgdGhlIHJlc3VsdGluZ1xuICogIGBgUHJvbWlzZWBgIGlzIHdhaXRlZCBvbiB0byByZXRyZWl2ZSB0aGUgcGF5bG9hZC5cbiAqXG4gKiAgVGhlIFtbRmV0Y2hSZXF1ZXN0XV0gaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIG1hbnkgY29tbW9uIHNpdHVhdGlvbnMsXG4gKiAgc3VjaCBhcyByZWRpcmVjdHMsIHNlcnZlciB0aHJvdHRsaW5nLCBhdXRoZW50Y2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBnZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGdldFVybEZ1bmMgPSBnZXRVcmw7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJJIHRvIHJlcXVyZXN0LlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICBzZXQgdXJsKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBib2R5LCBpZiBhbnksIHRvIHNlbmQgYXMgdGhlIHJlcXVlc3QgYm9keS4gLy8oZGVmYXVsdDogbnVsbCkvL1xuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogIHNldCBhbmQgd2lsbCBiZSB1c2VkIGlmICoqbm90IG92ZXJyaWRkZW4qKiBieSBzZXR0aW5nIGEgY3VzdG9tXG4gICAgICogIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBudWxsLCB0aGUgYm9keSBpcyBjbGVhcmVkIChhbG9uZyB3aXRoIHRoZVxuICAgICAqICBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCkgYW5kIHRoZSAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBzdHJpbmcsIHRoZSBpbnRyaW5jaXMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGB0ZXh0L3BsYWluYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBVaW50OEFycmF5LCB0aGUgaW50cmluY2lzIGBgQ29udGVudC1UeXBlYGAgaXMgc2V0IHRvXG4gICAgICogIGBgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYW55IG90aGVyIG9iamVjdCwgdGhlIGludHJpbmNpcyBgYENvbnRlbnQtVHlwZWBgIGlzXG4gICAgICogIHNldCB0byBgYGFwcGxpY2F0aW9uL2pzb25gYC5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICBzZXQgYm9keShib2R5KSB7XG4gICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoYm9keSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwidGV4dC9wbGFpblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9keVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gSWYgbm8gbWV0aG9kXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xuICAgICAqICBudWxsIGFuZCBgYFBPU1RgYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI21ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCb2R5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICB9XG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFN0cmluZyhtZXRob2QpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gQWxsXG4gICAgICogIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvYmplY3QgaXMgYSBjb3B5LCBzbyBhbnkgY2huYWdlcyB3aWxsICoqTk9UKiogYmUgcmVmbGVjdGVkXG4gICAgICogIGluIHRoZSBgYEZldGNoUmVxdWVzdGBgLlxuICAgICAqXG4gICAgICogIFRvIHNldCBhIGhlYWRlciBlbnRyeSwgdXNlIHRoZSBgYHNldEhlYWRlcmBgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jY3JlZHMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSBTdHJpbmcodGhpcy5ib2R5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXG4gICAgICogIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnNbU3RyaW5nKGtleSkudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYWxsIGhlYWRlcnMsIHJlc2V0dGluZyBhbGwgaW50cmluc2ljIGhlYWRlcnMuXG4gICAgICovXG4gICAgY2xlYXJIZWFkZXJzKCkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgZm9yIHRoZSBgYEF1dGhvcml6YXRpb25gYCBoZWFkZXIuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IHRoZSBjcmVkZW50aWFscywgdXNlIHRoZSBgYHNldENyZWRlbnRpYWxzYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWRzIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXRzIGFuIGBgQXV0aG9yaXphdGlvbmBgIGZvciAlJXVzZXJuYW1lJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGVyZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBwcmlvciB0byBlYWNoIHJlcXVlc3QsIGZvciBleGFtcGxlXG4gICAgICogIGR1cmluZyBhIHJlZGlyZWN0aW9uIG9yIHJldHJ5IGluIGNhc2Ugb2Ygc2VydmVyIHRocm90dGxpbmcuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvZmZlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcG9wdWxhdGUgaGVhZGVycyBvciB1cGRhdGVcbiAgICAgKiAgY29udGVudCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHByZWZsaWdodEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcmVmbGlnaHQgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByZWZsaWdodEZ1bmMocHJlZmxpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3ByZWZsaWdodCA9IHByZWZsaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGVhY2ggcmVzcG9uc2UsIG9mZmVyaW5nIGFuXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcbiAgICAgKiAgcmVzcG9uc2UgZGF0YS5cbiAgICAgKlxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxuICAgICAqXG4gICAgICogIFRvIHNjaGVkdWxlIGEgcmV0cnkgYXR0ZW1wdCAoYXNzdW1pbmcgdGhlIG1heGltdW0gcmV0cnkgbGltaXRcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBwcm9jZXNzRnVuYyhwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxuICAgICAqL1xuICAgIGdldCByZXRyeUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcmV0cnlGdW5jKHJldHJ5KSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgRmV0Y2hSZXF1ZXN0IGluc3RhbmNlIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgT25jZSBjcmVhdGVkLCBlYWNoIHByb3BlcnR5IG1heSBiZSBzZXQgYmVmb3JlIGlzc3VpbmcgYVxuICAgICAqICBgYC5zZW5kKClgYCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNnemlwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLiNtZXRob2QgPSBcIlwiO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gMzAwMDAwO1xuICAgICAgICB0aGlzLiN0aHJvdHRsZSA9IHtcbiAgICAgICAgICAgIHNsb3RJbnRlcnZhbDogU0xPVF9JTlRFUlZBTCxcbiAgICAgICAgICAgIG1heEF0dGVtcHRzOiBNQVhfQVRURU1QVFNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVxdWVzdCBtZXRob2Q9JHtKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGhvZCl9IHVybD0ke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gaGVhZGVycz0ke0pTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycyl9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXBkYXRlIHRoZSB0aHJvdHRsZSBwYXJhbWV0ZXJzIHVzZWQgdG8gZGV0ZXJtaW5lIG1heGltdW1cbiAgICAgKiAgYXR0ZW1wdHMgYW5kIGV4cG9uZW50aWFsLWJhY2tvZmYgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXRUaHJvdHRsZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zbG90SW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1heEF0dGVtcHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XG4gICAgICAgIGlmIChhdHRlbXB0ID49IHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImV4Y2VlZGVkIG1heGltdW0gcmV0cnkgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGdldFRpbWUoKSA8PSBleHBpcmVzLCBcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0LnNlbmRcIiwgcmVhc29uOiBcInRpbWVvdXRcIiwgcmVxdWVzdDogX3JlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IChyZXEudXJsLnNwbGl0KFwiOlwiKVswXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xuICAgICAgICBpZiAoc2NoZW1lIGluIEdhdGV3YXlzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBHYXRld2F5c1tzY2hlbWVdKHJlcS51cmwsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGEgcHJlZmxpZ2h0IGZ1bmN0aW9uOyB1cGRhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0RnVuYykge1xuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3Auc3RhdHVzQ29kZSwgcmVzcC5zdGF0dXNNZXNzYWdlLCByZXNwLmhlYWRlcnMsIHJlc3AuYm9keSwgX3JlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xuICAgICAgICAgICAgLy8gUmVkaXJlY3RcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICBpZiAodGhpcy5yZXRyeUZ1bmMgPT0gbnVsbCB8fCAoYXdhaXQgdGhpcy5yZXRyeUZ1bmMocmVxLCByZXNwb25zZSwgYXR0ZW1wdCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBlcnJvci5zdGFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZW5kKCkge1xuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsID09IG51bGwsIFwicmVxdWVzdCBhbHJlYWR5IHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LnNlbmRcIiB9KTtcbiAgICAgICAgdGhpcy4jc2lnbmFsID0gbmV3IEZldGNoQ2FuY2VsU2lnbmFsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy4jc2VuZCgwLCBnZXRUaW1lKCkgKyB0aGlzLnRpbWVvdXQsIDAsIHRoaXMsIG5ldyBGZXRjaFJlc3BvbnNlKDAsIFwiXCIsIHt9LCBudWxsLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYW5jZWxzIHRoZSBpbmZsaWdodCByZXNwb25zZSwgY2F1c2luZyBhIGBgQ0FOQ0VMTEVEYGBcbiAgICAgKiAgZXJyb3IgdG8gYmUgcmVqZWN0ZWQgZnJvbSB0aGUgW1tzZW5kXV0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsICE9IG51bGwsIFwicmVxdWVzdCBoYXMgbm90IGJlZW4gc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3QuY2FuY2VsXCIgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IGZldGNoU2lnbmFscy5nZXQodGhpcyk7XG4gICAgICAgIGlmICghc2lnbmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRmV0Y2hSZXF1ZXN0XV0gdGhhdCByZXByZXNlbnRzIHRoZSByZWRpcmVjdGlvblxuICAgICAqICB0byAlJWxvY2F0aW9uJSUuXG4gICAgICovXG4gICAgcmVkaXJlY3QobG9jYXRpb24pIHtcbiAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0YWlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgYXNzZXJ0KHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBMb2NrcyBhbGwgc3RhdGljIGNvbmZpZ3VyYXRpb24gZm9yIGdhdGV3YXlzIGFuZCBGZXRjaEdldFVybEZ1bmNcbiAgICAgKiAgcmVnaXN0cmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2NrQ29uZmlnKCkge1xuICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBjdXJyZW50IEdhdGV3YXkgZnVuY3Rpb24gZm9yICUlc2NoZW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEdhdGV3YXkoc2NoZW1lKSB7XG4gICAgICAgIHJldHVybiBHYXRld2F5c1tzY2hlbWUudG9Mb3dlckNhc2UoKV0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSB0aGUgJSVmdW5jJSUgd2hlbiBmZXRjaGluZyBVUklzIHVzaW5nICUlc2NoZW1lJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2F0ZXdheShzY2hlbWUsIGZ1bmMpIHtcbiAgICAgICAgc2NoZW1lID0gc2NoZW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IFwiaHR0cFwiIHx8IHNjaGVtZSA9PT0gXCJodHRwc1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBpbnRlcmNlcHQgJHtzY2hlbWV9OyB1c2UgcmVnaXN0ZXJHZXRVcmxgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgR2F0ZXdheXNbc2NoZW1lXSA9IGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgJSVnZXRVcmwlJSB3aGVuIGZldGNoaW5nIFVSSXMgb3ZlciBIVFRQIGFuZCBIVFRQUyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHZXRVcmwoZ2V0VXJsKSB7XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRVcmxGdW5jID0gZ2V0VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIFwiZmV0Y2hcIiBkYXRhIFVSSXMuXG4gICAgICpcbiAgICAgKiAgTm90ZSB0aGF0IHRoaXMgaXMgYXV0b21hdGljYWxseSBkb25lIGludGVybmFsbHkgdG8gc3VwcG9ydFxuICAgICAqICBkYXRhIFVSSXMsIHNvIGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gcmVnaXN0ZXIgaXQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IG1heVxuICAgICAqICBiZSB1c2VmdWwgaW4gYSB3cmFwcGVyIHRvIHBlcmZvbSBjdXN0b20gZGF0YSBVUkkgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGF0YUdhdGV3YXkoKSB7XG4gICAgICAgIHJldHVybiBkYXRhR2F0ZXdheUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGZldGNoIElQRlMgKHVudmFsaWRhdGVkKSBmcm9tXG4gICAgICogIGEgY3VzdG9tIGdhdGV3YXkgYmFzZVVybC5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCBJUEZTIGdhdGV3YXkgdXNlZCBpbnRlcm5hbGx5IGlzXG4gICAgICogIGBgXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCJgYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICAgICAgcmV0dXJuIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKTtcbiAgICB9XG59XG47XG4vKipcbiAqICBUaGUgcmVzcG9uc2UgZm9yIGEgRmV0Y2hSRXF1ZXN0LlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXNwb25zZSB7XG4gICAgI3N0YXR1c0NvZGU7XG4gICAgI3N0YXR1c01lc3NhZ2U7XG4gICAgI2hlYWRlcnM7XG4gICAgI2JvZHk7XG4gICAgI3JlcXVlc3Q7XG4gICAgI2Vycm9yO1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYDxGZXRjaFJlc3BvbnNlIHN0YXR1cz0ke3RoaXMuc3RhdHVzQ29kZX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c0NvZGUoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNDb2RlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzTWVzc2FnZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c01lc3NhZ2U7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGhlYWRlcnMuIEFsbCBrZXlzIGFyZSBsb3dlci1jYXNlLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkgeyByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIG9yIGBgbnVsbGBgIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSBhcyBhIFVURi04IGVuY29kZWQgc3RyaW5nLCBvciB0aGUgZW1wdHlcbiAgICAgKiAgc3RyaW5nIChpLmUuIGBgXCJcImBgKSBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBVVEYtOCBkYXRhLlxuICAgICAqL1xuICAgIGdldCBib2R5VGV4dCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IFwiXCIgOiB0b1V0ZjhTdHJpbmcodGhpcy4jYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwicmVzcG9uc2UgYm9keSBpcyBub3QgdmFsaWQgVVRGLTggZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImJvZHlUZXh0XCIsIGluZm86IHsgcmVzcG9uc2U6IHRoaXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBkZWNvZGVkIGFzIEpTT04uXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgSlNPTi1lbmNvZGVkIGRhdGFcbiAgICAgKiAgb3IgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHlKc29uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5ib2R5VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwicmVzcG9uc2UgYm9keSBpcyBub3QgdmFsaWQgSlNPTlwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImJvZHlKc29uXCIsIGluZm86IHsgcmVzcG9uc2U6IHRoaXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSwgcmVxdWVzdCkge1xuICAgICAgICB0aGlzLiNzdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy4jc3RhdHVzTWVzc2FnZSA9IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5yZWR1Y2UoKGFjY3VtLCBrKSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtrLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKGhlYWRlcnNba10pO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuI2JvZHkgPSAoKGJvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkoYm9keSkpO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0ID0gKHJlcXVlc3QgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMuI2Vycm9yID0geyBtZXNzYWdlOiBcIlwiIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBSZXNwb25zZSB3aXRoIG1hdGNoaW5nIGhlYWRlcnMgYW5kIGJvZHksIGJ1dCB3aXRoXG4gICAgICogIGFuIGVycm9yIHN0YXR1cyBjb2RlIChpLmUuIDU5OSkgYW5kICUlbWVzc2FnZSUlIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSVlcnJvciUlLlxuICAgICAqL1xuICAgIG1ha2VTZXJ2ZXJFcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICBsZXQgc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZSA9IGBDTElFTlQgRVNDQUxBVEVEIFNFUlZFUiBFUlJPUiAoJHttZXNzYWdlfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZSA9IGBDTElFTlQgRVNDQUxBVEVEIFNFUlZFUiBFUlJPUiAoJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfTsgJHttZXNzYWdlfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBzdGF0dXNNZXNzYWdlLCB0aGlzLmhlYWRlcnMsIHRoaXMuYm9keSwgdGhpcy4jcmVxdWVzdCB8fCB1bmRlZmluZWQpO1xuICAgICAgICByZXNwb25zZS4jZXJyb3IgPSB7IG1lc3NhZ2UsIGVycm9yIH07XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGNhbGxlZCB3aXRoaW4gYSBbcmVxdWVzdC5wcm9jZXNzRnVuY10oRmV0Y2hSZXF1ZXN0LXByb2Nlc3NGdW5jKVxuICAgICAqICBjYWxsLCBjYXVzZXMgdGhlIHJlcXVlc3QgdG8gcmV0cnkgYXMgaWYgdGhyb3R0bGVkIGZvciAlJXN0YWxsJSVcbiAgICAgKiAgbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIHRocm93VGhyb3R0bGVFcnJvcihtZXNzYWdlLCBzdGFsbCkge1xuICAgICAgICBpZiAoc3RhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhbGwgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhbGwpICYmIHN0YWxsID49IDAsIFwiaW52YWxpZCBzdGFsbCB0aW1lb3V0XCIsIFwic3RhbGxcIiwgc3RhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJ0aHJvdHRsaW5nIHJlcXVlc3RzXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IHN0YWxsLCB0aHJvdHRsZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciB2YWx1ZSBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9mIHRoZSByZXNwb25zZSBoYXMgYSBib2R5LlxuICAgICAqL1xuICAgIGhhc0JvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXF1ZXN0IG1hZGUgZm9yIHRoaXMgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3QoKSB7IHJldHVybiB0aGlzLiNyZXF1ZXN0OyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlc3BvbnNlIHdhcyBhIHN1Y2Nlc3Mgc3RhdHVzQ29kZS5cbiAgICAgKi9cbiAgICBvaygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNlcnJvci5tZXNzYWdlID09PSBcIlwiICYmIHRoaXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgdGhpcy5zdGF0dXNDb2RlIDwgMzAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRocm93cyBhIGBgU0VSVkVSX0VSUk9SYGAgaWYgdGhpcyByZXNwb25zZSBpcyBub3Qgb2suXG4gICAgICovXG4gICAgYXNzZXJ0T2soKSB7XG4gICAgICAgIGlmICh0aGlzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBtZXNzYWdlLCBlcnJvciB9ID0gdGhpcy4jZXJyb3I7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBcIlwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYHNlcnZlciByZXNwb25zZSAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiU0VSVkVSX0VSUk9SXCIsIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6ICh0aGlzLnJlcXVlc3QgfHwgXCJ1bmtub3duIHJlcXVlc3RcIiksIHJlc3BvbnNlOiB0aGlzLCBlcnJvclxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuZnVuY3Rpb24gdW5wZXJjZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHZhbHVlLnJlcGxhY2UoLyUoWzAtOWEtZl1bMC05YS1mXSkvZ2ksIChhbGwsIGNvZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZSwgMTYpKTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiZGVjb2RlQmFzZTY0IiwiZW5jb2RlQmFzZTY0IiwiaGV4bGlmeSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZGVmaW5lUHJvcGVydGllcyIsInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwiZ2V0VXJsIiwiTUFYX0FUVEVNUFRTIiwiU0xPVF9JTlRFUlZBTCIsImdldFVybEZ1bmMiLCJyZURhdGEiLCJSZWdFeHAiLCJyZUlwZnMiLCJsb2NrZWQiLCJkYXRhR2F0ZXdheUZ1bmMiLCJ1cmwiLCJzaWduYWwiLCJtYXRjaCIsIkVycm9yIiwiRmV0Y2hSZXNwb25zZSIsInVucGVyY2VudCIsImVycm9yIiwiRmV0Y2hSZXF1ZXN0IiwiZ2V0SXBmc0dhdGV3YXlGdW5jIiwiYmFzZVVybCIsImdhdGV3YXlJcGZzIiwiR2F0ZXdheXMiLCJmZXRjaFNpZ25hbHMiLCJXZWFrTWFwIiwiRmV0Y2hDYW5jZWxTaWduYWwiLCJsaXN0ZW5lcnMiLCJjYW5jZWxsZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVlc3QiLCJzZXQiLCJsaXN0ZW5lciIsInNldFRpbWVvdXQiLCJhZGRMaXN0ZW5lciIsIm9wZXJhdGlvbiIsInB1c2giLCJjaGVja1NpZ25hbCIsImFsbG93SW5zZWN1cmUiLCJnemlwIiwiaGVhZGVycyIsIm1ldGhvZCIsInRpbWVvdXQiLCJib2R5IiwiYm9keVR5cGUiLCJjcmVkcyIsInByZWZsaWdodCIsInByb2Nlc3MiLCJyZXRyeSIsInRocm90dGxlIiwiU3RyaW5nIiwiVWludDhBcnJheSIsInVuZGVmaW5lZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXNCb2R5IiwidG9VcHBlckNhc2UiLCJPYmplY3QiLCJhc3NpZ24iLCJhbGxvd0d6aXAiLCJsZW5ndGgiLCJnZXRIZWFkZXIiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInNldEhlYWRlciIsInZhbHVlIiwiY2xlYXJIZWFkZXJzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJrZXlzIiwiaW5kZXgiLCJuZXh0IiwiZG9uZSIsImNyZWRlbnRpYWxzIiwic2V0Q3JlZGVudGlhbHMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwicHJlZmxpZ2h0RnVuYyIsInByb2Nlc3NGdW5jIiwicmV0cnlGdW5jIiwic2xvdEludGVydmFsIiwibWF4QXR0ZW1wdHMiLCJ0b1N0cmluZyIsInNldFRocm90dGxlUGFyYW1zIiwicGFyYW1zIiwic2VuZCIsImF0dGVtcHQiLCJleHBpcmVzIiwiZGVsYXkiLCJfcmVxdWVzdCIsIl9yZXNwb25zZSIsIm1ha2VTZXJ2ZXJFcnJvciIsImdldFRpbWUiLCJyZWFzb24iLCJ3YWl0IiwicmVxIiwiY2xvbmUiLCJzY2hlbWUiLCJzcGxpdCIsInJlc3VsdCIsInJlc3BvbnNlIiwic3RhbGwiLCJhc3NlcnRPayIsInJlc3AiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImxvY2F0aW9uIiwicmVkaXJlY3QiLCJyZXRyeUFmdGVyIiwiTWF0aCIsInRydW5jIiwicmFuZG9tIiwicG93IiwicGFyc2VJbnQiLCJjYW5jZWwiLCJnZXQiLCJjdXJyZW50IiwidGFyZ2V0IiwibG9ja0NvbmZpZyIsImdldEdhdGV3YXkiLCJyZWdpc3RlckdhdGV3YXkiLCJmdW5jIiwicmVnaXN0ZXJHZXRVcmwiLCJjcmVhdGVEYXRhR2F0ZXdheSIsImNyZWF0ZUlwZnNHYXRld2F5RnVuYyIsImJvZHlUZXh0IiwiaW5mbyIsImJvZHlKc29uIiwicGFyc2UiLCJyZWR1Y2UiLCJhY2N1bSIsImsiLCJtZXNzYWdlIiwidGhyb3dUaHJvdHRsZUVycm9yIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwib2siLCJEYXRlIiwicmVwbGFjZSIsImFsbCIsImNvZGUiLCJmcm9tQ2hhckNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/fetch.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/geturl.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/geturl.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n\n\n\n\n\n/**\n *  @_ignore:\n */ async function getUrl(req, signal) {\n    const protocol = req.url.split(\":\")[0].toLowerCase();\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n        info: {\n            protocol\n        },\n        operation: \"request\"\n    });\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"request\"\n    });\n    const method = req.method;\n    const headers = Object.assign({}, req.headers);\n    const options = {\n        method,\n        headers\n    };\n    const request = (protocol === \"http\" ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__).request(req.url, options);\n    request.setTimeout(req.timeout);\n    const body = req.body;\n    if (body) {\n        request.write(Buffer.from(body));\n    }\n    request.end();\n    return new Promise((resolve, reject)=>{\n        // @TODO: Node 15 added AbortSignal; once we drop support for\n        // Node14, we can add that in here too\n        request.once(\"response\", (resp)=>{\n            const statusCode = resp.statusCode || 0;\n            const statusMessage = resp.statusMessage || \"\";\n            const headers = Object.keys(resp.headers || {}).reduce((accum, name)=>{\n                let value = resp.headers[name] || \"\";\n                if (Array.isArray(value)) {\n                    value = value.join(\", \");\n                }\n                accum[name] = value;\n                return accum;\n            }, {});\n            let body = null;\n            //resp.setEncoding(\"utf8\");\n            resp.on(\"data\", (chunk)=>{\n                if (signal) {\n                    try {\n                        signal.checkSignal();\n                    } catch (error) {\n                        return reject(error);\n                    }\n                }\n                if (body == null) {\n                    body = chunk;\n                } else {\n                    const newBody = new Uint8Array(body.length + chunk.length);\n                    newBody.set(body, 0);\n                    newBody.set(chunk, body.length);\n                    body = newBody;\n                }\n            });\n            resp.on(\"end\", ()=>{\n                if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                    body = (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.getBytes)((0,zlib__WEBPACK_IMPORTED_MODULE_2__.gunzipSync)(body));\n                }\n                resolve({\n                    statusCode,\n                    statusMessage,\n                    headers,\n                    body\n                });\n            });\n            resp.on(\"error\", (error)=>{\n                //@TODO: Should this just return nornal response with a server error?\n                error.response = {\n                    statusCode,\n                    statusMessage,\n                    headers,\n                    body\n                };\n                reject(error);\n            });\n        });\n        request.on(\"error\", (error)=>{\n            reject(error);\n        });\n    });\n} //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2dldHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0I7QUFDRTtBQUNRO0FBQ0c7QUFDQTtBQUNyQzs7Q0FFQyxHQUNNLGVBQWVLLE9BQU9DLEdBQUcsRUFBRUMsTUFBTTtJQUNwQyxNQUFNQyxXQUFXRixJQUFJRyxHQUFHLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQyxXQUFXO0lBQ2xEUixrREFBTUEsQ0FBQ0ssYUFBYSxVQUFVQSxhQUFhLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRUEsU0FBUyxDQUFDLEVBQUUseUJBQXlCO1FBQzdHSSxNQUFNO1lBQUVKO1FBQVM7UUFDakJLLFdBQVc7SUFDZjtJQUNBVixrREFBTUEsQ0FBQ0ssYUFBYSxXQUFXLENBQUNGLElBQUlRLFdBQVcsSUFBSVIsSUFBSVMsMkJBQTJCLEVBQUUsK0NBQStDLHlCQUF5QjtRQUN4SkYsV0FBVztJQUNmO0lBQ0EsTUFBTUcsU0FBU1YsSUFBSVUsTUFBTTtJQUN6QixNQUFNQyxVQUFVQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHYixJQUFJVyxPQUFPO0lBQzdDLE1BQU1HLFVBQVU7UUFBRUo7UUFBUUM7SUFBUTtJQUNsQyxNQUFNSSxVQUFVLENBQUMsYUFBYyxTQUFVckIsaUNBQUlBLEdBQUdDLGtDQUFJLEVBQUdvQixPQUFPLENBQUNmLElBQUlHLEdBQUcsRUFBRVc7SUFDeEVDLFFBQVFDLFVBQVUsQ0FBQ2hCLElBQUlpQixPQUFPO0lBQzlCLE1BQU1DLE9BQU9sQixJQUFJa0IsSUFBSTtJQUNyQixJQUFJQSxNQUFNO1FBQ05ILFFBQVFJLEtBQUssQ0FBQ0MsT0FBT0MsSUFBSSxDQUFDSDtJQUM5QjtJQUNBSCxRQUFRTyxHQUFHO0lBQ1gsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCLDZEQUE2RDtRQUM3RCxzQ0FBc0M7UUFDdENWLFFBQVFXLElBQUksQ0FBQyxZQUFZLENBQUNDO1lBQ3RCLE1BQU1DLGFBQWFELEtBQUtDLFVBQVUsSUFBSTtZQUN0QyxNQUFNQyxnQkFBZ0JGLEtBQUtFLGFBQWEsSUFBSTtZQUM1QyxNQUFNbEIsVUFBVUMsT0FBT2tCLElBQUksQ0FBQ0gsS0FBS2hCLE9BQU8sSUFBSSxDQUFDLEdBQUdvQixNQUFNLENBQUMsQ0FBQ0MsT0FBT0M7Z0JBQzNELElBQUlDLFFBQVFQLEtBQUtoQixPQUFPLENBQUNzQixLQUFLLElBQUk7Z0JBQ2xDLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtvQkFDdEJBLFFBQVFBLE1BQU1HLElBQUksQ0FBQztnQkFDdkI7Z0JBQ0FMLEtBQUssQ0FBQ0MsS0FBSyxHQUFHQztnQkFDZCxPQUFPRjtZQUNYLEdBQUcsQ0FBQztZQUNKLElBQUlkLE9BQU87WUFDWCwyQkFBMkI7WUFDM0JTLEtBQUtXLEVBQUUsQ0FBQyxRQUFRLENBQUNDO2dCQUNiLElBQUl0QyxRQUFRO29CQUNSLElBQUk7d0JBQ0FBLE9BQU91QyxXQUFXO29CQUN0QixFQUNBLE9BQU9DLE9BQU87d0JBQ1YsT0FBT2hCLE9BQU9nQjtvQkFDbEI7Z0JBQ0o7Z0JBQ0EsSUFBSXZCLFFBQVEsTUFBTTtvQkFDZEEsT0FBT3FCO2dCQUNYLE9BQ0s7b0JBQ0QsTUFBTUcsVUFBVSxJQUFJQyxXQUFXekIsS0FBSzBCLE1BQU0sR0FBR0wsTUFBTUssTUFBTTtvQkFDekRGLFFBQVFHLEdBQUcsQ0FBQzNCLE1BQU07b0JBQ2xCd0IsUUFBUUcsR0FBRyxDQUFDTixPQUFPckIsS0FBSzBCLE1BQU07b0JBQzlCMUIsT0FBT3dCO2dCQUNYO1lBQ0o7WUFDQWYsS0FBS1csRUFBRSxDQUFDLE9BQU87Z0JBQ1gsSUFBSTNCLE9BQU8sQ0FBQyxtQkFBbUIsS0FBSyxVQUFVTyxNQUFNO29CQUNoREEsT0FBT3BCLGtEQUFRQSxDQUFDRixnREFBVUEsQ0FBQ3NCO2dCQUMvQjtnQkFDQU0sUUFBUTtvQkFBRUk7b0JBQVlDO29CQUFlbEI7b0JBQVNPO2dCQUFLO1lBQ3ZEO1lBQ0FTLEtBQUtXLEVBQUUsQ0FBQyxTQUFTLENBQUNHO2dCQUNkLHFFQUFxRTtnQkFDckVBLE1BQU1LLFFBQVEsR0FBRztvQkFBRWxCO29CQUFZQztvQkFBZWxCO29CQUFTTztnQkFBSztnQkFDNURPLE9BQU9nQjtZQUNYO1FBQ0o7UUFDQTFCLFFBQVF1QixFQUFFLENBQUMsU0FBUyxDQUFDRztZQUFZaEIsT0FBT2dCO1FBQVE7SUFDcEQ7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLmpzP2Q0MDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0dHAgZnJvbSBcImh0dHBcIjtcbmltcG9ydCBodHRwcyBmcm9tIFwiaHR0cHNcIjtcbmltcG9ydCB7IGd1bnppcFN5bmMgfSBmcm9tIFwiemxpYlwiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgc2lnbmFsKSB7XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXEudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBpbmZvOiB7IHByb3RvY29sIH0sXG4gICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICB9KTtcbiAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCAhcmVxLmNyZWRlbnRpYWxzIHx8IHJlcS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24sIFwiaW5zZWN1cmUgYXV0aG9yaXplZCBjb25uZWN0aW9ucyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICB9KTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXEuaGVhZGVycyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgbWV0aG9kLCBoZWFkZXJzIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgocHJvdG9jb2wgPT09IFwiaHR0cFwiKSA/IGh0dHAgOiBodHRwcykucmVxdWVzdChyZXEudXJsLCBvcHRpb25zKTtcbiAgICByZXF1ZXN0LnNldFRpbWVvdXQocmVxLnRpbWVvdXQpO1xuICAgIGNvbnN0IGJvZHkgPSByZXEuYm9keTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgICByZXF1ZXN0LndyaXRlKEJ1ZmZlci5mcm9tKGJvZHkpKTtcbiAgICB9XG4gICAgcmVxdWVzdC5lbmQoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBAVE9ETzogTm9kZSAxNSBhZGRlZCBBYm9ydFNpZ25hbDsgb25jZSB3ZSBkcm9wIHN1cHBvcnQgZm9yXG4gICAgICAgIC8vIE5vZGUxNCwgd2UgY2FuIGFkZCB0aGF0IGluIGhlcmUgdG9vXG4gICAgICAgIHJlcXVlc3Qub25jZShcInJlc3BvbnNlXCIsIChyZXNwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcC5zdGF0dXNDb2RlIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNNZXNzYWdlID0gcmVzcC5zdGF0dXNNZXNzYWdlIHx8IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmtleXMocmVzcC5oZWFkZXJzIHx8IHt9KS5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcmVzcC5oZWFkZXJzW25hbWVdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgIC8vcmVzcC5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICByZXNwLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Qm9keSA9IG5ldyBVaW50OEFycmF5KGJvZHkubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm9keS5zZXQoYm9keSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JvZHkuc2V0KGNodW5rLCBib2R5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBuZXdCb2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcC5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LWVuY29kaW5nXCJdID09PSBcImd6aXBcIiAmJiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBnZXRCeXRlcyhndW56aXBTeW5jKGJvZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3Aub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvL0BUT0RPOiBTaG91bGQgdGhpcyBqdXN0IHJldHVybiBub3JuYWwgcmVzcG9uc2Ugd2l0aCBhIHNlcnZlciBlcnJvcj9cbiAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSB9O1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHsgcmVqZWN0KGVycm9yKTsgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwuanMubWFwIl0sIm5hbWVzIjpbImh0dHAiLCJodHRwcyIsImd1bnppcFN5bmMiLCJhc3NlcnQiLCJnZXRCeXRlcyIsImdldFVybCIsInJlcSIsInNpZ25hbCIsInByb3RvY29sIiwidXJsIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImluZm8iLCJvcGVyYXRpb24iLCJjcmVkZW50aWFscyIsImFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiIsIm1ldGhvZCIsImhlYWRlcnMiLCJPYmplY3QiLCJhc3NpZ24iLCJvcHRpb25zIiwicmVxdWVzdCIsInNldFRpbWVvdXQiLCJ0aW1lb3V0IiwiYm9keSIsIndyaXRlIiwiQnVmZmVyIiwiZnJvbSIsImVuZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25jZSIsInJlc3AiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsIm5hbWUiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJvbiIsImNodW5rIiwiY2hlY2tTaWduYWwiLCJlcnJvciIsIm5ld0JvZHkiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwic2V0IiwicmVzcG9uc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/geturl.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js":
/*!********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/maths.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bits)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL21hdGhzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ2dEO0FBQ0k7QUFDckQsTUFBTUksT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLGlEQUFpRDtBQUNqRCx1Q0FBdUM7QUFDdkMsTUFBTUUsV0FBVztBQUNqQjs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsTUFBTTtJQUNuQyxNQUFNQyxRQUFRQyxRQUFRSCxRQUFRO0lBQzlCLE1BQU1JLFFBQVFSLE9BQU9TLFVBQVVKLFFBQVE7SUFDdkNSLGtEQUFNQSxDQUFDLFNBQVVXLFVBQVdULE1BQU0sWUFBWSxpQkFBaUI7UUFDM0RXLFdBQVc7UUFBWUMsT0FBTztRQUFZTCxPQUFPRjtJQUNyRDtJQUNBLHlDQUF5QztJQUN6QyxJQUFJRSxTQUFVRSxRQUFRUCxNQUFPO1FBQ3pCLE1BQU1XLE9BQU8sQ0FBQ1gsUUFBUU8sS0FBSSxJQUFLUDtRQUMvQixPQUFPLENBQUUsRUFBQyxDQUFFSyxRQUFTTSxJQUFHLElBQUtYLElBQUc7SUFDcEM7SUFDQSxPQUFPSztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTTyxPQUFPVCxNQUFNLEVBQUVDLE1BQU07SUFDakMsSUFBSUMsUUFBUVEsVUFBVVYsUUFBUTtJQUM5QixNQUFNSSxRQUFRUixPQUFPUyxVQUFVSixRQUFRO0lBQ3ZDLE1BQU1VLFFBQVNkLFFBQVNPLFFBQVFQO0lBQ2hDLElBQUlLLFFBQVFQLE1BQU07UUFDZE8sUUFBUSxDQUFDQTtRQUNUVCxrREFBTUEsQ0FBQ1MsU0FBU1MsT0FBTyxXQUFXLGlCQUFpQjtZQUMvQ0wsV0FBVztZQUFVQyxPQUFPO1lBQVlMLE9BQU9GO1FBQ25EO1FBQ0EsTUFBTVEsT0FBTyxDQUFDWCxRQUFRTyxLQUFJLElBQUtQO1FBQy9CLE9BQU8sQ0FBQyxDQUFFSyxRQUFTTSxJQUFHLElBQUtYO0lBQy9CLE9BQ0s7UUFDREosa0RBQU1BLENBQUNTLFFBQVFTLE9BQU8sWUFBWSxpQkFBaUI7WUFDL0NMLFdBQVc7WUFBVUMsT0FBTztZQUFZTCxPQUFPRjtRQUNuRDtJQUNKO0lBQ0EsT0FBT0U7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU00sS0FBS1IsTUFBTSxFQUFFWSxLQUFLO0lBQzlCLE1BQU1WLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsTUFBTWEsT0FBT2pCLE9BQU9TLFVBQVVPLE9BQU87SUFDckMsT0FBT1YsUUFBUyxDQUFDTCxRQUFRZ0IsSUFBRyxJQUFLaEI7QUFDckM7QUFDQTs7O0NBR0MsR0FDTSxTQUFTYSxVQUFVUixLQUFLLEVBQUVZLElBQUk7SUFDakMsT0FBUSxPQUFRWjtRQUNaLEtBQUs7WUFBVSxPQUFPQTtRQUN0QixLQUFLO1lBQ0RSLDBEQUFjQSxDQUFDcUIsT0FBT0MsU0FBUyxDQUFDZCxRQUFRLGFBQWFZLFFBQVEsU0FBU1o7WUFDdEVSLDBEQUFjQSxDQUFDUSxTQUFTLENBQUNKLFlBQVlJLFNBQVNKLFVBQVUsWUFBWWdCLFFBQVEsU0FBU1o7WUFDckYsT0FBT04sT0FBT007UUFDbEIsS0FBSztZQUNELElBQUk7Z0JBQ0EsSUFBSUEsVUFBVSxJQUFJO29CQUNkLE1BQU0sSUFBSWUsTUFBTTtnQkFDcEI7Z0JBQ0EsSUFBSWYsS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUs7b0JBQ3RDLE9BQU8sQ0FBQ04sT0FBT00sTUFBTWdCLFNBQVMsQ0FBQztnQkFDbkM7Z0JBQ0EsT0FBT3RCLE9BQU9NO1lBQ2xCLEVBQ0EsT0FBT2lCLEdBQUc7Z0JBQ056QiwwREFBY0EsQ0FBQyxPQUFPLENBQUMsNkJBQTZCLEVBQUV5QixFQUFFQyxPQUFPLENBQUMsQ0FBQyxFQUFFTixRQUFRLFNBQVNaO1lBQ3hGO0lBQ1I7SUFDQVIsMERBQWNBLENBQUMsT0FBTyw4QkFBOEJvQixRQUFRLFNBQVNaO0FBQ3pFO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0MsUUFBUUQsS0FBSyxFQUFFWSxJQUFJO0lBQy9CLE1BQU1PLFNBQVNYLFVBQVVSLE9BQU9ZO0lBQ2hDckIsa0RBQU1BLENBQUM0QixVQUFVMUIsTUFBTSxxQ0FBcUMsaUJBQWlCO1FBQ3pFWSxPQUFPO1FBQVlELFdBQVc7UUFBV0o7SUFDN0M7SUFDQSxPQUFPbUI7QUFDWDtBQUNBLE1BQU1DLFVBQVU7QUFDaEI7OztDQUdDLEdBQ00sU0FBU0MsU0FBU3JCLEtBQUs7SUFDMUIsSUFBSUEsaUJBQWlCc0IsWUFBWTtRQUM3QixJQUFJSCxTQUFTO1FBQ2IsS0FBSyxNQUFNSSxLQUFLdkIsTUFBTztZQUNuQm1CLFVBQVVDLE9BQU8sQ0FBQ0csS0FBSyxFQUFFO1lBQ3pCSixVQUFVQyxPQUFPLENBQUNHLElBQUksS0FBSztRQUMvQjtRQUNBLE9BQU83QixPQUFPeUI7SUFDbEI7SUFDQSxPQUFPWCxVQUFVUjtBQUNyQjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNHLFVBQVVILEtBQUssRUFBRVksSUFBSTtJQUNqQyxPQUFRLE9BQVFaO1FBQ1osS0FBSztZQUNEUiwwREFBY0EsQ0FBQ1EsU0FBUyxDQUFDSixZQUFZSSxTQUFTSixVQUFVLFlBQVlnQixRQUFRLFNBQVNaO1lBQ3JGLE9BQU9hLE9BQU9iO1FBQ2xCLEtBQUs7WUFDRFIsMERBQWNBLENBQUNxQixPQUFPQyxTQUFTLENBQUNkLFFBQVEsYUFBYVksUUFBUSxTQUFTWjtZQUN0RVIsMERBQWNBLENBQUNRLFNBQVMsQ0FBQ0osWUFBWUksU0FBU0osVUFBVSxZQUFZZ0IsUUFBUSxTQUFTWjtZQUNyRixPQUFPQTtRQUNYLEtBQUs7WUFDRCxJQUFJO2dCQUNBLElBQUlBLFVBQVUsSUFBSTtvQkFDZCxNQUFNLElBQUllLE1BQU07Z0JBQ3BCO2dCQUNBLE9BQU9aLFVBQVVULE9BQU9NLFFBQVFZO1lBQ3BDLEVBQ0EsT0FBT0ssR0FBRztnQkFDTnpCLDBEQUFjQSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsRUFBRXlCLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLEVBQUVOLFFBQVEsU0FBU1o7WUFDbkY7SUFDUjtJQUNBUiwwREFBY0EsQ0FBQyxPQUFPLHlCQUF5Qm9CLFFBQVEsU0FBU1o7QUFDcEU7QUFDQTs7O0NBR0MsR0FDTSxTQUFTd0IsU0FBU3hCLEtBQUs7SUFDMUIsT0FBT0csVUFBVWtCLFNBQVNyQjtBQUM5QjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVN5QixRQUFRM0IsTUFBTSxFQUFFQyxNQUFNO0lBQ2xDLE1BQU1DLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsSUFBSXFCLFNBQVNuQixNQUFNMEIsUUFBUSxDQUFDO0lBQzVCLElBQUkzQixVQUFVLE1BQU07UUFDaEIscUNBQXFDO1FBQ3JDLElBQUlvQixPQUFPUSxNQUFNLEdBQUcsR0FBRztZQUNuQlIsU0FBUyxNQUFNQTtRQUNuQjtJQUNKLE9BQ0s7UUFDRCxNQUFNakIsUUFBUUMsVUFBVUosUUFBUTtRQUNoQ1Isa0RBQU1BLENBQUNXLFFBQVEsS0FBS2lCLE9BQU9RLE1BQU0sRUFBRSxDQUFDLHFCQUFxQixFQUFFekIsTUFBTSxNQUFNLENBQUMsRUFBRSxpQkFBaUI7WUFDdkZFLFdBQVc7WUFDWEMsT0FBTztZQUNQTCxPQUFPRjtRQUNYO1FBQ0Esc0NBQXNDO1FBQ3RDLE1BQU9xQixPQUFPUSxNQUFNLEdBQUl6QixRQUFRLEVBQUk7WUFDaENpQixTQUFTLE1BQU1BO1FBQ25CO0lBQ0o7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCO0FBQ0E7O0NBRUMsR0FDTSxTQUFTUyxVQUFVOUIsTUFBTTtJQUM1QixNQUFNRSxRQUFRQyxRQUFRSCxRQUFRO0lBQzlCLElBQUlFLFVBQVVQLE1BQU07UUFDaEIsT0FBTyxJQUFJNkIsV0FBVyxFQUFFO0lBQzVCO0lBQ0EsSUFBSU8sTUFBTTdCLE1BQU0wQixRQUFRLENBQUM7SUFDekIsSUFBSUcsSUFBSUYsTUFBTSxHQUFHLEdBQUc7UUFDaEJFLE1BQU0sTUFBTUE7SUFDaEI7SUFDQSxNQUFNVixTQUFTLElBQUlHLFdBQVdPLElBQUlGLE1BQU0sR0FBRztJQUMzQyxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSVgsT0FBT1EsTUFBTSxFQUFFRyxJQUFLO1FBQ3BDLE1BQU1DLFNBQVNELElBQUk7UUFDbkJYLE1BQU0sQ0FBQ1csRUFBRSxHQUFHRSxTQUFTSCxJQUFJYixTQUFTLENBQUNlLFFBQVFBLFNBQVMsSUFBSTtJQUM1RDtJQUNBLE9BQU9aO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTYyxXQUFXakMsS0FBSztJQUM1QixJQUFJbUIsU0FBUzlCLGlEQUFPQSxDQUFDQyxxREFBV0EsQ0FBQ1UsU0FBU0EsUUFBUTRCLFVBQVU1QixRQUFRZ0IsU0FBUyxDQUFDO0lBQzlFLE1BQU9HLE9BQU9lLFVBQVUsQ0FBQyxLQUFNO1FBQzNCZixTQUFTQSxPQUFPSCxTQUFTLENBQUM7SUFDOUI7SUFDQSxJQUFJRyxXQUFXLElBQUk7UUFDZkEsU0FBUztJQUNiO0lBQ0EsT0FBTyxPQUFPQTtBQUNsQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanM/ZjIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJpdHMpYCwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGFkIHRoZSB2YWx1ZSB0byB0aGUgcmVxdWlyZWQgd2lkdGhcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVBcnJheShfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGlmICh2YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW10pO1xuICAgIH1cbiAgICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAyO1xuICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0hleFN0cmluZ11dIGZvciAlJXZhbHVlJSUgc2FmZSB0byB1c2UgYXMgYSAvL1F1YW50aXR5Ly8uXG4gKlxuICogIEEgLy9RdWFudGl0eS8vIGRvZXMgbm90IGhhdmUgYW5kIGxlYWRpbmcgMCB2YWx1ZXMgdW5sZXNzIHRoZSB2YWx1ZSBpc1xuICogIHRoZSBsaXRlcmFsIHZhbHVlIGAweDBgLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCBmb3IgSlNTT04tUlBDXG4gKiAgbnVtZXJpYyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1F1YW50aXR5KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGhleGxpZnkoaXNCeXRlc0xpa2UodmFsdWUpID8gdmFsdWUgOiB0b0JlQXJyYXkodmFsdWUpKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aHMuanMubWFwIl0sIm5hbWVzIjpbImhleGxpZnkiLCJpc0J5dGVzTGlrZSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsIkJOXzEiLCJtYXhWYWx1ZSIsImZyb21Ud29zIiwiX3ZhbHVlIiwiX3dpZHRoIiwidmFsdWUiLCJnZXRVaW50Iiwid2lkdGgiLCJnZXROdW1iZXIiLCJvcGVyYXRpb24iLCJmYXVsdCIsIm1hc2siLCJ0b1R3b3MiLCJnZXRCaWdJbnQiLCJsaW1pdCIsIl9iaXRzIiwiYml0cyIsIm5hbWUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJFcnJvciIsInN1YnN0cmluZyIsImUiLCJtZXNzYWdlIiwicmVzdWx0IiwiTmliYmxlcyIsInRvQmlnSW50IiwiVWludDhBcnJheSIsInYiLCJ0b051bWJlciIsInRvQmVIZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsInRvQmVBcnJheSIsImhleCIsImkiLCJvZmZzZXQiLCJwYXJzZUludCIsInRvUXVhbnRpdHkiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/properties.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsU0FBU0EsVUFBVUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDaEMsTUFBTUMsUUFBUUYsS0FBS0csS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSTtJQUM3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsTUFBTU0sTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE9BQVFQO1lBQ0osS0FBSztnQkFDRDtZQUNKLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsSUFBSSxPQUFRRCxVQUFXQyxNQUFNO29CQUN6QjtnQkFDSjtRQUNSO0lBQ0o7SUFDQSxNQUFNUyxRQUFRLElBQUlDLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRVYsS0FBSyxDQUFDO0lBQ3hEUyxNQUFNRSxJQUFJLEdBQUc7SUFDYkYsTUFBTUcsUUFBUSxHQUFHLENBQUMsTUFBTSxFQUFFWCxLQUFLLENBQUM7SUFDaENRLE1BQU1WLEtBQUssR0FBR0E7SUFDZCxNQUFNVTtBQUNWO0FBQ0E7OztDQUdDLEdBQ00sZUFBZUksa0JBQWtCZCxLQUFLO0lBQ3pDLE1BQU1lLE9BQU9DLE9BQU9ELElBQUksQ0FBQ2Y7SUFDekIsTUFBTWlCLFVBQVUsTUFBTUMsUUFBUUMsR0FBRyxDQUFDSixLQUFLVixHQUFHLENBQUMsQ0FBQ2UsSUFBTUYsUUFBUUcsT0FBTyxDQUFDckIsS0FBSyxDQUFDb0IsRUFBRTtJQUMxRSxPQUFPSCxRQUFRSyxNQUFNLENBQUMsQ0FBQ0MsT0FBT0MsR0FBR0M7UUFDN0JGLEtBQUssQ0FBQ1IsSUFBSSxDQUFDVSxNQUFNLENBQUMsR0FBR0Q7UUFDckIsT0FBT0Q7SUFDWCxHQUFHLENBQUM7QUFDUjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTRyxpQkFBaUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFekIsS0FBSztJQUNsRCxJQUFLLElBQUkwQixPQUFPRCxPQUFRO1FBQ3BCLElBQUk1QixRQUFRNEIsTUFBTSxDQUFDQyxJQUFJO1FBQ3ZCLE1BQU01QixPQUFRRSxRQUFRQSxLQUFLLENBQUMwQixJQUFJLEdBQUc7UUFDbkMsSUFBSTVCLE1BQU07WUFDTkYsVUFBVUMsT0FBT0MsTUFBTTRCO1FBQzNCO1FBQ0FiLE9BQU9jLGNBQWMsQ0FBQ0gsUUFBUUUsS0FBSztZQUFFRSxZQUFZO1lBQU0vQjtZQUFPZ0MsVUFBVTtRQUFNO0lBQ2xGO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanM/YjY2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJjaGVja1R5cGUiLCJ2YWx1ZSIsInR5cGUiLCJuYW1lIiwidHlwZXMiLCJzcGxpdCIsIm1hcCIsInQiLCJ0cmltIiwiaSIsImxlbmd0aCIsImVycm9yIiwiRXJyb3IiLCJjb2RlIiwiYXJndW1lbnQiLCJyZXNvbHZlUHJvcGVydGllcyIsImtleXMiLCJPYmplY3QiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsImsiLCJyZXNvbHZlIiwicmVkdWNlIiwiYWNjdW0iLCJ2IiwiaW5kZXgiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwidmFsdWVzIiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: () => (/* binding */ decodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while(result.length < 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length,\n            offset\n        });\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data,\n        length: 0,\n        offset: 1\n    });\n    const checkOffset = (offset)=>{\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length: data.length,\n            offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: hexlifyByte(data[offset])\n    };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */ function decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n} //# sourceMappingURL=rlp-decode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0RBQWdEO0FBQ1o7QUFDaUI7QUFDaEI7QUFDckMsU0FBU0ksWUFBWUMsS0FBSztJQUN0QixJQUFJQyxTQUFTRCxNQUFNRSxRQUFRLENBQUM7SUFDNUIsTUFBT0QsT0FBT0UsTUFBTSxHQUFHLEVBQUc7UUFDdEJGLFNBQVMsTUFBTUE7SUFDbkI7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCO0FBQ0EsU0FBU0csa0JBQWtCQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUgsTUFBTTtJQUMzQyxJQUFJRixTQUFTO0lBQ2IsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDN0JOLFNBQVMsU0FBVSxNQUFPSSxJQUFJLENBQUNDLFNBQVNDLEVBQUU7SUFDOUM7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBU08sZ0JBQWdCSCxJQUFJLEVBQUVDLE1BQU0sRUFBRUcsV0FBVyxFQUFFTixNQUFNO0lBQ3RELE1BQU1GLFNBQVMsRUFBRTtJQUNqQixNQUFPUSxjQUFjSCxTQUFTLElBQUlILE9BQVE7UUFDdEMsTUFBTU8sVUFBVUMsUUFBUU4sTUFBTUk7UUFDOUJSLE9BQU9XLElBQUksQ0FBQ0YsUUFBUVQsTUFBTTtRQUMxQlEsZUFBZUMsUUFBUUcsUUFBUTtRQUMvQmpCLGtEQUFNQSxDQUFDYSxlQUFlSCxTQUFTLElBQUlILFFBQVEsd0JBQXdCLGtCQUFrQjtZQUNqRlcsUUFBUVQ7WUFBTUY7WUFBUUc7UUFDMUI7SUFDSjtJQUNBLE9BQU87UUFBRU8sVUFBVyxJQUFJVjtRQUFTRixRQUFRQTtJQUFPO0FBQ3BEO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVNVLFFBQVFOLElBQUksRUFBRUMsTUFBTTtJQUN6QlYsa0RBQU1BLENBQUNTLEtBQUtGLE1BQU0sS0FBSyxHQUFHLGtCQUFrQixrQkFBa0I7UUFDMURXLFFBQVFUO1FBQU1GLFFBQVE7UUFBR0csUUFBUTtJQUNyQztJQUNBLE1BQU1TLGNBQWMsQ0FBQ1Q7UUFDakJWLGtEQUFNQSxDQUFDVSxVQUFVRCxLQUFLRixNQUFNLEVBQUUsZ0NBQWdDLGtCQUFrQjtZQUM1RVcsUUFBUVQ7WUFBTUYsUUFBUUUsS0FBS0YsTUFBTTtZQUFFRztRQUN2QztJQUNKO0lBQ0EsaUNBQWlDO0lBQ2pDLElBQUlELElBQUksQ0FBQ0MsT0FBTyxJQUFJLE1BQU07UUFDdEIsTUFBTVUsZUFBZVgsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDcENTLFlBQVlULFNBQVMsSUFBSVU7UUFDekIsTUFBTWIsU0FBU0Msa0JBQWtCQyxNQUFNQyxTQUFTLEdBQUdVO1FBQ25ERCxZQUFZVCxTQUFTLElBQUlVLGVBQWViO1FBQ3hDLE9BQU9LLGdCQUFnQkgsTUFBTUMsUUFBUUEsU0FBUyxJQUFJVSxjQUFjQSxlQUFlYjtJQUNuRixPQUNLLElBQUlFLElBQUksQ0FBQ0MsT0FBTyxJQUFJLE1BQU07UUFDM0IsTUFBTUgsU0FBU0UsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDOUJTLFlBQVlULFNBQVMsSUFBSUg7UUFDekIsT0FBT0ssZ0JBQWdCSCxNQUFNQyxRQUFRQSxTQUFTLEdBQUdIO0lBQ3JELE9BQ0ssSUFBSUUsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUMzQixNQUFNVSxlQUFlWCxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNwQ1MsWUFBWVQsU0FBUyxJQUFJVTtRQUN6QixNQUFNYixTQUFTQyxrQkFBa0JDLE1BQU1DLFNBQVMsR0FBR1U7UUFDbkRELFlBQVlULFNBQVMsSUFBSVUsZUFBZWI7UUFDeEMsTUFBTUYsU0FBU04saURBQU9BLENBQUNVLEtBQUtZLEtBQUssQ0FBQ1gsU0FBUyxJQUFJVSxjQUFjVixTQUFTLElBQUlVLGVBQWViO1FBQ3pGLE9BQU87WUFBRVUsVUFBVyxJQUFJRyxlQUFlYjtZQUFTRixRQUFRQTtRQUFPO0lBQ25FLE9BQ0ssSUFBSUksSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUMzQixNQUFNSCxTQUFTRSxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUM5QlMsWUFBWVQsU0FBUyxJQUFJSDtRQUN6QixNQUFNRixTQUFTTixpREFBT0EsQ0FBQ1UsS0FBS1ksS0FBSyxDQUFDWCxTQUFTLEdBQUdBLFNBQVMsSUFBSUg7UUFDM0QsT0FBTztZQUFFVSxVQUFXLElBQUlWO1lBQVNGLFFBQVFBO1FBQU87SUFDcEQ7SUFDQSxPQUFPO1FBQUVZLFVBQVU7UUFBR1osUUFBUUYsWUFBWU0sSUFBSSxDQUFDQyxPQUFPO0lBQUU7QUFDNUQ7QUFDQTs7Q0FFQyxHQUNNLFNBQVNZLFVBQVVDLEtBQUs7SUFDM0IsTUFBTWQsT0FBT1Asa0RBQVFBLENBQUNxQixPQUFPO0lBQzdCLE1BQU1ULFVBQVVDLFFBQVFOLE1BQU07SUFDOUJSLDBEQUFjQSxDQUFDYSxRQUFRRyxRQUFRLEtBQUtSLEtBQUtGLE1BQU0sRUFBRSxxQ0FBcUMsUUFBUWdCO0lBQzlGLE9BQU9ULFFBQVFULE1BQU07QUFDekIsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanM/NTE4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmZ1bmN0aW9uIGhleGxpZnlCeXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGFzc2VydChjaGlsZE9mZnNldCA8PSBvZmZzZXQgKyAxICsgbGVuZ3RoLCBcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IDAsIG9mZnNldDogMVxuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgICBhc3NlcnQob2Zmc2V0IDw9IGRhdGEubGVuZ3RoLCBcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogZGF0YS5sZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnlCeXRlKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbi8qKlxuICogIERlY29kZXMgJSVkYXRhJSUgaW50byB0aGUgc3RydWN0dXJlZCBkYXRhIGl0IHJlcHJlc2VudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNvZGVkLmNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCwgXCJ1bmV4cGVjdGVkIGp1bmsgYWZ0ZXIgcmxwIHBheWxvYWRcIiwgXCJkYXRhXCIsIF9kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZGVjb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRCeXRlcyIsImhleGxpZnlCeXRlIiwidmFsdWUiLCJyZXN1bHQiLCJ0b1N0cmluZyIsImxlbmd0aCIsInVuYXJyYXlpZnlJbnRlZ2VyIiwiZGF0YSIsIm9mZnNldCIsImkiLCJfZGVjb2RlQ2hpbGRyZW4iLCJjaGlsZE9mZnNldCIsImRlY29kZWQiLCJfZGVjb2RlIiwicHVzaCIsImNvbnN1bWVkIiwiYnVmZmVyIiwiY2hlY2tPZmZzZXQiLCJsZW5ndGhMZW5ndGgiLCJzbGljZSIsImRlY29kZVJscCIsIl9kYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-decode.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: () => (/* binding */ encodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */ function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)){\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n} //# sourceMappingURL=rlp-encode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1lbmNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxnREFBZ0Q7QUFDWDtBQUNyQyxTQUFTQyxnQkFBZ0JDLEtBQUs7SUFDMUIsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLE1BQU9ELE1BQU87UUFDVkMsT0FBT0MsT0FBTyxDQUFDRixRQUFRO1FBQ3ZCQSxVQUFVO0lBQ2Q7SUFDQSxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsUUFBUUMsTUFBTTtJQUNuQixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFNBQVM7UUFDdkIsSUFBSUcsVUFBVSxFQUFFO1FBQ2hCSCxPQUFPSSxPQUFPLENBQUMsU0FBVUMsS0FBSztZQUMxQkYsVUFBVUEsUUFBUUcsTUFBTSxDQUFDUCxRQUFRTTtRQUNyQztRQUNBLElBQUlGLFFBQVFJLE1BQU0sSUFBSSxJQUFJO1lBQ3RCSixRQUFRTCxPQUFPLENBQUMsT0FBT0ssUUFBUUksTUFBTTtZQUNyQyxPQUFPSjtRQUNYO1FBQ0EsTUFBTUksU0FBU1osZ0JBQWdCUSxRQUFRSSxNQUFNO1FBQzdDQSxPQUFPVCxPQUFPLENBQUMsT0FBT1MsT0FBT0EsTUFBTTtRQUNuQyxPQUFPQSxPQUFPRCxNQUFNLENBQUNIO0lBQ3pCO0lBQ0EsTUFBTUssT0FBT1AsTUFBTVEsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ2pCLGtEQUFRQSxDQUFDTSxRQUFRO0lBQ3pELElBQUlRLEtBQUtELE1BQU0sS0FBSyxLQUFLQyxJQUFJLENBQUMsRUFBRSxJQUFJLE1BQU07UUFDdEMsT0FBT0E7SUFDWCxPQUNLLElBQUlBLEtBQUtELE1BQU0sSUFBSSxJQUFJO1FBQ3hCQyxLQUFLVixPQUFPLENBQUMsT0FBT1UsS0FBS0QsTUFBTTtRQUMvQixPQUFPQztJQUNYO0lBQ0EsTUFBTUQsU0FBU1osZ0JBQWdCYSxLQUFLRCxNQUFNO0lBQzFDQSxPQUFPVCxPQUFPLENBQUMsT0FBT1MsT0FBT0EsTUFBTTtJQUNuQyxPQUFPQSxPQUFPRCxNQUFNLENBQUNFO0FBQ3pCO0FBQ0EsTUFBTUksVUFBVTtBQUNoQjs7Q0FFQyxHQUNNLFNBQVNDLFVBQVViLE1BQU07SUFDNUIsSUFBSUgsU0FBUztJQUNiLEtBQUssTUFBTWlCLEtBQUtmLFFBQVFDLFFBQVM7UUFDN0JILFVBQVVlLE9BQU8sQ0FBQ0UsS0FBSyxFQUFFO1FBQ3pCakIsVUFBVWUsT0FBTyxDQUFDRSxJQUFJLElBQUk7SUFDOUI7SUFDQSxPQUFPakI7QUFDWCxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcz8yYjU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRCeXRlcyhvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmxwKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChjb25zdCB2IG9mIF9lbmNvZGUob2JqZWN0KSkge1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ID4+IDRdO1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXJyYXlpZnlJbnRlZ2VyIiwidmFsdWUiLCJyZXN1bHQiLCJ1bnNoaWZ0IiwiX2VuY29kZSIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInBheWxvYWQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjb25jYXQiLCJsZW5ndGgiLCJkYXRhIiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwibmliYmxlcyIsImVuY29kZVJscCIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/rlp-encode.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/utf8.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ \n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V0ZjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQUNvQztBQUN5QjtBQUM5RCxTQUFTRyxVQUFVQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDMURQLDBEQUFjQSxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRUksT0FBTyxFQUFFLEVBQUVELE9BQU8sQ0FBQyxFQUFFLFNBQVNFO0FBQ3ZGO0FBQ0EsU0FBU0csV0FBV0wsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzNELHVHQUF1RztJQUN2RyxJQUFJSixXQUFXLGdCQUFnQkEsV0FBVyx1QkFBdUI7UUFDN0QsSUFBSU0sSUFBSTtRQUNSLElBQUssSUFBSUMsSUFBSU4sU0FBUyxHQUFHTSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7WUFDNUMsSUFBSUwsS0FBSyxDQUFDSyxFQUFFLElBQUksTUFBTSxNQUFNO2dCQUN4QjtZQUNKO1lBQ0FEO1FBQ0o7UUFDQSxPQUFPQTtJQUNYO0lBQ0Esd0VBQXdFO0lBQ3hFLG1FQUFtRTtJQUNuRSxJQUFJTixXQUFXLFdBQVc7UUFDdEIsT0FBT0UsTUFBTU0sTUFBTSxHQUFHUCxTQUFTO0lBQ25DO0lBQ0Esa0JBQWtCO0lBQ2xCLE9BQU87QUFDWDtBQUNBLFNBQVNRLFlBQVlULE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUM1RCxzRkFBc0Y7SUFDdEYsSUFBSUosV0FBVyxZQUFZO1FBQ3ZCSCwwREFBY0EsQ0FBQyxPQUFRTyxpQkFBa0IsVUFBVSwwQ0FBMEMsZ0JBQWdCQTtRQUM3R0QsT0FBT08sSUFBSSxDQUFDTjtRQUNaLE9BQU87SUFDWDtJQUNBLGdEQUFnRDtJQUNoREQsT0FBT08sSUFBSSxDQUFDO0lBQ1osMkNBQTJDO0lBQzNDLE9BQU9MLFdBQVdMLFFBQVFDLFFBQVFDLE9BQU9DLFFBQVFDO0FBQ3JEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxNQUFNTyxpQkFBaUJDLE9BQU9DLE1BQU0sQ0FBQztJQUN4Q0MsT0FBT2Y7SUFDUGdCLFFBQVFWO0lBQ1JXLFNBQVNQO0FBQ2IsR0FBRztBQUNILG9GQUFvRjtBQUNwRixTQUFTUSxrQkFBa0JDLE1BQU0sRUFBRUMsT0FBTztJQUN0QyxJQUFJQSxXQUFXLE1BQU07UUFDakJBLFVBQVVSLGVBQWVHLEtBQUs7SUFDbEM7SUFDQSxNQUFNWixRQUFRTixrREFBUUEsQ0FBQ3NCLFFBQVE7SUFDL0IsTUFBTUUsU0FBUyxFQUFFO0lBQ2pCLElBQUlkLElBQUk7SUFDUiw0QkFBNEI7SUFDNUIsTUFBT0EsSUFBSUosTUFBTU0sTUFBTSxDQUFFO1FBQ3JCLE1BQU1hLElBQUluQixLQUFLLENBQUNJLElBQUk7UUFDcEIsWUFBWTtRQUNaLElBQUllLEtBQUssTUFBTSxHQUFHO1lBQ2RELE9BQU9WLElBQUksQ0FBQ1c7WUFDWjtRQUNKO1FBQ0EscURBQXFEO1FBQ3JELElBQUlDLGNBQWM7UUFDbEIsSUFBSUMsZUFBZTtRQUNuQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDRixJQUFJLElBQUcsTUFBTyxNQUFNO1lBQ3JCQyxjQUFjO1lBQ2RDLGVBQWU7UUFDZixnQ0FBZ0M7UUFDcEMsT0FDSyxJQUFJLENBQUNGLElBQUksSUFBRyxNQUFPLE1BQU07WUFDMUJDLGNBQWM7WUFDZEMsZUFBZTtRQUNmLDBDQUEwQztRQUM5QyxPQUNLLElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtZQUMxQkMsY0FBYztZQUNkQyxlQUFlO1FBQ25CLE9BQ0s7WUFDRCxJQUFJLENBQUNGLElBQUksSUFBRyxNQUFPLE1BQU07Z0JBQ3JCZixLQUFLYSxRQUFRLHVCQUF1QmIsSUFBSSxHQUFHSixPQUFPa0I7WUFDdEQsT0FDSztnQkFDRGQsS0FBS2EsUUFBUSxjQUFjYixJQUFJLEdBQUdKLE9BQU9rQjtZQUM3QztZQUNBO1FBQ0o7UUFDQSx1Q0FBdUM7UUFDdkMsSUFBSWQsSUFBSSxJQUFJZ0IsZUFBZXBCLE1BQU1NLE1BQU0sRUFBRTtZQUNyQ0YsS0FBS2EsUUFBUSxXQUFXYixJQUFJLEdBQUdKLE9BQU9rQjtZQUN0QztRQUNKO1FBQ0EseUNBQXlDO1FBQ3pDLElBQUlJLE1BQU1ILElBQUssQ0FBQyxLQUFNLElBQUlDLGNBQWMsQ0FBQyxJQUFLO1FBQzlDLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJSCxhQUFhRyxJQUFLO1lBQ2xDLElBQUlDLFdBQVd4QixLQUFLLENBQUNJLEVBQUU7WUFDdkIsNEJBQTRCO1lBQzVCLElBQUksQ0FBQ29CLFdBQVcsSUFBRyxLQUFNLE1BQU07Z0JBQzNCcEIsS0FBS2EsUUFBUSxvQkFBb0JiLEdBQUdKLE9BQU9rQjtnQkFDM0NJLE1BQU07Z0JBQ047WUFDSjs7WUFFQUEsTUFBTSxPQUFRLElBQU1FLFdBQVc7WUFDL0JwQjtRQUNKO1FBQ0EsK0NBQStDO1FBQy9DLElBQUlrQixRQUFRLE1BQU07WUFDZDtRQUNKO1FBQ0EscUJBQXFCO1FBQ3JCLElBQUlBLE1BQU0sVUFBVTtZQUNoQmxCLEtBQUthLFFBQVEsZ0JBQWdCYixJQUFJLElBQUlnQixhQUFhcEIsT0FBT2tCLFFBQVFJO1lBQ2pFO1FBQ0o7UUFDQSx1Q0FBdUM7UUFDdkMsSUFBSUEsT0FBTyxVQUFVQSxPQUFPLFFBQVE7WUFDaENsQixLQUFLYSxRQUFRLG1CQUFtQmIsSUFBSSxJQUFJZ0IsYUFBYXBCLE9BQU9rQixRQUFRSTtZQUNwRTtRQUNKO1FBQ0Esd0RBQXdEO1FBQ3hELElBQUlBLE9BQU9ELGNBQWM7WUFDckJqQixLQUFLYSxRQUFRLFlBQVliLElBQUksSUFBSWdCLGFBQWFwQixPQUFPa0IsUUFBUUk7WUFDN0Q7UUFDSjtRQUNBSixPQUFPVixJQUFJLENBQUNjO0lBQ2hCO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLHVGQUF1RjtBQUN2Rjs7OztDQUlDLEdBQ00sU0FBU08sWUFBWUMsR0FBRyxFQUFFQyxJQUFJO0lBQ2pDLElBQUlBLFFBQVEsTUFBTTtRQUNkL0IsMkRBQWVBLENBQUMrQjtRQUNoQkQsTUFBTUEsSUFBSUUsU0FBUyxDQUFDRDtJQUN4QjtJQUNBLElBQUlULFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSWQsSUFBSSxHQUFHQSxJQUFJc0IsSUFBSXBCLE1BQU0sRUFBRUYsSUFBSztRQUNqQyxNQUFNZSxJQUFJTyxJQUFJRyxVQUFVLENBQUN6QjtRQUN6QixJQUFJZSxJQUFJLE1BQU07WUFDVkQsT0FBT1YsSUFBSSxDQUFDVztRQUNoQixPQUNLLElBQUlBLElBQUksT0FBTztZQUNoQkQsT0FBT1YsSUFBSSxDQUFDLEtBQU0sSUFBSztZQUN2QlUsT0FBT1YsSUFBSSxDQUFDLElBQUssT0FBUTtRQUM3QixPQUNLLElBQUksQ0FBQ1csSUFBSSxNQUFLLEtBQU0sUUFBUTtZQUM3QmY7WUFDQSxNQUFNMEIsS0FBS0osSUFBSUcsVUFBVSxDQUFDekI7WUFDMUJULDBEQUFjQSxDQUFDUyxJQUFJc0IsSUFBSXBCLE1BQU0sSUFBSyxDQUFDd0IsS0FBSyxNQUFLLE1BQU8sUUFBUywwQkFBMEIsT0FBT0o7WUFDOUYsaUJBQWlCO1lBQ2pCLE1BQU1LLE9BQU8sVUFBVyxFQUFDWixJQUFJLE1BQUssS0FBTSxFQUFDLElBQU1XLENBQUFBLEtBQUssTUFBSztZQUN6RFosT0FBT1YsSUFBSSxDQUFDLFFBQVMsS0FBTTtZQUMzQlUsT0FBT1YsSUFBSSxDQUFDLFFBQVUsS0FBTSxPQUFRO1lBQ3BDVSxPQUFPVixJQUFJLENBQUMsUUFBVSxJQUFLLE9BQVE7WUFDbkNVLE9BQU9WLElBQUksQ0FBQyxPQUFRLE9BQVE7UUFDaEMsT0FDSztZQUNEVSxPQUFPVixJQUFJLENBQUMsS0FBTSxLQUFNO1lBQ3hCVSxPQUFPVixJQUFJLENBQUMsS0FBTyxJQUFLLE9BQVE7WUFDaENVLE9BQU9WLElBQUksQ0FBQyxJQUFLLE9BQVE7UUFDN0I7SUFDSjtJQUNBLE9BQU8sSUFBSXdCLFdBQVdkO0FBQzFCOztBQUVBLFNBQVM7QUFDVCxTQUFTZSxjQUFjQyxVQUFVO0lBQzdCLE9BQU9BLFdBQVdDLEdBQUcsQ0FBQyxDQUFDQztRQUNuQixJQUFJQSxhQUFhLFFBQVE7WUFDckIsT0FBT0MsT0FBT0MsWUFBWSxDQUFDRjtRQUMvQjtRQUNBQSxhQUFhO1FBQ2IsT0FBT0MsT0FBT0MsWUFBWSxDQUFFLENBQUMsYUFBYyxLQUFNLEtBQUksSUFBSyxRQUFVLENBQUNGLFlBQVksS0FBSSxJQUFLO0lBQzlGLEdBQUdHLElBQUksQ0FBQztBQUNaO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU0MsYUFBYXhDLEtBQUssRUFBRWlCLE9BQU87SUFDdkMsT0FBT2dCLGNBQWNsQixrQkFBa0JmLE9BQU9pQjtBQUNsRDtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTd0IsaUJBQWlCZixHQUFHLEVBQUVDLElBQUk7SUFDdEMsT0FBT1osa0JBQWtCVSxZQUFZQyxLQUFLQztBQUM5QyxFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcz80Njc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBhc3NlcnROb3JtYWxpemUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0Tm9ybWFsaXplKGZvcm0pO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBjb2RlLXBvaW50cyBmb3IgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnROb3JtYWxpemUiLCJlcnJvckZ1bmMiLCJyZWFzb24iLCJvZmZzZXQiLCJieXRlcyIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJpIiwibyIsImxlbmd0aCIsInJlcGxhY2VGdW5jIiwicHVzaCIsIlV0ZjhFcnJvckZ1bmNzIiwiT2JqZWN0IiwiZnJlZXplIiwiZXJyb3IiLCJpZ25vcmUiLCJyZXBsYWNlIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJfYnl0ZXMiLCJvbkVycm9yIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwidG9VdGY4Qnl0ZXMiLCJzdHIiLCJmb3JtIiwibm9ybWFsaXplIiwiY2hhckNvZGVBdCIsImMyIiwicGFpciIsIlVpbnQ4QXJyYXkiLCJfdG9VdGY4U3RyaW5nIiwiY29kZVBvaW50cyIsIm1hcCIsImNvZGVQb2ludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhDb2RlUG9pbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/utils/uuid.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/utils/uuid.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuidV4: () => (/* binding */ uuidV4)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Explain UUID and link to RFC here.\n *\n *  @_subsection: api/utils:UUID  [about-uuid]\n */ \n/**\n *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.\n *\n *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n */ function uuidV4(randomBytes) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(randomBytes, \"randomBytes\");\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = bytes[6] & 0x0f | 0x40;\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    const value = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    return [\n        value.substring(2, 10),\n        value.substring(10, 14),\n        value.substring(14, 18),\n        value.substring(18, 22),\n        value.substring(22, 34)\n    ].join(\"-\");\n} //# sourceMappingURL=uuid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OztDQUlDLEdBQzZDO0FBQzlDOzs7O0NBSUMsR0FDTSxTQUFTRSxPQUFPQyxXQUFXO0lBQzlCLE1BQU1DLFFBQVFKLGtEQUFRQSxDQUFDRyxhQUFhO0lBQ3BDLGtCQUFrQjtJQUNsQix3Q0FBd0M7SUFDeENDLEtBQUssQ0FBQyxFQUFFLEdBQUcsS0FBTSxDQUFDLEVBQUUsR0FBRyxPQUFRO0lBQy9CLGNBQWM7SUFDZCx1Q0FBdUM7SUFDdkMsdUNBQXVDO0lBQ3ZDQSxLQUFLLENBQUMsRUFBRSxHQUFHLEtBQU0sQ0FBQyxFQUFFLEdBQUcsT0FBUTtJQUMvQixNQUFNQyxRQUFRSixpREFBT0EsQ0FBQ0c7SUFDdEIsT0FBTztRQUNIQyxNQUFNQyxTQUFTLENBQUMsR0FBRztRQUNuQkQsTUFBTUMsU0FBUyxDQUFDLElBQUk7UUFDcEJELE1BQU1DLFNBQVMsQ0FBQyxJQUFJO1FBQ3BCRCxNQUFNQyxTQUFTLENBQUMsSUFBSTtRQUNwQkQsTUFBTUMsU0FBUyxDQUFDLElBQUk7S0FDdkIsQ0FBQ0MsSUFBSSxDQUFDO0FBQ1gsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V1aWQuanM/NmZkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFeHBsYWluIFVVSUQgYW5kIGxpbmsgdG8gUkZDIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOlVVSUQgIFthYm91dC11dWlkXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIHZlcnNpb24gNCBbW2xpbmstdXVpZF1dIGZvciB0aGUgJSVyYW5kb21CeXRlcyUlLlxuICpcbiAqICBAc2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcbiAgICAvLyBTZWN0aW9uOiA0LjEuMzpcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuICAgIF0uam9pbihcIi1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlcyIsImhleGxpZnkiLCJ1dWlkVjQiLCJyYW5kb21CeXRlcyIsImJ5dGVzIiwidmFsdWUiLCJzdWJzdHJpbmciLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/utils/uuid.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/base-wallet.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/base-wallet.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWallet: () => (/* binding */ BaseWallet)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n\n\n\n\n\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */ class BaseWallet extends _providers_index_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    #signingKey;\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */ constructor(privateKey, provider){\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n        this.#signingKey = privateKey;\n        const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.computeAddress)(this.signingKey.publicKey);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            address\n        });\n    }\n    // Store private values behind getters to reduce visibility\n    // in console.log\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */ get signingKey() {\n        return this.#signingKey;\n    }\n    /**\n     *  The private key for this wallet.\n     */ get privateKey() {\n        return this.signingKey.privateKey;\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n    async signTransaction(tx) {\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n            to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.to, this.provider) : undefined,\n            from: tx.from ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, this.provider) : undefined\n        });\n        if (to != null) {\n            tx.to = to;\n        }\n        if (from != null) {\n            tx.from = from;\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_5__.getAddress)(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n        // Build the transaction\n        const btx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_6__.Transaction.from(tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n        return btx.serialized;\n    }\n    async signMessage(message) {\n        return this.signMessageSync(message);\n    }\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */ signMessageSync(message) {\n        return this.signingKey.sign((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.hashMessage)(message)).serialized;\n    }\n    async signTypedData(domain, types, value) {\n        // Populate any ENS names\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_8__.TypedDataEncoder.resolveNames(domain, types, value, async (name)=>{\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: {\n                    name\n                }\n            });\n            const address = await this.provider.resolveName(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n            return address;\n        });\n        return this.signingKey.sign(_hash_index_js__WEBPACK_IMPORTED_MODULE_8__.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n} //# sourceMappingURL=base-wallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9iYXNlLXdhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ0E7QUFDVjtBQUNlO0FBQzBCO0FBQ2hHOzs7Ozs7Ozs7O0NBVUMsR0FDTSxNQUFNVyxtQkFBbUJQLCtEQUFjQTtJQUsxQyxDQUFDUSxVQUFVLENBQUM7SUFDWjs7Ozs7O0tBTUMsR0FDREMsWUFBWUMsVUFBVSxFQUFFQyxRQUFRLENBQUU7UUFDOUIsS0FBSyxDQUFDQTtRQUNOTCwrREFBY0EsQ0FBQ0ksY0FBYyxPQUFRQSxXQUFXRSxJQUFJLEtBQU0sWUFBWSx1QkFBdUIsY0FBYztRQUMzRyxJQUFJLENBQUMsQ0FBQ0osVUFBVSxHQUFHRTtRQUNuQixNQUFNRyxVQUFVWixxRUFBY0EsQ0FBQyxJQUFJLENBQUNPLFVBQVUsQ0FBQ00sU0FBUztRQUN4RFgsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFVTtRQUFRO0lBQ3JDO0lBQ0EsMkRBQTJEO0lBQzNELGlCQUFpQjtJQUNqQjs7S0FFQyxHQUNELElBQUlMLGFBQWE7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxVQUFVO0lBQUU7SUFDNUM7O0tBRUMsR0FDRCxJQUFJRSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUNGLFVBQVUsQ0FBQ0UsVUFBVTtJQUFFO0lBQ3RELE1BQU1kLGFBQWE7UUFBRSxPQUFPLElBQUksQ0FBQ2lCLE9BQU87SUFBRTtJQUMxQ0UsUUFBUUosUUFBUSxFQUFFO1FBQ2QsT0FBTyxJQUFJSixXQUFXLElBQUksQ0FBQyxDQUFDQyxVQUFVLEVBQUVHO0lBQzVDO0lBQ0EsTUFBTUssZ0JBQWdCQyxFQUFFLEVBQUU7UUFDdEIsc0RBQXNEO1FBQ3RELE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNZixrRUFBaUJBLENBQUM7WUFDekNjLElBQUtELEdBQUdDLEVBQUUsR0FBR3JCLGlFQUFjQSxDQUFDb0IsR0FBR0MsRUFBRSxFQUFFLElBQUksQ0FBQ1AsUUFBUSxJQUFJUztZQUNwREQsTUFBT0YsR0FBR0UsSUFBSSxHQUFHdEIsaUVBQWNBLENBQUNvQixHQUFHRSxJQUFJLEVBQUUsSUFBSSxDQUFDUixRQUFRLElBQUlTO1FBQzlEO1FBQ0EsSUFBSUYsTUFBTSxNQUFNO1lBQ1pELEdBQUdDLEVBQUUsR0FBR0E7UUFDWjtRQUNBLElBQUlDLFFBQVEsTUFBTTtZQUNkRixHQUFHRSxJQUFJLEdBQUdBO1FBQ2Q7UUFDQSxJQUFJRixHQUFHRSxJQUFJLElBQUksTUFBTTtZQUNqQmIsK0RBQWNBLENBQUNWLDZEQUFVQSxDQUFFcUIsR0FBR0UsSUFBSSxNQUFPLElBQUksQ0FBQ04sT0FBTyxFQUFFLHFDQUFxQyxXQUFXSSxHQUFHRSxJQUFJO1lBQzlHLE9BQU9GLEdBQUdFLElBQUk7UUFDbEI7UUFDQSx3QkFBd0I7UUFDeEIsTUFBTUUsTUFBTW5CLDhEQUFXQSxDQUFDaUIsSUFBSSxDQUFDRjtRQUM3QkksSUFBSUMsU0FBUyxHQUFHLElBQUksQ0FBQ2QsVUFBVSxDQUFDSSxJQUFJLENBQUNTLElBQUlFLFlBQVk7UUFDckQsT0FBT0YsSUFBSUcsVUFBVTtJQUN6QjtJQUNBLE1BQU1DLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtJQUNoQztJQUNBLGtFQUFrRTtJQUNsRSw0QkFBNEI7SUFDNUI7O0tBRUMsR0FDREMsZ0JBQWdCRCxPQUFPLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUNsQixVQUFVLENBQUNJLElBQUksQ0FBQ2QsMkRBQVdBLENBQUM0QixVQUFVRixVQUFVO0lBQ2hFO0lBQ0EsTUFBTUksY0FBY0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUN0Qyx5QkFBeUI7UUFDekIsTUFBTUMsWUFBWSxNQUFNakMsNERBQWdCQSxDQUFDa0MsWUFBWSxDQUFDSixRQUFRQyxPQUFPQyxPQUFPLE9BQU9HO1lBQy9FLHNEQUFzRDtZQUN0RCx5QkFBeUI7WUFDekI3Qix1REFBTUEsQ0FBQyxJQUFJLENBQUNNLFFBQVEsSUFBSSxNQUFNLCtDQUErQyx5QkFBeUI7Z0JBQ2xHd0IsV0FBVztnQkFDWEMsTUFBTTtvQkFBRUY7Z0JBQUs7WUFDakI7WUFDQSxNQUFNckIsVUFBVSxNQUFNLElBQUksQ0FBQ0YsUUFBUSxDQUFDMEIsV0FBVyxDQUFDSDtZQUNoRDdCLHVEQUFNQSxDQUFDUSxXQUFXLE1BQU0seUJBQXlCLHFCQUFxQjtnQkFDbEVrQixPQUFPRztZQUNYO1lBQ0EsT0FBT3JCO1FBQ1g7UUFDQSxPQUFPLElBQUksQ0FBQ0wsVUFBVSxDQUFDSSxJQUFJLENBQUNiLDREQUFnQkEsQ0FBQ3VDLElBQUksQ0FBQ04sVUFBVUgsTUFBTSxFQUFFQyxPQUFPRSxVQUFVRCxLQUFLLEdBQUdQLFVBQVU7SUFDM0c7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2Jhc2Utd2FsbGV0LmpzPzgzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaGFzaE1lc3NhZ2UsIFR5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcywgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBUaGUgKipCYXNlV2FsbGV0KiogaXMgYSBzdHJlYW0tbGluZWQgaW1wbGVtZW50YXRpb24gb2YgYVxuICogIFtbU2lnbmVyXV0gdGhhdCBvcGVyYXRlcyB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFtbV2FsbGV0XV0gY2xhc3MsIGFzIGl0IG9mZmVyc1xuICogIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBhbmQgc2ltcGxpZmllcyBsb2FkaW5nIGEgdmFyaWV0eVxuICogIG9mIEpTT04gZm9ybWF0cywgTW5lbW9uaWMgUGhyYXNlcywgZXRjLlxuICpcbiAqICBUaGlzIGNsYXNzIG1heSBiZSBvZiB1c2UgZm9yIHRob3NlIGF0dGVtcHRpbmcgdG8gaW1wbGVtZW50XG4gKiAgYSBtaW5pbWFsIFNpZ25lci5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VXYWxsZXQgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgICNzaWduaW5nS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEJhc2VXYWxsZXQgZm9yICUlcHJpdmF0ZUtleSUlLCBvcHRpb25hbGx5XG4gICAgICogIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm92aWRlciUlIGlzIG5vdCBzcGVjaWZpZWQsIG9ubHkgb2ZmbGluZSBtZXRob2RzIGNhblxuICAgICAqICBiZSB1c2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpdmF0ZUtleSAmJiB0eXBlb2YgKHByaXZhdGVLZXkuc2lnbikgPT09IFwiZnVuY3Rpb25cIiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgdGhpcy4jc2lnbmluZ0tleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyh0aGlzLnNpZ25pbmdLZXkucHVibGljS2V5KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHByaXZhdGUgdmFsdWVzIGJlaGluZCBnZXR0ZXJzIHRvIHJlZHVjZSB2aXNpYmlsaXR5XG4gICAgLy8gaW4gY29uc29sZS5sb2dcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbU2lnbmluZ0tleV1dIHVzZWQgZm9yIHNpZ25pbmcgcGF5bG9hZHMuXG4gICAgICovXG4gICAgZ2V0IHNpZ25pbmdLZXkoKSB7IHJldHVybiB0aGlzLiNzaWduaW5nS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleSBmb3IgdGhpcyB3YWxsZXQuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLnNpZ25pbmdLZXkucHJpdmF0ZUtleTsgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVdhbGxldCh0aGlzLiNzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICAvLyBSZXBsYWNlIGFueSBBZGRyZXNzYWJsZSBvciBFTlMgbmFtZSB3aXRoIGFuIGFkZHJlc3NcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdG86ICh0eC50byA/IHJlc29sdmVBZGRyZXNzKHR4LnRvLCB0aGlzLnByb3ZpZGVyKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICBmcm9tOiAodHguZnJvbSA/IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpIDogdW5kZWZpbmVkKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LnRvID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZ2V0QWRkcmVzcygodHguZnJvbSkpID09PSB0aGlzLmFkZHJlc3MsIFwidHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCB0eC5mcm9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0eC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBidHggPSBUcmFuc2FjdGlvbi5mcm9tKHR4KTtcbiAgICAgICAgYnR4LnNpZ25hdHVyZSA9IHRoaXMuc2lnbmluZ0tleS5zaWduKGJ0eC51bnNpZ25lZEhhc2gpO1xuICAgICAgICByZXR1cm4gYnR4LnNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWRkIGEgc2VjaWFsaXplZCBzaWduVHggYW5kIHNpZ25UeXBlZCBzeW5jIHRoYXQgZW5mb3JjZXNcbiAgICAvLyBhbGwgcGFyYW1ldGVycyBhcmUga25vd24/XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNpZ25hdHVyZSBmb3IgJSVtZXNzYWdlJSUgc2lnbmVkIHdpdGggdGhpcyB3YWxsZXQuXG4gICAgICovXG4gICAgc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKGhhc2hNZXNzYWdlKG1lc3NhZ2UpKS5zZXJpYWxpemVkO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXNcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jIChuYW1lKSA9PiB7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGhpcyBzaG91bGQgdXNlIHJlc29sdmVOYW1lOyBhZGRyZXNzZXMgZG9uJ3RcbiAgICAgICAgICAgIC8vICAgICAgICBuZWVkIGEgcHJvdmlkZXJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLnByb3ZpZGVyICE9IG51bGwsIFwiY2Fubm90IHJlc29sdmUgRU5TIG5hbWVzIHdpdGhvdXQgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBuYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQoYWRkcmVzcyAhPSBudWxsLCBcInVuY29uZmlndXJlZCBFTlMgbmFtZVwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25pbmdLZXkuc2lnbihUeXBlZERhdGFFbmNvZGVyLmhhc2gocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpLnNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS13YWxsZXQuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsImhhc2hNZXNzYWdlIiwiVHlwZWREYXRhRW5jb2RlciIsIkFic3RyYWN0U2lnbmVyIiwiY29tcHV0ZUFkZHJlc3MiLCJUcmFuc2FjdGlvbiIsImRlZmluZVByb3BlcnRpZXMiLCJyZXNvbHZlUHJvcGVydGllcyIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQmFzZVdhbGxldCIsInNpZ25pbmdLZXkiLCJjb25zdHJ1Y3RvciIsInByaXZhdGVLZXkiLCJwcm92aWRlciIsInNpZ24iLCJhZGRyZXNzIiwicHVibGljS2V5IiwiY29ubmVjdCIsInNpZ25UcmFuc2FjdGlvbiIsInR4IiwidG8iLCJmcm9tIiwidW5kZWZpbmVkIiwiYnR4Iiwic2lnbmF0dXJlIiwidW5zaWduZWRIYXNoIiwic2VyaWFsaXplZCIsInNpZ25NZXNzYWdlIiwibWVzc2FnZSIsInNpZ25NZXNzYWdlU3luYyIsInNpZ25UeXBlZERhdGEiLCJkb21haW4iLCJ0eXBlcyIsInZhbHVlIiwicG9wdWxhdGVkIiwicmVzb2x2ZU5hbWVzIiwibmFtZSIsIm9wZXJhdGlvbiIsImluZm8iLCJyZXNvbHZlTmFtZSIsImhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/base-wallet.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/hdwallet.js":
/*!************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/hdwallet.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HDNodeVoidWallet: () => (/* binding */ HDNodeVoidWallet),\n/* harmony export */   HDNodeWallet: () => (/* binding */ HDNodeWallet),\n/* harmony export */   defaultPath: () => (/* binding */ defaultPath),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getIndexedAccountPath: () => (/* binding */ getIndexedAccountPath)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/hmac.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/ripemd160.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/random.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../providers/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base-wallet.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./mnemonic.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./json-keystore.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */ \n\n\n\n\n\n\n\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */ const defaultPath = \"m/44'/60'/0'/0/0\";\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([\n    66,\n    105,\n    116,\n    99,\n    111,\n    105,\n    110,\n    32,\n    115,\n    101,\n    101,\n    100\n]);\nconst HardenedBit = 0x80000000;\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value, length) {\n    let result = \"\";\n    while(value){\n        result = Nibbles[value % 16] + result;\n        value = Math.trunc(value / 16);\n    }\n    while(result.length < length * 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction encodeBase58Check(_value) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_value);\n    const check = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(value)), 0, 4);\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        value,\n        check\n    ]);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.encodeBase58)(bytes);\n}\nconst _guard = {};\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n    const data = new Uint8Array(37);\n    if (index & HardenedBit) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"deriveChild\"\n        });\n        // Data = 0x00 || ser_256(k_par)\n        data.set((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(privateKey), 1);\n    } else {\n        // Data = ser_p(point(k_par))\n        data.set((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(publicKey));\n    }\n    // Data += ser_32(i)\n    for(let i = 24; i >= 0; i -= 8){\n        data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n    }\n    const I = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.computeHmac)(\"sha512\", chainCode, data));\n    return {\n        IL: I.slice(0, 32),\n        IR: I.slice(32)\n    };\n}\nfunction derivePath(node, path) {\n    const components = path.split(\"/\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(components.length > 0 && (components[0] === \"m\" || node.depth > 0), \"invalid path\", \"path\", path);\n    if (components[0] === \"m\") {\n        components.shift();\n    }\n    let result = node;\n    for(let i = 0; i < components.length; i++){\n        const component = components[i];\n        if (component.match(/^[0-9]+'$/)) {\n            const index = parseInt(component.substring(0, component.length - 1));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(HardenedBit + index);\n        } else if (component.match(/^[0-9]+$/)) {\n            const index = parseInt(component);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(index);\n        } else {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid path component\", `path[${i}]`, component);\n        }\n    }\n    return result;\n}\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */ class HDNodeWallet extends _base_wallet_js__WEBPACK_IMPORTED_MODULE_5__.BaseWallet {\n    /**\n     *  @private\n     */ constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider){\n        super(signingKey, provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertPrivate)(guard, _guard, \"HDNodeWallet\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            publicKey: signingKey.compressedPublicKey\n        });\n        const fingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.ripemd160)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(this.publicKey)), 0, 4);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            parentFingerprint,\n            fingerprint,\n            chainCode,\n            path,\n            index,\n            depth\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            mnemonic\n        });\n    }\n    connect(provider) {\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n    #account() {\n        const account = {\n            address: this.address,\n            privateKey: this.privateKey\n        };\n        const m = this.mnemonic;\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n            account.mnemonic = {\n                path: this.path,\n                locale: \"en\",\n                entropy: m.entropy\n            };\n        }\n        return account;\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */ async encrypt(password, progressCallback) {\n        return await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_8__.encryptKeystoreJson)(this.#account(), password, {\n            progressCallback\n        });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */ encryptSync(password) {\n        return (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_8__.encryptKeystoreJsonSync)(this.#account(), password);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */ get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"extendedKey\"\n        });\n        return encodeBase58Check((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x0488ADE4\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                \"0x00\",\n                this.privateKey\n            ])\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */ hasPath() {\n        return this.path != null;\n    }\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */ neuter() {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n    }\n    /**\n     *  Return the child for %%index%%.\n     */ deriveChild(_index) {\n        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(_index, \"index\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n        const ki = new _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__.SigningKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));\n        return new HDNodeWallet(_guard, ki, this.fingerprint, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n    }\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */ derivePath(path) {\n        return derivePath(this, path);\n    }\n    static #fromSeed(_seed, mnemonic) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const seed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_seed, \"seed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const I = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.computeHmac)(\"sha512\", MasterSecret, seed));\n        const signingKey = new _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__.SigningKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(I.slice(0, 32)));\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n    }\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */ static fromExtendedKey(extendedKey) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeArray)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.decodeBase58)(extendedKey)); // @TODO: redact\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n        const depth = bytes[4];\n        const parentFingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(5, 9));\n        const index = parseInt((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n        switch((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4))){\n            // Public Key\n            case \"0x0488b21e\":\n            case \"0x043587cf\":\n                {\n                    const publicKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(key);\n                    return new HDNodeVoidWallet(_guard, (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_11__.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n                }\n            // Private Key\n            case \"0x0488ade4\":\n            case \"0x04358394 \":\n                if (key[0] !== 0) {\n                    break;\n                }\n                return new HDNodeWallet(_guard, new _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n    /**\n     *  Creates a new random HDNode.\n     */ static createRandom(password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_12__.LangEn.wordlist();\n        }\n        const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_13__.Mnemonic.fromEntropy((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_14__.randomBytes)(16), password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */ static fromMnemonic(mnemonic, path) {\n        if (!path) {\n            path = defaultPath;\n        }\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */ static fromPhrase(phrase, password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_12__.LangEn.wordlist();\n        }\n        const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_13__.Mnemonic.fromPhrase(phrase, password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */ static fromSeed(seed) {\n        return HDNodeWallet.#fromSeed(seed, null);\n    }\n}\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */ class HDNodeVoidWallet extends _providers_index_js__WEBPACK_IMPORTED_MODULE_15__.VoidSigner {\n    /**\n     *  @private\n     */ constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider){\n        super(address, provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertPrivate)(guard, _guard, \"HDNodeVoidWallet\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            publicKey\n        });\n        const fingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.ripemd160)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(publicKey)), 0, 4);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            publicKey,\n            fingerprint,\n            parentFingerprint,\n            chainCode,\n            path,\n            index,\n            depth\n        });\n    }\n    connect(provider) {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */ get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"extendedKey\"\n        });\n        return encodeBase58Check((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x0488B21E\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            this.publicKey\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */ hasPath() {\n        return this.path != null;\n    }\n    /**\n     *  Return the child for %%index%%.\n     */ deriveChild(_index) {\n        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(_index, \"index\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\n        const Ki = _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__.SigningKey.addPoints(IL, this.publicKey, true);\n        const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_11__.computeAddress)(Ki);\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(IR), path, index, this.depth + 1, this.provider);\n    }\n    /**\n     *  Return the signer for %%path%% from this node.\n     */ derivePath(path) {\n        return derivePath(this, path);\n    }\n}\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/ /**\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */ function getAccountPath(_index) {\n    const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(_index, \"index\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${index}'/0/0`;\n}\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */ function getIndexedAccountPath(_index) {\n    const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(_index, \"index\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${index}`;\n} //# sourceMappingURL=hdwallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9oZHdhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQzRGO0FBQzFDO0FBQ007QUFDMko7QUFDbks7QUFDSDtBQUNMO0FBQzBDO0FBQ25GOztDQUVDLEdBQ00sTUFBTTJCLGNBQWMsbUJBQW1CO0FBQzlDLGlCQUFpQjtBQUNqQixNQUFNQyxlQUFlLElBQUlDLFdBQVc7SUFBQztJQUFJO0lBQUs7SUFBSztJQUFJO0lBQUs7SUFBSztJQUFLO0lBQUk7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUM3RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLElBQUlDLE9BQU87QUFDakIsTUFBTUMsVUFBVTtBQUNoQixTQUFTQyxLQUFLQyxLQUFLLEVBQUVDLE1BQU07SUFDdkIsSUFBSUMsU0FBUztJQUNiLE1BQU9GLE1BQU87UUFDVkUsU0FBU0osT0FBTyxDQUFDRSxRQUFRLEdBQUcsR0FBR0U7UUFDL0JGLFFBQVFHLEtBQUtDLEtBQUssQ0FBQ0osUUFBUTtJQUMvQjtJQUNBLE1BQU9FLE9BQU9ELE1BQU0sR0FBR0EsU0FBUyxFQUFHO1FBQy9CQyxTQUFTLE1BQU1BO0lBQ25CO0lBQ0EsT0FBTyxPQUFPQTtBQUNsQjtBQUNBLFNBQVNHLGtCQUFrQkMsTUFBTTtJQUM3QixNQUFNTixRQUFRdkIseURBQVFBLENBQUM2QjtJQUN2QixNQUFNQyxRQUFRbEMsMERBQVNBLENBQUNKLHdEQUFNQSxDQUFDQSx3REFBTUEsQ0FBQytCLFNBQVMsR0FBRztJQUNsRCxNQUFNUSxRQUFRcEMsdURBQU1BLENBQUM7UUFBQzRCO1FBQU9PO0tBQU07SUFDbkMsT0FBTy9CLDZEQUFZQSxDQUFDZ0M7QUFDeEI7QUFDQSxNQUFNQyxTQUFTLENBQUM7QUFDaEIsU0FBU0MsTUFBTUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsVUFBVTtJQUNsRCxNQUFN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QUFPRixXQUFXLElBQUksRUFBRUU7SUFDNUI7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxHQUNBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTaUQsZUFBZWYsTUFBTTtJQUNqQyxNQUFNaEQsUUFBUS9CLDBEQUFTQSxDQUFDK0UsUUFBUTtJQUNoQ3pFLCtEQUFjQSxDQUFDeUIsU0FBUyxLQUFLQSxRQUFRaEIsYUFBYSx5QkFBeUIsU0FBU2dCO0lBQ3BGLE9BQU8sQ0FBQyxVQUFVLEVBQUVBLE1BQU0sS0FBSyxDQUFDO0FBQ3BDO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTZ0Usc0JBQXNCaEIsTUFBTTtJQUN4QyxNQUFNaEQsUUFBUS9CLDBEQUFTQSxDQUFDK0UsUUFBUTtJQUNoQ3pFLCtEQUFjQSxDQUFDeUIsU0FBUyxLQUFLQSxRQUFRaEIsYUFBYSx5QkFBeUIsU0FBU2dCO0lBQ3BGLE9BQU8sQ0FBQyxlQUFlLEVBQUVBLE1BQU0sQ0FBQztBQUNwQyxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2hkd2FsbGV0LmpzPzBmZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXhwbGFpbiBIRCBXYWxsZXRzLi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkhEIFdhbGxldHMgIFtoZC13YWxsZXRzXVxuICovXG5pbXBvcnQgeyBjb21wdXRlSG1hYywgcmFuZG9tQnl0ZXMsIHJpcGVtZDE2MCwgU2lnbmluZ0tleSwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVm9pZFNpZ25lciB9IGZyb20gXCIuLi9wcm92aWRlcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZGVjb2RlQmFzZTU4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSwgZ2V0TnVtYmVyLCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b0JlSGV4LCBhc3NlcnRQcml2YXRlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcbmltcG9ydCB7IEJhc2VXYWxsZXQgfSBmcm9tIFwiLi9iYXNlLXdhbGxldC5qc1wiO1xuaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tIFwiLi9tbmVtb25pYy5qc1wiO1xuaW1wb3J0IHsgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xuLyoqXG4gKiAgVGhlIGRlZmF1bHQgZGVyaXZhdGlvbiBwYXRoIGZvciBFdGhlcmV1bSBIRCBOb2Rlcy4gKGkuZS4gYGBcIm0vNDQnLzYwJy8wJy8wLzBcImBgKVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcbi8vIFwiQml0Y29pbiBzZWVkXCJcbmNvbnN0IE1hc3RlclNlY3JldCA9IG5ldyBVaW50OEFycmF5KFs2NiwgMTA1LCAxMTYsIDk5LCAxMTEsIDEwNSwgMTEwLCAzMiwgMTE1LCAxMDEsIDEwMSwgMTAwXSk7XG5jb25zdCBIYXJkZW5lZEJpdCA9IDB4ODAwMDAwMDA7XG5jb25zdCBOID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIpO1xuY29uc3QgTmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IE5pYmJsZXNbdmFsdWUgJSAxNl0gKyByZXN1bHQ7XG4gICAgICAgIHZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSAvIDE2KTtcbiAgICB9XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGggKiAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gZW5jb2RlQmFzZTU4Q2hlY2soX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCeXRlcyhfdmFsdWUpO1xuICAgIGNvbnN0IGNoZWNrID0gZGF0YVNsaWNlKHNoYTI1NihzaGEyNTYodmFsdWUpKSwgMCwgNCk7XG4gICAgY29uc3QgYnl0ZXMgPSBjb25jYXQoW3ZhbHVlLCBjaGVja10pO1xuICAgIHJldHVybiBlbmNvZGVCYXNlNTgoYnl0ZXMpO1xufVxuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiBzZXJfSShpbmRleCwgY2hhaW5Db2RlLCBwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoMzcpO1xuICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgIGFzc2VydChwcml2YXRlS2V5ICE9IG51bGwsIFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZXJpdmVDaGlsZFwiXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwcml2YXRlS2V5KSwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwdWJsaWNLZXkpKTtcbiAgICB9XG4gICAgLy8gRGF0YSArPSBzZXJfMzIoaSlcbiAgICBmb3IgKGxldCBpID0gMjQ7IGkgPj0gMDsgaSAtPSA4KSB7XG4gICAgICAgIGRhdGFbMzMgKyAoaSA+PiAzKV0gPSAoKGluZGV4ID4+ICgyNCAtIGkpKSAmIDB4ZmYpO1xuICAgIH1cbiAgICBjb25zdCBJID0gZ2V0Qnl0ZXMoY29tcHV0ZUhtYWMoXCJzaGE1MTJcIiwgY2hhaW5Db2RlLCBkYXRhKSk7XG4gICAgcmV0dXJuIHsgSUw6IEkuc2xpY2UoMCwgMzIpLCBJUjogSS5zbGljZSgzMikgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZVBhdGgobm9kZSwgcGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wb25lbnRzLmxlbmd0aCA+IDAgJiYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiIHx8IG5vZGUuZGVwdGggPiAwKSwgXCJpbnZhbGlkIHBhdGhcIiwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIGlmIChjb21wb25lbnRzWzBdID09PSBcIm1cIikge1xuICAgICAgICBjb21wb25lbnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBub2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZGVyaXZlQ2hpbGQoSGFyZGVuZWRCaXQgKyBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZGVyaXZlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEFuICoqSEROb2RlV2FsbGV0KiogaXMgYSBbW1NpZ25lcl1dIGJhY2tlZCBieSB0aGUgcHJpdmF0ZSBrZXkgZGVyaXZlZFxuICogIGZyb20gYW4gSEQgTm9kZSB1c2luZyB0aGUgW1tsaW5rLWJpcC0zMl1dIHN0YW50YXJkLlxuICpcbiAqICBBbiBIRCBOb2RlIGZvcm1zIGEgaGllcmFyY2hhbCBzdHJ1Y3R1cmUgd2l0aCBlYWNoIEhEIE5vZGUgaGF2aW5nIGFcbiAqICBwcml2YXRlIGtleSBhbmQgdGhlIGFiaWxpdHkgdG8gZGVyaXZlIGNoaWxkIEhEIE5vZGVzLCBkZWZpbmVkIGJ5XG4gKiAgYSBwYXRoIGluZGljYXRpbmcgdGhlIGluZGV4IG9mIGVhY2ggY2hpbGQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIRE5vZGVXYWxsZXQgZXh0ZW5kcyBCYXNlV2FsbGV0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKi9cbiAgICBwdWJsaWNLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaW5nZXJwcmludC5cbiAgICAgKlxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXG4gICAgICogIGJ1dCBkZXZlbG9wZXJzIHNob3VsZCBiZSBwcmVwYXJlZCB0byBkZWFsIHdpdGggY29sbGlzaW9ucyBhcyBpdFxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXG4gICAgICovXG4gICAgZmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJlbnQgZmluZ2VycHJpbnQuXG4gICAgICovXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyB1c2VkIHRvIGNyZWF0ZSB0aGlzIEhEIE5vZGUsIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqICBTb3VyY2VzIHN1Y2ggYXMgZXh0ZW5kZWQga2V5cyBkbyBub3QgZW5jb2RlIHRoZSBtbmVtb25pYywgaW5cbiAgICAgKiAgd2hpY2ggY2FzZSB0aGlzIHdpbGwgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgbW5lbW9uaWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjaGFpbkNvZGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXJpdmF0aW9uIHBhdGggb2YgdGhpcyB3YWxsZXQuXG4gICAgICpcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZXIgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVub2NkZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBzaWduaW5nS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIG1uZW1vbmljLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJIRE5vZGVXYWxsZXRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwdWJsaWNLZXk6IHNpZ25pbmdLZXkuY29tcHJlc3NlZFB1YmxpY0tleSB9KTtcbiAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBkYXRhU2xpY2UocmlwZW1kMTYwKHNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLCAwLCA0KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCwgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG1uZW1vbmljIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwgdGhpcy5zaWduaW5nS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLm1uZW1vbmljLCBwcm92aWRlcik7XG4gICAgfVxuICAgICNhY2NvdW50KCkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICBjb25zdCBtID0gdGhpcy5tbmVtb25pYztcbiAgICAgICAgaWYgKHRoaXMucGF0aCAmJiBtICYmIG0ud29yZGxpc3QubG9jYWxlID09PSBcImVuXCIgJiYgbS5wYXNzd29yZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBcImVuXCIsXG4gICAgICAgICAgICAgICAgZW50cm9weTogbS5lbnRyb3B5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwdGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3NDYWxsYmFjayUlIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZWNlaXZlIHBlcmlvZGljXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXG4gICAgICovXG4gICAgYXN5bmMgZW5jcnlwdChwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW5jcnlwdEtleXN0b3JlSnNvbih0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyh0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBleHRlbmRlZCBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHJpdmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIEhEIE5vZGUgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgwNDg4QURFNFwiLCB6cGFkKHRoaXMuZGVwdGgsIDEpLCB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSwgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICBjb25jYXQoW1wiMHgwMFwiLCB0aGlzLnByaXZhdGVLZXldKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB3YWxsZXQgaGFzIGEgcGF0aCwgcHJvdmlkaW5nIGEgVHlwZSBHdWFyZFxuICAgICAqICB0aGF0IHRoZSBwYXRoIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGhhc1BhdGgoKSB7IHJldHVybiAodGhpcy5wYXRoICE9IG51bGwpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXV0ZXJlZCBIRCBOb2RlLCB3aGljaCByZW1vdmVzIHRoZSBwcml2YXRlIGRldGFpbHNcbiAgICAgKiAgb2YgYW4gSEQgTm9kZS5cbiAgICAgKlxuICAgICAqICBBIG5ldXRlcmVkIG5vZGUgaGFzIG5vIHByaXZhdGUga2V5LCBidXQgY2FuIGJlIHVzZWQgdG8gZGVyaXZlXG4gICAgICogIGNoaWxkIGFkZHJlc3NlcyBhbmQgb3RoZXIgcHVibGljIGRhdGEgYWJvdXQgdGhlIEhEIE5vZGUuXG4gICAgICovXG4gICAgbmV1dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgY2hpbGQgZm9yICUlaW5kZXglJS5cbiAgICAgKi9cbiAgICBkZXJpdmVDaGlsZChfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBraSA9IG5ldyBTaWduaW5nS2V5KHRvQmVIZXgoKHRvQmlnSW50KElMKSArIEJpZ0ludCh0aGlzLnByaXZhdGVLZXkpKSAlIE4sIDMyKSk7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwga2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMubW5lbW9uaWMsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBIRE5vZGUgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG4gICAgc3RhdGljICNmcm9tU2VlZChfc2VlZCwgbW5lbW9uaWMpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNCeXRlc0xpa2UoX3NlZWQpLCBcImludmFsaWQgc2VlZFwiLCBcInNlZWRcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICBjb25zdCBzZWVkID0gZ2V0Qnl0ZXMoX3NlZWQsIFwic2VlZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2VlZC5sZW5ndGggPj0gMTYgJiYgc2VlZC5sZW5ndGggPD0gNjQsIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IEkgPSBnZXRCeXRlcyhjb21wdXRlSG1hYyhcInNoYTUxMlwiLCBNYXN0ZXJTZWNyZXQsIHNlZWQpKTtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGhleGxpZnkoSS5zbGljZSgwLCAzMikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBzaWduaW5nS2V5LCBcIjB4MDAwMDAwMDBcIiwgaGV4bGlmeShJLnNsaWNlKDMyKSksIFwibVwiLCAwLCAwLCBtbmVtb25pYywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEhEIE5vZGUgZnJvbSAlJWV4dGVuZGVkS2V5JSUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlZXh0ZW5kZWRLZXklJSB3aWxsIGVpdGhlciBoYXZlIGEgcHJlZml4IG9yIGBgeHB1YmBgIG9yXG4gICAgICogIGBgeHByaXZgYCwgcmV0dXJuaW5nIGEgbmV1dGVyZWQgSEQgTm9kZSAoW1tIRE5vZGVWb2lkV2FsbGV0XV0pXG4gICAgICogIG9yIGZ1bGwgSEQgTm9kZSAoW1tIRE5vZGVXYWxsZXQpIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdG9CZUFycmF5KGRlY29kZUJhc2U1OChleHRlbmRlZEtleSkpOyAvLyBAVE9ETzogcmVkYWN0XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gODIgfHwgZW5jb2RlQmFzZTU4Q2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSA9PT0gZXh0ZW5kZWRLZXksIFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcbiAgICAgICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDUsIDkpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIHN3aXRjaCAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkpIHtcbiAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcbiAgICAgICAgICAgIGNhc2UgXCIweDA0ODhiMjFlXCI6XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODdjZlwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gaGV4bGlmeShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIGNvbXB1dGVBZGRyZXNzKHB1YmxpY0tleSksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgbnVsbCwgaW5kZXgsIGRlcHRoLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTgzOTQgXCI6XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBuZXcgU2lnbmluZ0tleShrZXkuc2xpY2UoMSkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXh0ZW5kZWQga2V5IHByZWZpeFwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gSEROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocGFzc3dvcmQsIHBhdGgsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkocmFuZG9tQnl0ZXMoMTYpLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhbiBIRCBOb2RlIGZyb20gJSVtbmVtb25pYyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhIG1uZW1vbmljICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5mcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhICUlc2VlZCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipIRE5vZGVWb2lkV2FsbGV0KiogY2Fubm90IHNpZ24sIGJ1dCBwcm92aWRlcyBhY2Nlc3MgdG9cbiAqICB0aGUgY2hpbGRyZW4gbm9kZXMgb2YgYSBbW2xpbmstYmlwLTMyXV0gSEQgd2FsbGV0IGFkZHJlc3Nlcy5cbiAqXG4gKiAgVGhlIGNhbiBiZSBjcmVhdGVkIGJ5IHVzaW5nIGFuIGV4dGVuZGVkIGBgeHB1YmBgIGtleSB0b1xuICogIFtbSEROb2RlV2FsbGV0X2Zyb21FeHRlbmRlZEtleV1dIG9yIGJ5XG4gKiAgW251ZXRlcmluZ10oSEROb2RlV2FsbGV0LW5ldXRlcikgYSBbW0hETm9kZVdhbGxldF1dLlxuICovXG5leHBvcnQgY2xhc3MgSEROb2RlVm9pZFdhbGxldCBleHRlbmRzIFZvaWRTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIHB1YmxpY0tleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZpbmdlcnByaW50LlxuICAgICAqXG4gICAgICogIEEgZmluZ2VycHJpbnQgYWxsb3dzIHF1aWNrIHFheSB0byBkZXRlY3QgcGFyZW50IGFuZCBjaGlsZCBub2RlcyxcbiAgICAgKiAgYnV0IGRldmVsb3BlcnMgc2hvdWxkIGJlIHByZXBhcmVkIHRvIGRlYWwgd2l0aCBjb2xsaXNpb25zIGFzIGl0XG4gICAgICogIGlzIG9ubHkgNCBieXRlcy5cbiAgICAgKi9cbiAgICBmaW5nZXJwcmludDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcmVudCBub2RlIGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGVyIGZ1bGwgcGF0aCBkZXRhaWxzLCB0aGlzXG4gICAgICogIG1heSBiZSBgYG51bGxgYCwgaWYgaW5zdGFudGlhdGVkIGZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdFxuICAgICAqICBlbm9jZGUgaXQuXG4gICAgICovXG4gICAgcGF0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoaWxkIGluZGV4IG9mIHRoaXMgd2FsbGV0LiBWYWx1ZXMgb3ZlciBgYDIgKlxcKiAzMWBgIGluZGljYXRlXG4gICAgICogIHRoZSBub2RlIGlzIGhhcmRlbmVkLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVwdGggb2YgdGhpcyB3YWxsZXQsIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xuICAgICAqICBpbiBpdHMgcGF0aC5cbiAgICAgKi9cbiAgICBkZXB0aDtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgYWRkcmVzcywgcHVibGljS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKGFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVZvaWRXYWxsZXRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gZGF0YVNsaWNlKHJpcGVtZDE2MChzaGEyNTYocHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSwgZmluZ2VycHJpbnQsIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXh0ZW5kZWQga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMga2V5IHdpbGwgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgeHB1YmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIG5ldXRlcmVkIGtleSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgwNDg4QjIxRVwiLFxuICAgICAgICAgICAgenBhZCh0aGlzLmRlcHRoLCAxKSxcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLFxuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKF9pbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICAvLyBCYXNlIHBhdGhcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IEtpID0gU2lnbmluZ0tleS5hZGRQb2ludHMoSUwsIHRoaXMucHVibGljS2V5LCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKEtpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgYWRkcmVzcywgS2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduZXIgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEhETm9kZVdhbGxldE1hbmFnZXIge1xuICAgICNyb290OiBIRE5vZGVXYWxsZXQ7XG5cbiAgICBjb25zdHJ1Y3RvcihwaHJhc2U6IHN0cmluZywgcGFzc3dvcmQ/OiBudWxsIHwgc3RyaW5nLCBwYXRoPzogbnVsbCB8IHN0cmluZywgbG9jYWxlPzogbnVsbCB8IFdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7IHBhc3N3b3JkID0gXCJcIjsgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7IHBhdGggPSBcIm0vNDQnLzYwJy8wJy8wXCI7IH1cbiAgICAgICAgaWYgKGxvY2FsZSA9PSBudWxsKSB7IGxvY2FsZSA9IExhbmdFbi53b3JkbGlzdCgpOyB9XG4gICAgICAgIHRoaXMuI3Jvb3QgPSBIRE5vZGVXYWxsZXQuZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCBsb2NhbGUpO1xuICAgIH1cblxuICAgIGdldFNpZ25lcihpbmRleD86IG51bWJlcik6IEhETm9kZVdhbGxldCB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyb290LmRlcml2ZUNoaWxkKChpbmRleCA9PSBudWxsKSA/IDA6IGluZGV4KTtcbiAgICB9XG59XG4qL1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLWJpcC0zMl1dIHBhdGggZm9yIHRoZSBhY2NvdW50IGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBMZWRnZXIuXG4gKlxuICogIFRoZXJlIGlzIGFsc28gYW4gW2FsdGVybmF0ZSBwYXR0ZXJuXShnZXRJbmRleGVkQWNjb3VudFBhdGgpIHVzZWQgYnlcbiAqICBzb21lIHNvZnR3YXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvJHtpbmRleH0nLzAvMGA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBwYXRoIHVzaW5nIGFuIGFsdGVybmF0aXZlIHBhdHRlcm4gZm9yIGRlcml2aW5nIGFjY291bnRzLFxuICogIGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBkZXJpdmF0aW9uIHBhdGggdXNlcyB0aGUgLy9pbmRleC8vIGNvbXBvbmVudCByYXRoZXIgdGhhbiB0aGVcbiAqICAvL2FjY291bnQvLyBjb21wb25lbnQgdG8gZGVyaXZlIHNlcXVlbnRpYWwgYWNjb3VudHMuXG4gKlxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTWV0YU1hc2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleGVkQWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC8ke2luZGV4fWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZHdhbGxldC5qcy5tYXAiXSwibmFtZXMiOlsiY29tcHV0ZUhtYWMiLCJyYW5kb21CeXRlcyIsInJpcGVtZDE2MCIsIlNpZ25pbmdLZXkiLCJzaGEyNTYiLCJWb2lkU2lnbmVyIiwiY29tcHV0ZUFkZHJlc3MiLCJjb25jYXQiLCJkYXRhU2xpY2UiLCJkZWNvZGVCYXNlNTgiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW5jb2RlQmFzZTU4IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJnZXROdW1iZXIiLCJ0b0JlQXJyYXkiLCJ0b0JpZ0ludCIsInRvQmVIZXgiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJMYW5nRW4iLCJCYXNlV2FsbGV0IiwiTW5lbW9uaWMiLCJlbmNyeXB0S2V5c3RvcmVKc29uIiwiZW5jcnlwdEtleXN0b3JlSnNvblN5bmMiLCJkZWZhdWx0UGF0aCIsIk1hc3RlclNlY3JldCIsIlVpbnQ4QXJyYXkiLCJIYXJkZW5lZEJpdCIsIk4iLCJCaWdJbnQiLCJOaWJibGVzIiwienBhZCIsInZhbHVlIiwibGVuZ3RoIiwicmVzdWx0IiwiTWF0aCIsInRydW5jIiwiZW5jb2RlQmFzZTU4Q2hlY2siLCJfdmFsdWUiLCJjaGVjayIsImJ5dGVzIiwiX2d1YXJkIiwic2VyX0kiLCJpbmRleCIsImNoYWluQ29kZSIsInB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJkYXRhIiwib3BlcmF0aW9uIiwic2V0IiwiaSIsIkkiLCJJTCIsInNsaWNlIiwiSVIiLCJkZXJpdmVQYXRoIiwibm9kZSIsInBhdGgiLCJjb21wb25lbnRzIiwic3BsaXQiLCJkZXB0aCIsInNoaWZ0IiwiY29tcG9uZW50IiwibWF0Y2giLCJwYXJzZUludCIsInN1YnN0cmluZyIsImRlcml2ZUNoaWxkIiwiSEROb2RlV2FsbGV0IiwiY29uc3RydWN0b3IiLCJndWFyZCIsInNpZ25pbmdLZXkiLCJwYXJlbnRGaW5nZXJwcmludCIsIm1uZW1vbmljIiwicHJvdmlkZXIiLCJjb21wcmVzc2VkUHVibGljS2V5IiwiZmluZ2VycHJpbnQiLCJjb25uZWN0IiwiYWNjb3VudCIsImFkZHJlc3MiLCJtIiwid29yZGxpc3QiLCJsb2NhbGUiLCJwYXNzd29yZCIsImVudHJvcHkiLCJlbmNyeXB0IiwicHJvZ3Jlc3NDYWxsYmFjayIsImVuY3J5cHRTeW5jIiwiZXh0ZW5kZWRLZXkiLCJoYXNQYXRoIiwibmV1dGVyIiwiSEROb2RlVm9pZFdhbGxldCIsIl9pbmRleCIsImtpIiwiZnJvbVNlZWQiLCJfc2VlZCIsInNlZWQiLCJmcm9tRXh0ZW5kZWRLZXkiLCJrZXkiLCJjcmVhdGVSYW5kb20iLCJmcm9tRW50cm9weSIsImNvbXB1dGVTZWVkIiwiZnJvbU1uZW1vbmljIiwiZnJvbVBocmFzZSIsInBocmFzZSIsIktpIiwiYWRkUG9pbnRzIiwiZ2V0QWNjb3VudFBhdGgiLCJnZXRJbmRleGVkQWNjb3VudFBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/hdwallet.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/json-crowdsale.js":
/*!******************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/json-crowdsale.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptCrowdsaleJson: () => (/* binding */ decryptCrowdsaleJson),\n/* harmony export */   isCrowdsaleJson: () => (/* binding */ isCrowdsaleJson)\n/* harmony export */ });\n/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/pbkdf2.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/utils.js\");\n/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */ \n\n\n\n\n\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */ function isCrowdsaleJson(json) {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) {\n            return true;\n        }\n    } catch (error) {}\n    return false;\n}\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */ function decryptCrowdsaleJson(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\n    // Ethereum Address\n    const address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"ethaddr:string!\"));\n    // Encrypted Seed\n    const encseed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.looseArrayify)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"encseed:string!\"));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(encseed && encseed.length % 16 === 0, \"invalid encseed\", \"json\", json);\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CBC(key, iv);\n    const seed = (0,aes_js__WEBPACK_IMPORTED_MODULE_0__.pkcs7Strip)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBytes)(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for(let i = 0; i < seed.length; i++){\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    return {\n        address,\n        privateKey: (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_6__.id)(seedHex)\n    };\n} //# sourceMappingURL=json-crowdsale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9qc29uLWNyb3dkc2FsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUN3QztBQUNRO0FBQ0w7QUFDTjtBQUN1QjtBQUNJO0FBQ2pFOztDQUVDLEdBQ00sU0FBU1UsZ0JBQWdCQyxJQUFJO0lBQ2hDLElBQUk7UUFDQSxNQUFNQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNIO1FBQ3hCLElBQUlDLEtBQUtHLE9BQU8sRUFBRTtZQUNkLE9BQU87UUFDWDtJQUNKLEVBQ0EsT0FBT0MsT0FBTyxDQUFFO0lBQ2hCLE9BQU87QUFDWDtBQUNBLGlEQUFpRDtBQUNqRDs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTQyxxQkFBcUJOLElBQUksRUFBRU8sU0FBUztJQUNoRCxNQUFNTixPQUFPQyxLQUFLQyxLQUFLLENBQUNIO0lBQ3hCLE1BQU1RLFdBQVdaLHNEQUFXQSxDQUFDVztJQUM3QixtQkFBbUI7SUFDbkIsTUFBTUUsVUFBVWxCLDZEQUFVQSxDQUFDTyxrREFBT0EsQ0FBQ0csTUFBTTtJQUN6QyxpQkFBaUI7SUFDakIsTUFBTUcsVUFBVVAsd0RBQWFBLENBQUNDLGtEQUFPQSxDQUFDRyxNQUFNO0lBQzVDTiwrREFBY0EsQ0FBQ1MsV0FBVyxRQUFTTSxNQUFNLEdBQUcsT0FBUSxHQUFHLG1CQUFtQixRQUFRVjtJQUNsRixNQUFNVyxNQUFNakIseURBQVFBLENBQUNGLHdEQUFNQSxDQUFDZ0IsVUFBVUEsVUFBVSxNQUFNLElBQUksV0FBV0ksS0FBSyxDQUFDLEdBQUc7SUFDOUUsTUFBTUMsS0FBS1QsUUFBUVEsS0FBSyxDQUFDLEdBQUc7SUFDNUIsTUFBTUUsZ0JBQWdCVixRQUFRUSxLQUFLLENBQUM7SUFDcEMsbUJBQW1CO0lBQ25CLE1BQU1HLFNBQVMsSUFBSTFCLHVDQUFHQSxDQUFDc0IsS0FBS0U7SUFDNUIsTUFBTUcsT0FBTzFCLGtEQUFVQSxDQUFDSSx5REFBUUEsQ0FBQ3FCLE9BQU9FLE9BQU8sQ0FBQ0g7SUFDaEQsNkVBQTZFO0lBQzdFLElBQUlJLFVBQVU7SUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsS0FBS04sTUFBTSxFQUFFUyxJQUFLO1FBQ2xDRCxXQUFXRSxPQUFPQyxZQUFZLENBQUNMLElBQUksQ0FBQ0csRUFBRTtJQUMxQztJQUNBLE9BQU87UUFBRVY7UUFBU2EsWUFBWTdCLGtEQUFFQSxDQUFDeUI7SUFBUztBQUM5QyxFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2pzb24tY3Jvd2RzYWxlLmpzP2FlMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkpTT04gV2FsbGV0cyAgW2pzb24td2FsbGV0c11cbiAqL1xuaW1wb3J0IHsgQ0JDLCBwa2NzN1N0cmlwIH0gZnJvbSBcImFlcy1qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBwYmtkZjIgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldFBhc3N3b3JkLCBsb29zZUFycmF5aWZ5LCBzcGVsdW5rIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gQ3Jvd2RzYWxlIHdhbGxldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ3Jvd2RzYWxlSnNvbihqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIGlmIChkYXRhLmVuY3NlZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbFxuLyoqXG4gKiAgQmVmb3JlIEV0aGVyZXVtIGxhdW5jaGVkLCBpdCB3YXMgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBhIHdhbGxldFxuICogIGZvcm1hdCBmb3IgYmFja2VycyB0byB1c2UsIHdoaWNoIHdvdWxkIGJlIHVzZWQgdG8gcmVjZWl2ZSBldGhlclxuICogIGFzIGEgcmV3YXJkIGZvciBjb250cmlidXRpbmcgdG8gdGhlIHByb2plY3QuXG4gKlxuICogIFRoZSBbW2xpbmstY3Jvd2RzYWxlXV0gZm9ybWF0IGlzIG5vdyBvYnNvbGV0ZSwgYnV0IGl0IGlzIHN0aWxsXG4gKiAgdXNlZnVsIHRvIHN1cHBvcnQgYW5kIHRoZSBhZGRpdGlvbmFsIGNvZGUgaXMgZmFpcmx5IHRyaXZpYWwgYXNcbiAqICBhbGwgdGhlIHByaW1pdGl2ZXMgcmVxdWlyZWQgYXJlIHVzZWQgdGhyb3VnaCBjb3JlIHBvcnRpb25zIG9mXG4gKiAgdGhlIGxpYnJhcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNyeXB0Q3Jvd2RzYWxlSnNvbihqc29uLCBfcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XG4gICAgLy8gRXRoZXJldW0gQWRkcmVzc1xuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHNwZWx1bmsoZGF0YSwgXCJldGhhZGRyOnN0cmluZyFcIikpO1xuICAgIC8vIEVuY3J5cHRlZCBTZWVkXG4gICAgY29uc3QgZW5jc2VlZCA9IGxvb3NlQXJyYXlpZnkoc3BlbHVuayhkYXRhLCBcImVuY3NlZWQ6c3RyaW5nIVwiKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZW5jc2VlZCAmJiAoZW5jc2VlZC5sZW5ndGggJSAxNikgPT09IDAsIFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcbiAgICBjb25zdCBrZXkgPSBnZXRCeXRlcyhwYmtkZjIocGFzc3dvcmQsIHBhc3N3b3JkLCAyMDAwLCAzMiwgXCJzaGEyNTZcIikpLnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBpdiA9IGVuY3NlZWQuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IGVuY3J5cHRlZFNlZWQgPSBlbmNzZWVkLnNsaWNlKDE2KTtcbiAgICAvLyBEZWNyeXB0IHRoZSBzZWVkXG4gICAgY29uc3QgYWVzQ2JjID0gbmV3IENCQyhrZXksIGl2KTtcbiAgICBjb25zdCBzZWVkID0gcGtjczdTdHJpcChnZXRCeXRlcyhhZXNDYmMuZGVjcnlwdChlbmNyeXB0ZWRTZWVkKSkpO1xuICAgIC8vIFRoaXMgd2FsbGV0IGZvcm1hdCBpcyB3ZWlyZC4uLiBDb252ZXJ0IHRoZSBiaW5hcnkgZW5jb2RlZCBoZXggdG8gYSBzdHJpbmcuXG4gICAgbGV0IHNlZWRIZXggPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWVkSGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc2VlZFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB7IGFkZHJlc3MsIHByaXZhdGVLZXk6IGlkKHNlZWRIZXgpIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLWNyb3dkc2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiQ0JDIiwicGtjczdTdHJpcCIsImdldEFkZHJlc3MiLCJwYmtkZjIiLCJpZCIsImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRQYXNzd29yZCIsImxvb3NlQXJyYXlpZnkiLCJzcGVsdW5rIiwiaXNDcm93ZHNhbGVKc29uIiwianNvbiIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJlbmNzZWVkIiwiZXJyb3IiLCJkZWNyeXB0Q3Jvd2RzYWxlSnNvbiIsIl9wYXNzd29yZCIsInBhc3N3b3JkIiwiYWRkcmVzcyIsImxlbmd0aCIsImtleSIsInNsaWNlIiwiaXYiLCJlbmNyeXB0ZWRTZWVkIiwiYWVzQ2JjIiwic2VlZCIsImRlY3J5cHQiLCJzZWVkSGV4IiwiaSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInByaXZhdGVLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/json-crowdsale.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/json-keystore.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/json-keystore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptKeystoreJson: () => (/* binding */ decryptKeystoreJson),\n/* harmony export */   decryptKeystoreJsonSync: () => (/* binding */ decryptKeystoreJsonSync),\n/* harmony export */   encryptKeystoreJson: () => (/* binding */ encryptKeystoreJson),\n/* harmony export */   encryptKeystoreJsonSync: () => (/* binding */ encryptKeystoreJsonSync),\n/* harmony export */   isKeystoreJson: () => (/* binding */ isKeystoreJson)\n/* harmony export */ });\n/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/pbkdf2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/scrypt.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/random.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/uuid.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/utils.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../_version.js */ \"(rsc)/../../node_modules/ethers/lib.esm/_version.js\");\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */ \n\n\n\n\n\n\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */ function isKeystoreJson(json) {\n    try {\n        const data = JSON.parse(json);\n        const version = data.version != null ? parseInt(data.version) : 0;\n        if (version === 3) {\n            return true;\n        }\n    } catch (error) {}\n    return false;\n}\nfunction decrypt(data, key, ciphertext) {\n    const cipher = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n        const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(key, iv);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(aesCtr.decrypt(ciphertext));\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\nfunction getAccount(data, _key) {\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_key);\n    const ciphertext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.ciphertext:data!\");\n    const computedMAC = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        key.slice(16, 32),\n        ciphertext\n    ]))).substring(2);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(computedMAC === (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n    const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.computeAddress)(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) {\n            check = \"0x\" + check;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n    const account = {\n        address,\n        privateKey\n    };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n        const mnemonicCiphertext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(mnemonicKey, mnemonicIv);\n        account.mnemonic = {\n            path: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.path:string\") || defaultPath,\n            locale: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.locale:string\") || \"en\",\n            entropy: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n    return account;\n}\nfunction getDecryptKdfParams(data) {\n    const kdf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdf:string\");\n    if (kdf && typeof kdf === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const N = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.n:int!\");\n            const r = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.r:int!\");\n            const p = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.p:int!\");\n            // Make sure N is a power of 2\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(N > 0 && (N & N - 1) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n            const dkLen = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n            return {\n                name: \"scrypt\",\n                salt,\n                N,\n                r,\n                p,\n                dkLen: 64\n            };\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const prf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n            const count = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.c:int!\");\n            const dkLen = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n            return {\n                name: \"pbkdf2\",\n                salt,\n                count,\n                dkLen,\n                algorithm\n            };\n        }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */ function decryptKeystoreJsonSync(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.pbkdf2)(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n        params\n    });\n    const { salt, N, r, p, dkLen } = params;\n    const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.scryptSync)(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            resolve();\n        }, duration);\n    });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */ async function decryptKeystoreJson(json, _password, progress) {\n    const data = JSON.parse(json);\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.pbkdf2)(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n        params\n    });\n    const { salt, N, r, p, dkLen } = params;\n    const key = await (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.scrypt)(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\nfunction getEncryptKdfParams(options) {\n    // Check/generate the salt\n    const salt = options.salt != null ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.salt, \"options.salt\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_9__.randomBytes)(32);\n    // Override the scrypt password-based key derivation function parameters\n    let N = 1 << 17, r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof N === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof r === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof p === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n    return {\n        name: \"scrypt\",\n        dkLen: 32,\n        salt,\n        N,\n        r,\n        p\n    };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n    const privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(account.privateKey, \"privateKey\");\n    // Override initialization vector\n    const iv = options.iv != null ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.iv, \"options.iv\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_9__.randomBytes)(16);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n    // Override the uuid\n    const uuidRandom = options.uuid != null ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.uuid, \"options.uuid\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_9__.randomBytes)(16);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n    // Encrypt the private key\n    const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(derivedKey, iv);\n    const ciphertext = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    const mac = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        macPrefix,\n        ciphertext\n    ]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data = {\n        address: account.address.substring(2).toLowerCase(),\n        id: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.uuidV4)(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(iv).substring(2)\n            },\n            ciphertext: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = options.client != null ? options.client : `ethers/${_version_js__WEBPACK_IMPORTED_MODULE_11__.version}`;\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n        const mnemonicKey = key.slice(32, 64);\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_9__.randomBytes)(16);\n        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(mnemonicAesCtr.encrypt(entropy));\n        const now = new Date();\n        const timestamp = now.getUTCFullYear() + \"-\" + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCMonth() + 1, 2) + \"-\" + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCDate(), 2) + \"T\" + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCHours(), 2) + \"-\" + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCMinutes(), 2) + \"-\" + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCSeconds(), 2) + \".0Z\";\n        const gethFilename = \"UTC--\" + timestamp + \"--\" + data.address;\n        data[\"x-ethers\"] = {\n            client,\n            gethFilename,\n            path,\n            locale,\n            mnemonicCounter: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(mnemonicIv).substring(2),\n            mnemonicCiphertext: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n    return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */ function encryptKeystoreJsonSync(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key), kdf, account, options);\n}\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */ async function encryptKeystoreJson(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key), kdf, account, options);\n} //# sourceMappingURL=json-keystore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9qc29uLWtleXN0b3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzRCO0FBQ29CO0FBQ3VDO0FBQy9CO0FBQ3FDO0FBQ3RDO0FBQ2Y7QUFDekMsTUFBTWtCLGNBQWM7QUFDcEI7O0NBRUMsR0FDTSxTQUFTQyxlQUFlQyxJQUFJO0lBQy9CLElBQUk7UUFDQSxNQUFNQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNIO1FBQ3hCLE1BQU1ILFVBQVcsS0FBTUEsT0FBTyxJQUFJLE9BQVFPLFNBQVNILEtBQUtKLE9BQU8sSUFBSTtRQUNuRSxJQUFJQSxZQUFZLEdBQUc7WUFDZixPQUFPO1FBQ1g7SUFDSixFQUNBLE9BQU9RLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQSxTQUFTQyxRQUFRTCxJQUFJLEVBQUVNLEdBQUcsRUFBRUMsVUFBVTtJQUNsQyxNQUFNQyxTQUFTZCxrREFBT0EsQ0FBQ00sTUFBTTtJQUM3QixJQUFJUSxXQUFXLGVBQWU7UUFDMUIsTUFBTUMsS0FBS2Ysa0RBQU9BLENBQUNNLE1BQU07UUFDekIsTUFBTVUsU0FBUyxJQUFJL0IsdUNBQUdBLENBQUMyQixLQUFLRztRQUM1QixPQUFPcEIsd0RBQU9BLENBQUNxQixPQUFPTCxPQUFPLENBQUNFO0lBQ2xDO0lBQ0FoQix1REFBTUEsQ0FBQyxPQUFPLHNCQUFzQix5QkFBeUI7UUFDekRvQixXQUFXO0lBQ2Y7QUFDSjtBQUNBLFNBQVNDLFdBQVdaLElBQUksRUFBRWEsSUFBSTtJQUMxQixNQUFNUCxNQUFNbEIseURBQVFBLENBQUN5QjtJQUNyQixNQUFNTixhQUFhYixrREFBT0EsQ0FBQ00sTUFBTTtJQUNqQyxNQUFNYyxjQUFjekIsd0RBQU9BLENBQUNSLDJEQUFTQSxDQUFDTSx1REFBTUEsQ0FBQztRQUFDbUIsSUFBSVMsS0FBSyxDQUFDLElBQUk7UUFBS1I7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Q2I7SUFDSjtJQUNBLE9BQU9LLEtBQUtxRixTQUFTLENBQUN0RjtBQUMxQjtBQUNBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTdUYsd0JBQXdCakUsT0FBTyxFQUFFd0IsUUFBUSxFQUFFVSxPQUFPO0lBQzlELElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVSxDQUFDO0lBQ2Y7SUFDQSxNQUFNZ0MsZ0JBQWdCL0Ysc0RBQVdBLENBQUNxRDtJQUNsQyxNQUFNZCxNQUFNdUIsb0JBQW9CQztJQUNoQyxNQUFNbEQsTUFBTXJCLDREQUFVQSxDQUFDdUcsZUFBZXhELElBQUlDLElBQUksRUFBRUQsSUFBSUUsQ0FBQyxFQUFFRixJQUFJRyxDQUFDLEVBQUVILElBQUlJLENBQUMsRUFBRTtJQUNyRSxPQUFPd0IsaUJBQWlCeEUseURBQVFBLENBQUNrQixNQUFNMEIsS0FBS1YsU0FBU2tDO0FBQ3pEO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDTSxlQUFlaUMsb0JBQW9CbkUsT0FBTyxFQUFFd0IsUUFBUSxFQUFFVSxPQUFPO0lBQ2hFLElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVSxDQUFDO0lBQ2Y7SUFDQSxNQUFNZ0MsZ0JBQWdCL0Ysc0RBQVdBLENBQUNxRDtJQUNsQyxNQUFNZCxNQUFNdUIsb0JBQW9CQztJQUNoQyxNQUFNbEQsTUFBTSxNQUFNdEIsd0RBQU1BLENBQUN3RyxlQUFleEQsSUFBSUMsSUFBSSxFQUFFRCxJQUFJRSxDQUFDLEVBQUVGLElBQUlHLENBQUMsRUFBRUgsSUFBSUksQ0FBQyxFQUFFLElBQUlvQixRQUFRa0MsZ0JBQWdCO0lBQ25HLE9BQU85QixpQkFBaUJ4RSx5REFBUUEsQ0FBQ2tCLE1BQU0wQixLQUFLVixTQUFTa0M7QUFDekQsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9qc29uLWtleXN0b3JlLmpzP2M2ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIEpTT04gV2FsbGV0IGZvcm1hdHMgYWxsb3cgYSBzaW1wbGUgd2F5IHRvIHN0b3JlIHRoZSBwcml2YXRlXG4gKiAga2V5cyBuZWVkZWQgaW4gRXRoZXJldW0gYWxvbmcgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uIGFuZCBhbGxvd3NcbiAqICBmb3IgZXh0ZW5zaWJsZSBmb3JtcyBvZiBlbmNyeXB0aW9uLlxuICpcbiAqICBUaGVzZSB1dGlsaXRpZXMgZmFjaWxpdGF0ZSBkZWNyeXB0aW5nIGFuZCBlbmNyeXB0aW5nIHRoZSBtb3N0IGNvbW1vblxuICogIEpTT04gV2FsbGV0IGZvcm1hdHMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpKU09OIFdhbGxldHMgIFtqc29uLXdhbGxldHNdXG4gKi9cbmltcG9ydCB7IENUUiB9IGZyb20gXCJhZXMtanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBwYmtkZjIsIHJhbmRvbUJ5dGVzLCBzY3J5cHQsIHNjcnlwdFN5bmMgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBnZXRCeXRlcywgaGV4bGlmeSwgdXVpZFY0LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRQYXNzd29yZCwgc3BlbHVuaywgenBhZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5jb25zdCBkZWZhdWx0UGF0aCA9IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlanNvbiUlIGlzIGEgdmFsaWQgSlNPTiBLZXlzdG9yZSBXYWxsZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0tleXN0b3JlSnNvbihqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAoKGRhdGEudmVyc2lvbiAhPSBudWxsKSA/IHBhcnNlSW50KGRhdGEudmVyc2lvbikgOiAwKTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBjaXBoZXIgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcjpzdHJpbmdcIik7XG4gICAgaWYgKGNpcGhlciA9PT0gXCJhZXMtMTI4LWN0clwiKSB7XG4gICAgICAgIGNvbnN0IGl2ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5jaXBoZXJwYXJhbXMuaXY6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoa2V5LCBpdik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGFlc0N0ci5kZWNyeXB0KGNpcGhlcnRleHQpKTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIGNpcGhlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJkZWNyeXB0XCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFjY291bnQoZGF0YSwgX2tleSkge1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKF9rZXkpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnRleHQ6ZGF0YSFcIik7XG4gICAgY29uc3QgY29tcHV0ZWRNQUMgPSBoZXhsaWZ5KGtlY2NhazI1Nihjb25jYXQoW2tleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpKS5zdWJzdHJpbmcoMik7XG4gICAgYXNzZXJ0QXJndW1lbnQoY29tcHV0ZWRNQUMgPT09IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ubWFjOnN0cmluZyFcIikudG9Mb3dlckNhc2UoKSwgXCJpbmNvcnJlY3QgcGFzc3dvcmRcIiwgXCJwYXNzd29yZFwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZGVjcnlwdChkYXRhLCBrZXkuc2xpY2UoMCwgMTYpLCBjaXBoZXJ0ZXh0KTtcbiAgICBjb25zdCBhZGRyZXNzID0gY29tcHV0ZUFkZHJlc3MocHJpdmF0ZUtleSk7XG4gICAgaWYgKGRhdGEuYWRkcmVzcykge1xuICAgICAgICBsZXQgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFjaGVjay5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGNoZWNrID0gXCIweFwiICsgY2hlY2s7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZ2V0QWRkcmVzcyhjaGVjaykgPT09IGFkZHJlc3MsIFwia2V5c3RvcmUgYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIsIFwiYWRkcmVzc1wiLCBkYXRhLmFkZHJlc3MpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzLCBwcml2YXRlS2V5IH07XG4gICAgLy8gVmVyc2lvbiAwLjEgeC1ldGhlcnMgbWV0YWRhdGEgbXVzdCBjb250YWluIGFuIGVuY3J5cHRlZCBtbmVtb25pYyBwaHJhc2VcbiAgICBjb25zdCB2ZXJzaW9uID0gc3BlbHVuayhkYXRhLCBcIngtZXRoZXJzLnZlcnNpb246c3RyaW5nXCIpO1xuICAgIGlmICh2ZXJzaW9uID09PSBcIjAuMVwiKSB7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljS2V5ID0ga2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQ2lwaGVydGV4dCA9IHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5tbmVtb25pY0NpcGhlcnRleHQ6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDb3VudGVyOmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0Flc0N0ciA9IG5ldyBDVFIobW5lbW9uaWNLZXksIG1uZW1vbmljSXYpO1xuICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0ge1xuICAgICAgICAgICAgcGF0aDogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5wYXRoOnN0cmluZ1wiKSB8fCBkZWZhdWx0UGF0aCksXG4gICAgICAgICAgICBsb2NhbGU6IChzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubG9jYWxlOnN0cmluZ1wiKSB8fCBcImVuXCIpLFxuICAgICAgICAgICAgZW50cm9weTogaGV4bGlmeShnZXRCeXRlcyhtbmVtb25pY0Flc0N0ci5kZWNyeXB0KG1uZW1vbmljQ2lwaGVydGV4dCkpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudDtcbn1cbmZ1bmN0aW9uIGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSkge1xuICAgIGNvbnN0IGtkZiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmOnN0cmluZ1wiKTtcbiAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwic2NyeXB0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5zYWx0OmRhdGEhXCIpO1xuICAgICAgICAgICAgY29uc3QgTiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLm46aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5yOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCBwID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucDppbnQhXCIpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIE4gaXMgYSBwb3dlciBvZiAyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOID4gMCAmJiAoTiAmIChOIC0gMSkpID09PSAwLCBcImludmFsaWQga2RmLk5cIiwgXCJrZGYuTlwiLCBOKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHIgPiAwICYmIHAgPiAwLCBcImludmFsaWQga2RmXCIsIFwia2RmXCIsIGtkZik7XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGZsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJzY3J5cHRcIiwgc2FsdCwgTiwgciwgcCwgZGtMZW46IDY0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5zYWx0OmRhdGEhXCIpO1xuICAgICAgICAgICAgY29uc3QgcHJmID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucHJmOnN0cmluZyFcIik7XG4gICAgICAgICAgICBjb25zdCBhbGdvcml0aG0gPSBwcmYuc3BsaXQoXCItXCIpLnBvcCgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWxnb3JpdGhtID09PSBcInNoYTI1NlwiIHx8IGFsZ29yaXRobSA9PT0gXCJzaGE1MTJcIiwgXCJpbnZhbGlkIGtkZi5wZGZcIiwgXCJrZGYucGRmXCIsIHByZik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmM6aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRrTGVuID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuZGtsZW46aW50IVwiKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5ka2xlblwiLCBka0xlbik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInBia2RmMlwiLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJVxuICogIHVzaW5nICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGRlY3J5cHRLZXlzdG9yZUpzb24pXG4gKiAgaW5zdGVhZCwgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZFxuICogIGFzIHRvIHRoZSBkZWNyeXB0aW9uIHN0YXR1cy5cbiAqXG4gKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbCBkZWNyeXB0aW9uXG4gKiAgaXMgY29tcGxldGUsIHdoaWNoIGNhbiB0YWtlIHF1aXRlIHNvbWUgdGltZSwgZGVwZW5kaW5nIG9uIHRoZSB3YWxsZXRcbiAqICBwYXJhbXRlcnMgYW5kIHBsYXRmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdEtleXN0b3JlSnNvblN5bmMoanNvbiwgX3Bhc3N3b3JkKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRQYXNzd29yZChfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSk7XG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgIGNvbnN0IHsgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qga2V5ID0gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG4gICAgfVxuICAgIGFzc2VydChwYXJhbXMubmFtZSA9PT0gXCJzY3J5cHRcIiwgXCJjYW5ub3QgYmUgcmVhY2hlZFwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBwYXJhbXMgfSk7XG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGtleSA9IHNjcnlwdFN5bmMocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKTtcbiAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIHRoZSBkZWNyeXB0ZWQgSlNPTiBLZXlzdG9yZSBXYWxsZXQgJSVqc29uJSUgdXNpbmcgdGhlXG4gKiAgJSVwYXNzd29yZCUlLlxuICpcbiAqICBJZiBwcm92aWRlZCwgJSVwcm9ncmVzcyUlIHdpbGwgYmUgY2FsbGVkIHBlcmlvZGljYWxseSBkdXJpbmcgdGhlXG4gKiAgZGVjcnB5dGlvbiB0byBwcm92aWRlIGZlZWRiYWNrLCBhbmQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqICBgYGZhbHNlYGAgd2lsbCBoYWx0IGRlY3J5cHRpb24uXG4gKlxuICogIFRoZSAlJXByb2dyZXNzQ2FsbGJhY2slJSB3aWxsICoqYWx3YXlzKiogcmVjZWl2ZSBgYDBgYCBiZWZvcmVcbiAqICBkZWNyeXB0aW9uIGJlZ2lucyBhbmQgYGAxYGAgd2hlbiBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgX3Bhc3N3b3JkLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xuICAgIGlmIChwYXJhbXMubmFtZSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHByb2dyZXNzKDApO1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBrZXkgPSBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBwcm9ncmVzcygxKTtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG4gICAgfVxuICAgIGFzc2VydChwYXJhbXMubmFtZSA9PT0gXCJzY3J5cHRcIiwgXCJjYW5ub3QgYmUgcmVhY2hlZFwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBwYXJhbXMgfSk7XG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHNjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKTtcbiAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZnVuY3Rpb24gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKSB7XG4gICAgLy8gQ2hlY2svZ2VuZXJhdGUgdGhlIHNhbHRcbiAgICBjb25zdCBzYWx0ID0gKG9wdGlvbnMuc2FsdCAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuc2FsdCwgXCJvcHRpb25zLnNhbHRcIikgOiByYW5kb21CeXRlcygzMik7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIHNjcnlwdCBwYXNzd29yZC1iYXNlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXG4gICAgbGV0IE4gPSAoMSA8PCAxNyksIHIgPSA4LCBwID0gMTtcbiAgICBpZiAob3B0aW9ucy5zY3J5cHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0Lk4pIHtcbiAgICAgICAgICAgIE4gPSBvcHRpb25zLnNjcnlwdC5OO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5yKSB7XG4gICAgICAgICAgICByID0gb3B0aW9ucy5zY3J5cHQucjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucCkge1xuICAgICAgICAgICAgcCA9IG9wdGlvbnMuc2NyeXB0LnA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChOKSA9PT0gXCJudW1iZXJcIiAmJiBOID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihOKSAmJiAoQmlnSW50KE4pICYgQmlnSW50KE4gLSAxKSkgPT09IEJpZ0ludCgwKSwgXCJpbnZhbGlkIHNjcnlwdCBOIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMuTlwiLCBOKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHIpID09PSBcIm51bWJlclwiICYmIHIgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHIpLCBcImludmFsaWQgc2NyeXB0IHIgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5yXCIsIHIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAocCkgPT09IFwibnVtYmVyXCIgJiYgcCA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIocCksIFwiaW52YWxpZCBzY3J5cHQgcCBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLnBcIiwgcCk7XG4gICAgcmV0dXJuIHsgbmFtZTogXCJzY3J5cHRcIiwgZGtMZW46IDMyLCBzYWx0LCBOLCByLCBwIH07XG59XG5mdW5jdGlvbiBfZW5jcnlwdEtleXN0b3JlKGtleSwga2RmLCBhY2NvdW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdldEJ5dGVzKGFjY291bnQucHJpdmF0ZUtleSwgXCJwcml2YXRlS2V5XCIpO1xuICAgIC8vIE92ZXJyaWRlIGluaXRpYWxpemF0aW9uIHZlY3RvclxuICAgIGNvbnN0IGl2ID0gKG9wdGlvbnMuaXYgIT0gbnVsbCkgPyBnZXRCeXRlcyhvcHRpb25zLml2LCBcIm9wdGlvbnMuaXZcIikgOiByYW5kb21CeXRlcygxNik7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXYubGVuZ3RoID09PSAxNiwgXCJpbnZhbGlkIG9wdGlvbnMuaXYgbGVuZ3RoXCIsIFwib3B0aW9ucy5pdlwiLCBvcHRpb25zLml2KTtcbiAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuICAgIGNvbnN0IHV1aWRSYW5kb20gPSAob3B0aW9ucy51dWlkICE9IG51bGwpID8gZ2V0Qnl0ZXMob3B0aW9ucy51dWlkLCBcIm9wdGlvbnMudXVpZFwiKSA6IHJhbmRvbUJ5dGVzKDE2KTtcbiAgICBhc3NlcnRBcmd1bWVudCh1dWlkUmFuZG9tLmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLnV1aWQgbGVuZ3RoXCIsIFwib3B0aW9ucy51dWlkXCIsIG9wdGlvbnMuaXYpO1xuICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXG4gICAgLy8gLSAzMiBieXRlcyAgIEFzIG5vcm1hbCBmb3IgdGhlIFdlYjMgc2VjcmV0IHN0b3JhZ2UgKGRlcml2ZWRLZXksIG1hY1ByZWZpeClcbiAgICAvLyAtIDMyIGJ5dGVzICAgQUVTIGtleSB0byBlbmNyeXB0IG1uZW1vbmljIHdpdGggKHJlcXVpcmVkIGhlcmUgdG8gYmUgRXRoZXJzIFdhbGxldClcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0ga2V5LnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBtYWNQcmVmaXggPSBrZXkuc2xpY2UoMTYsIDMyKTtcbiAgICAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoZGVyaXZlZEtleSwgaXYpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBnZXRCeXRlcyhhZXNDdHIuZW5jcnlwdChwcml2YXRlS2V5KSk7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLCB1c2VkIHRvIGNoZWNrIHRoZSBwYXNzd29yZFxuICAgIGNvbnN0IG1hYyA9IGtlY2NhazI1Nihjb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvV2ViMy1TZWNyZXQtU3RvcmFnZS1EZWZpbml0aW9uXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBpZDogdXVpZFY0KHV1aWRSYW5kb20pLFxuICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICBDcnlwdG86IHtcbiAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgaXY6IGhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBoZXhsaWZ5KGNpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcbiAgICAgICAgICAgIGtkZnBhcmFtczoge1xuICAgICAgICAgICAgICAgIHNhbHQ6IGhleGxpZnkoa2RmLnNhbHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgICAgICBuOiBrZGYuTixcbiAgICAgICAgICAgICAgICBka2xlbjogMzIsXG4gICAgICAgICAgICAgICAgcDoga2RmLnAsXG4gICAgICAgICAgICAgICAgcjoga2RmLnJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYWM6IG1hYy5zdWJzdHJpbmcoMilcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgd2UgaGF2ZSBhIG1uZW1vbmljLCBlbmNyeXB0IGl0IGludG8gdGhlIEpTT04gd2FsbGV0XG4gICAgaWYgKGFjY291bnQubW5lbW9uaWMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gKG9wdGlvbnMuY2xpZW50ICE9IG51bGwpID8gb3B0aW9ucy5jbGllbnQgOiBgZXRoZXJzLyR7dmVyc2lvbn1gO1xuICAgICAgICBjb25zdCBwYXRoID0gYWNjb3VudC5tbmVtb25pYy5wYXRoIHx8IGRlZmF1bHRQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSB8fCBcImVuXCI7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljS2V5ID0ga2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBnZXRCeXRlcyhhY2NvdW50Lm1uZW1vbmljLmVudHJvcHksIFwiYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5XCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gcmFuZG9tQnl0ZXMoMTYpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0Flc0N0ciA9IG5ldyBDVFIobW5lbW9uaWNLZXksIG1uZW1vbmljSXYpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSBnZXRCeXRlcyhtbmVtb25pY0Flc0N0ci5lbmNyeXB0KGVudHJvcHkpKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDRGF0ZSgpLCAyKSArIFwiVFwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDTWludXRlcygpLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ1NlY29uZHMoKSwgMikgKyBcIi4wWlwiKTtcbiAgICAgICAgY29uc3QgZ2V0aEZpbGVuYW1lID0gKFwiVVRDLS1cIiArIHRpbWVzdGFtcCArIFwiLS1cIiArIGRhdGEuYWRkcmVzcyk7XG4gICAgICAgIGRhdGFbXCJ4LWV0aGVyc1wiXSA9IHtcbiAgICAgICAgICAgIGNsaWVudCwgZ2V0aEZpbGVuYW1lLCBwYXRoLCBsb2NhbGUsXG4gICAgICAgICAgICBtbmVtb25pY0NvdW50ZXI6IGhleGxpZnkobW5lbW9uaWNJdikuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgbW5lbW9uaWNDaXBoZXJ0ZXh0OiBoZXhsaWZ5KG1uZW1vbmljQ2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgdmVyc2lvbjogXCIwLjFcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWQgd2l0aFxuICogICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcbiAqICB1c2VkLiBBbnkgcHJvdmlkZWQgW1tQcm9ncmVzc0NhbGxiYWNrXV0gaXMgaWdub3JkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvblN5bmMoYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFzc3dvcmRCeXRlcyA9IGdldFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleSA9IHNjcnlwdFN5bmMocGFzc3dvcmRCeXRlcywga2RmLnNhbHQsIGtkZi5OLCBrZGYuciwga2RmLnAsIDY0KTtcbiAgICByZXR1cm4gX2VuY3J5cHRLZXlzdG9yZShnZXRCeXRlcyhrZXkpLCBrZGYsIGFjY291bnQsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiAgUmVzb2x2ZWQgdG8gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWRcbiAqICB3aXRoICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcbiAqICB1c2VkIGFuZCBwcm92aWRlIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8gcmVjZWl2ZSBwZXJpb2RpYyB1cGRhdGVzXG4gKiAgb24gdGhlIGNvbXBsZXRpb24gc3RhdHVzLi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRLZXlzdG9yZUpzb24oYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFzc3dvcmRCeXRlcyA9IGdldFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHNjcnlwdChwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQsIG9wdGlvbnMucHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoZ2V0Qnl0ZXMoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24ta2V5c3RvcmUuanMubWFwIl0sIm5hbWVzIjpbIkNUUiIsImdldEFkZHJlc3MiLCJrZWNjYWsyNTYiLCJwYmtkZjIiLCJyYW5kb21CeXRlcyIsInNjcnlwdCIsInNjcnlwdFN5bmMiLCJjb21wdXRlQWRkcmVzcyIsImNvbmNhdCIsImdldEJ5dGVzIiwiaGV4bGlmeSIsInV1aWRWNCIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZ2V0UGFzc3dvcmQiLCJzcGVsdW5rIiwienBhZCIsInZlcnNpb24iLCJkZWZhdWx0UGF0aCIsImlzS2V5c3RvcmVKc29uIiwianNvbiIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJwYXJzZUludCIsImVycm9yIiwiZGVjcnlwdCIsImtleSIsImNpcGhlcnRleHQiLCJjaXBoZXIiLCJpdiIsImFlc0N0ciIsIm9wZXJhdGlvbiIsImdldEFjY291bnQiLCJfa2V5IiwiY29tcHV0ZWRNQUMiLCJzbGljZSIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwicHJpdmF0ZUtleSIsImFkZHJlc3MiLCJjaGVjayIsInN0YXJ0c1dpdGgiLCJhY2NvdW50IiwibW5lbW9uaWNLZXkiLCJtbmVtb25pY0NpcGhlcnRleHQiLCJtbmVtb25pY0l2IiwibW5lbW9uaWNBZXNDdHIiLCJtbmVtb25pYyIsInBhdGgiLCJsb2NhbGUiLCJlbnRyb3B5IiwiZ2V0RGVjcnlwdEtkZlBhcmFtcyIsImtkZiIsInNhbHQiLCJOIiwiciIsInAiLCJka0xlbiIsIm5hbWUiLCJwcmYiLCJhbGdvcml0aG0iLCJzcGxpdCIsInBvcCIsImNvdW50IiwiZGVjcnlwdEtleXN0b3JlSnNvblN5bmMiLCJfcGFzc3dvcmQiLCJwYXNzd29yZCIsInBhcmFtcyIsInN0YWxsIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJkZWNyeXB0S2V5c3RvcmVKc29uIiwicHJvZ3Jlc3MiLCJnZXRFbmNyeXB0S2RmUGFyYW1zIiwib3B0aW9ucyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJCaWdJbnQiLCJfZW5jcnlwdEtleXN0b3JlIiwibGVuZ3RoIiwidXVpZFJhbmRvbSIsInV1aWQiLCJkZXJpdmVkS2V5IiwibWFjUHJlZml4IiwiZW5jcnlwdCIsIm1hYyIsImlkIiwiQ3J5cHRvIiwiY2lwaGVycGFyYW1zIiwia2RmcGFyYW1zIiwibiIsImRrbGVuIiwiY2xpZW50Iiwibm93IiwiRGF0ZSIsInRpbWVzdGFtcCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldGhGaWxlbmFtZSIsIm1uZW1vbmljQ291bnRlciIsInN0cmluZ2lmeSIsImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jIiwicGFzc3dvcmRCeXRlcyIsImVuY3J5cHRLZXlzdG9yZUpzb24iLCJwcm9ncmVzc0NhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/json-keystore.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/mnemonic.js":
/*!************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/mnemonic.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mnemonic: () => (/* binding */ Mnemonic)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/pbkdf2.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n\n\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return (1 << bits) - 1 << 8 - bits & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return (1 << bits) - 1 & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(\"NFKD\");\n    if (wordlist == null) {\n        wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\n    }\n    const words = wordlist.split(mnemonic);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n    let offset = 0;\n    for(let i = 0; i < words.length; i++){\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n        for(let bit = 0; bit < 11; bit++){\n            if (index & 1 << 10 - bit) {\n                entropy[offset >> 3] |= 1 << 7 - offset % 8;\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n    if (wordlist == null) {\n        wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\n    }\n    const indices = [\n        0\n    ];\n    let remainingBits = 11;\n    for(let i = 0; i < entropy.length; i++){\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n    return wordlist.join(indices.map((index)=>wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */ class Mnemonic {\n    /**\n     *  @private\n     */ constructor(guard, entropy, phrase, password, wordlist){\n        if (password == null) {\n            password = \"\";\n        }\n        if (wordlist == null) {\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Mnemonic\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.defineProperties)(this, {\n            phrase,\n            password,\n            wordlist,\n            entropy\n        });\n    }\n    /**\n     *  Returns the seed for the mnemonic.\n     */ computeSeed() {\n        const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.pbkdf2)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */ static fromPhrase(phrase, password, wordlist) {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */ static fromEntropy(_entropy, password, wordlist) {\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */ static entropyToPhrase(_entropy, wordlist) {\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */ static phraseToEntropy(phrase, wordlist) {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */ static isValidMnemonic(phrase, wordlist) {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        } catch (error) {}\n        return false;\n    }\n} //# sourceMappingURL=mnemonic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9tbmVtb25pYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvRDtBQUNpRjtBQUNwRjtBQUNqRCx1Q0FBdUM7QUFDdkMsU0FBU1UsYUFBYUMsSUFBSTtJQUN0QixPQUFPLENBQUUsS0FBS0EsSUFBRyxJQUFLLEtBQU8sSUFBSUEsT0FBUTtBQUM3QztBQUNBLHVDQUF1QztBQUN2QyxTQUFTQyxhQUFhRCxJQUFJO0lBQ3RCLE9BQU8sQ0FBRSxLQUFLQSxJQUFHLElBQUssSUFBSztBQUMvQjtBQUNBLFNBQVNFLGtCQUFrQkMsUUFBUSxFQUFFQyxRQUFRO0lBQ3pDVixnRUFBZUEsQ0FBQztJQUNoQixJQUFJVSxZQUFZLE1BQU07UUFDbEJBLFdBQVdOLHlEQUFNQSxDQUFDTSxRQUFRO0lBQzlCO0lBQ0EsTUFBTUMsUUFBUUQsU0FBU0UsS0FBSyxDQUFDSDtJQUM3QlAsK0RBQWNBLENBQUMsTUFBT1csTUFBTSxHQUFHLE1BQU8sS0FBS0YsTUFBTUUsTUFBTSxJQUFJLE1BQU1GLE1BQU1FLE1BQU0sSUFBSSxJQUFJLDJCQUEyQixZQUFZO0lBQzVILE1BQU1DLFVBQVUsSUFBSUMsV0FBV0MsS0FBS0MsSUFBSSxDQUFDLEtBQUtOLE1BQU1FLE1BQU0sR0FBRztJQUM3RCxJQUFJSyxTQUFTO0lBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLE1BQU1FLE1BQU0sRUFBRU0sSUFBSztRQUNuQyxJQUFJQyxRQUFRVixTQUFTVyxZQUFZLENBQUNWLEtBQUssQ0FBQ1EsRUFBRSxDQUFDRyxTQUFTLENBQUM7UUFDckRwQiwrREFBY0EsQ0FBQ2tCLFNBQVMsR0FBRyxDQUFDLCtCQUErQixFQUFFRCxFQUFFLENBQUMsRUFBRSxZQUFZO1FBQzlFLElBQUssSUFBSUksTUFBTSxHQUFHQSxNQUFNLElBQUlBLE1BQU87WUFDL0IsSUFBSUgsUUFBUyxLQUFNLEtBQUtHLEtBQU87Z0JBQzNCVCxP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QSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9tbmVtb25pYy5qcz82MmM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBia2RmMiwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXMsIGhleGxpZnksIGFzc2VydE5vcm1hbGl6ZSwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIE1TQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKSAmIDB4ZmY7XG59XG4vLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBMU0IgYml0cyBzZXRcbmZ1bmN0aW9uIGdldExvd2VyTWFzayhiaXRzKSB7XG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpICYgMHhmZjtcbn1cbmZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIGFzc2VydE5vcm1hbGl6ZShcIk5GS0RcIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSB3b3JkbGlzdC5zcGxpdChtbmVtb25pYyk7XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdvcmRzLmxlbmd0aCAlIDMpID09PSAwICYmIHdvcmRzLmxlbmd0aCA+PSAxMiAmJiB3b3Jkcy5sZW5ndGggPD0gMjQsIFwiaW52YWxpZCBtbmVtb25pYyBsZW5ndGhcIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExICogd29yZHMubGVuZ3RoIC8gOCkpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBgaW52YWxpZCBtbmVtb25pYyB3b3JkIGF0IGluZGV4ICR7aX1gLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBmb3IgKGxldCBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XG4gICAgICAgICAgICAgICAgZW50cm9weVtvZmZzZXQgPj4gM10gfD0gKDEgPDwgKDcgLSAob2Zmc2V0ICUgOCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IHdvcmRzLmxlbmd0aCAvIDM7XG4gICAgY29uc3QgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBnZXRCeXRlcyhzaGEyNTYoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKSlbMF0gJiBjaGVja3N1bU1hc2s7XG4gICAgYXNzZXJ0QXJndW1lbnQoY2hlY2tzdW0gPT09IChlbnRyb3B5W2VudHJvcHkubGVuZ3RoIC0gMV0gJiBjaGVja3N1bU1hc2spLCBcImludmFsaWQgbW5lbW9uaWMgY2hlY2tzdW1cIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpO1xufVxuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICBhc3NlcnRBcmd1bWVudCgoZW50cm9weS5sZW5ndGggJSA0KSA9PT0gMCAmJiBlbnRyb3B5Lmxlbmd0aCA+PSAxNiAmJiBlbnRyb3B5Lmxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGVudHJvcHkgc2l6ZVwiLCBcImVudHJvcHlcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlcyA9IFswXTtcbiAgICBsZXQgcmVtYWluaW5nQml0cyA9IDExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSA4O1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgICAgICAvLyBUaGlzIGJ5dGUgd2lsbCBjb21wbGV0ZSBhbiAxMS1iaXQgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gcmVtYWluaW5nQml0cztcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goZW50cm9weVtpXSAmIGdldExvd2VyTWFzayg4IC0gcmVtYWluaW5nQml0cykpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBwYXJzZUludChzaGEyNTYoZW50cm9weSkuc3Vic3RyaW5nKDIsIDQpLCAxNikgJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcbiAgICAvLyBTaGlmdCB0aGUgY2hlY2tzdW0gaW50byB0aGUgd29yZCBpbmRpY2VzXG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSBjaGVja3N1bUJpdHM7XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuICAgIHJldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKChpbmRleCkgPT4gd29yZGxpc3QuZ2V0V29yZChpbmRleCkpKTtcbn1cbmNvbnN0IF9ndWFyZCA9IHt9O1xuLyoqXG4gKiAgQSAqKk1uZW1vbmljKiogd3JhcHMgYWxsIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gY29tcHV0ZSBbW2xpbmstYmlwLTM5XV1cbiAqICBzZWVkcyBhbmQgY29udmVydCBiZXR3ZWVuIHBocmFzZXMgYW5kIGVudHJvcHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNbmVtb25pYyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyBwaHJhc2Ugb2YgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMuXG4gICAgICpcbiAgICAgKiAgVXNlIHRoZSBbW3dvcmRsaXN0XV0gYGBzcGxpdGBgIG1ldGhvZCB0byBnZXQgdGhlIGluZGl2aWR1YWwgd29yZHMuXG4gICAgICovXG4gICAgcGhyYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFzc3dvcmQgdXNlZCBmb3IgdGhpcyBtbmVtb25pYy4gSWYgbm8gcGFzc3dvcmQgaXMgdXNlZCB0aGlzXG4gICAgICogIGlzIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGFzIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBwYXNzd29yZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHdvcmRsaXN0IGZvciB0aGlzIG1uZW1vbmljLlxuICAgICAqL1xuICAgIHdvcmRsaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdW5kZXJseWluZyBlbnRyb3B5IHdoaWNoIHRoZSBtbmVtb25pYyBlbmNvZGVzLlxuICAgICAqL1xuICAgIGVudHJvcHk7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGVudHJvcHksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIk1uZW1vbmljXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QsIGVudHJvcHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzZWVkIGZvciB0aGUgbW5lbW9uaWMuXG4gICAgICovXG4gICAgY29tcHV0ZVNlZWQoKSB7XG4gICAgICAgIGNvbnN0IHNhbHQgPSB0b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyB0aGlzLnBhc3N3b3JkLCBcIk5GS0RcIik7XG4gICAgICAgIHJldHVybiBwYmtkZjIodG9VdGY4Qnl0ZXModGhpcy5waHJhc2UsIFwiTkZLRFwiKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBNbmVtb25pYyBmb3IgdGhlICUlcGhyYXNlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XG4gICAgICogIHdvcmRsaXN0IGlzIHRoZSBbRW5nbGlzaCB3b3JkbGlzdHNdKExhbmdFbikuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjZTsgdGhyb3dzIGlmIGludmFsaWRcbiAgICAgICAgY29uc3QgZW50cm9weSA9IG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhnZXRCeXRlcyhlbnRyb3B5KSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqTW5lbW9uaWMqKiBmcm9tIHRoZSAlJWVudHJvcHklJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVudHJvcHkoX2VudHJvcHksIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoX2VudHJvcHksIFwiZW50cm9weVwiKTtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgaGV4bGlmeShlbnRyb3B5KSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcGhyYXNlIGZvciAlJW1uZW1vbmljJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVudHJvcHlUb1BocmFzZShfZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICAgICAgY29uc3QgZW50cm9weSA9IGdldEJ5dGVzKF9lbnRyb3B5LCBcImVudHJvcHlcIik7XG4gICAgICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRyb3B5IGZvciAlJXBocmFzZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBwaHJhc2VUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgICAgICByZXR1cm4gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVwaHJhc2UlJSBpcyBhIHZhbGlkIFtbbGluay1iaXAtMzldXSBwaHJhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjaGVja3MgYWxsIHRoZSBwcm92aWRlZCB3b3JkcyBiZWxvbmcgdG8gdGhlICUld29yZGxpc3QlJSxcbiAgICAgKiAgdGhhdCB0aGUgbGVuZ3RoIGlzIHZhbGlkIGFuZCB0aGUgY2hlY2tzdW0gaXMgY29ycmVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZE1uZW1vbmljKHBocmFzZSwgd29yZGxpc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1uZW1vbmljLmpzLm1hcCJdLCJuYW1lcyI6WyJwYmtkZjIiLCJzaGEyNTYiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiYXNzZXJ0Tm9ybWFsaXplIiwiYXNzZXJ0UHJpdmF0ZSIsImFzc2VydEFyZ3VtZW50IiwidG9VdGY4Qnl0ZXMiLCJMYW5nRW4iLCJnZXRVcHBlck1hc2siLCJiaXRzIiwiZ2V0TG93ZXJNYXNrIiwibW5lbW9uaWNUb0VudHJvcHkiLCJtbmVtb25pYyIsIndvcmRsaXN0Iiwid29yZHMiLCJzcGxpdCIsImxlbmd0aCIsImVudHJvcHkiLCJVaW50OEFycmF5IiwiTWF0aCIsImNlaWwiLCJvZmZzZXQiLCJpIiwiaW5kZXgiLCJnZXRXb3JkSW5kZXgiLCJub3JtYWxpemUiLCJiaXQiLCJlbnRyb3B5Qml0cyIsImNoZWNrc3VtQml0cyIsImNoZWNrc3VtTWFzayIsImNoZWNrc3VtIiwic2xpY2UiLCJlbnRyb3B5VG9NbmVtb25pYyIsImluZGljZXMiLCJyZW1haW5pbmdCaXRzIiwicHVzaCIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiam9pbiIsIm1hcCIsImdldFdvcmQiLCJfZ3VhcmQiLCJNbmVtb25pYyIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJwaHJhc2UiLCJwYXNzd29yZCIsImNvbXB1dGVTZWVkIiwic2FsdCIsImZyb21QaHJhc2UiLCJmcm9tRW50cm9weSIsIl9lbnRyb3B5IiwiZW50cm9weVRvUGhyYXNlIiwicGhyYXNlVG9FbnRyb3B5IiwiaXNWYWxpZE1uZW1vbmljIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/mnemonic.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPassword: () => (/* binding */ getPassword),\n/* harmony export */   looseArrayify: () => (/* binding */ looseArrayify),\n/* harmony export */   spelunk: () => (/* binding */ spelunk),\n/* harmony export */   zpad: () => (/* binding */ zpad)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  @_ignore\n */ \nfunction looseArrayify(hexString) {\n    if (typeof hexString === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(hexString);\n}\nfunction zpad(value, length) {\n    value = String(value);\n    while(value.length < length){\n        value = \"0\" + value;\n    }\n    return value;\n}\nfunction getPassword(password) {\n    if (typeof password === \"string\") {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(password, \"NFKC\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(password);\n}\nfunction spelunk(object, _path) {\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(match != null, \"invalid path\", \"path\", _path);\n    const path = match[1];\n    const type = match[3];\n    const reqd = match[4] === \"!\";\n    let cur = object;\n    for (const comp of path.toLowerCase().split(\".\")){\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) {\n                break;\n            }\n            cur = cur[parseInt(comp)];\n        } else if (typeof cur === \"object\") {\n            let found = null;\n            for(const key in cur){\n                if (key.toLowerCase() === comp) {\n                    found = cur[key];\n                    break;\n                }\n            }\n            cur = found;\n        } else {\n            cur = null;\n        }\n        if (cur == null) {\n            break;\n        }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!reqd || cur != null, \"missing required value\", \"path\", path);\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof cur === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return parseInt(cur);\n            } else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n        if (type === \"number\") {\n            if (typeof cur === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return parseFloat(cur);\n            }\n        }\n        if (type === \"data\") {\n            if (typeof cur === \"string\") {\n                return looseArrayify(cur);\n            }\n        }\n        if (type === \"array\" && Array.isArray(cur)) {\n            return cur;\n        }\n        if (type === typeof cur) {\n            return cur;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `wrong type found for ${type} `, \"path\", path);\n    }\n    return cur;\n} /*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/  // See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n /*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/  //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDNkU7QUFDdkUsU0FBU0csY0FBY0MsU0FBUztJQUNuQyxJQUFJLE9BQVFBLGNBQWUsWUFBWSxDQUFDQSxVQUFVQyxVQUFVLENBQUMsT0FBTztRQUNoRUQsWUFBWSxPQUFPQTtJQUN2QjtJQUNBLE9BQU9KLDZEQUFZQSxDQUFDSTtBQUN4QjtBQUNPLFNBQVNFLEtBQUtDLEtBQUssRUFBRUMsTUFBTTtJQUM5QkQsUUFBUUUsT0FBT0Y7SUFDZixNQUFPQSxNQUFNQyxNQUFNLEdBQUdBLE9BQVE7UUFDMUJELFFBQVEsTUFBTUE7SUFDbEI7SUFDQSxPQUFPQTtBQUNYO0FBQ08sU0FBU0csWUFBWUMsUUFBUTtJQUNoQyxJQUFJLE9BQVFBLGFBQWMsVUFBVTtRQUNoQyxPQUFPVCw0REFBV0EsQ0FBQ1MsVUFBVTtJQUNqQztJQUNBLE9BQU9YLDZEQUFZQSxDQUFDVztBQUN4QjtBQUNPLFNBQVNDLFFBQVFDLE1BQU0sRUFBRUMsS0FBSztJQUNqQyxNQUFNQyxRQUFRRCxNQUFNQyxLQUFLLENBQUM7SUFDMUJkLCtEQUFjQSxDQUFDYyxTQUFTLE1BQU0sZ0JBQWdCLFFBQVFEO0lBQ3RELE1BQU1FLE9BQU9ELEtBQUssQ0FBQyxFQUFFO0lBQ3JCLE1BQU1FLE9BQU9GLEtBQUssQ0FBQyxFQUFFO0lBQ3JCLE1BQU1HLE9BQVFILEtBQUssQ0FBQyxFQUFFLEtBQUs7SUFDM0IsSUFBSUksTUFBTU47SUFDVixLQUFLLE1BQU1PLFFBQVFKLEtBQUtLLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEtBQU07UUFDOUMsaUVBQWlFO1FBQ2pFLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0wsTUFBTTtZQUNwQixJQUFJLENBQUNDLEtBQUtMLEtBQUssQ0FBQyxhQUFhO2dCQUN6QjtZQUNKO1lBQ0FJLE1BQU1BLEdBQUcsQ0FBQ00sU0FBU0wsTUFBTTtRQUM3QixPQUNLLElBQUksT0FBUUQsUUFBUyxVQUFVO1lBQ2hDLElBQUlPLFFBQVE7WUFDWixJQUFLLE1BQU1DLE9BQU9SLElBQUs7Z0JBQ25CLElBQUlRLElBQUlOLFdBQVcsT0FBT0QsTUFBTTtvQkFDNUJNLFFBQVFQLEdBQUcsQ0FBQ1EsSUFBSTtvQkFDaEI7Z0JBQ0o7WUFDSjtZQUNBUixNQUFNTztRQUNWLE9BQ0s7WUFDRFAsTUFBTTtRQUNWO1FBQ0EsSUFBSUEsT0FBTyxNQUFNO1lBQ2I7UUFDSjtJQUNKO0lBQ0FsQiwrREFBY0EsQ0FBQyxDQUFDaUIsUUFBUUMsT0FBTyxNQUFNLDBCQUEwQixRQUFRSDtJQUN2RSxJQUFJQyxRQUFRRSxPQUFPLE1BQU07UUFDckIsSUFBSUYsU0FBUyxPQUFPO1lBQ2hCLElBQUksT0FBUUUsUUFBUyxZQUFZQSxJQUFJSixLQUFLLENBQUMsZUFBZTtnQkFDdEQsT0FBT1UsU0FBU047WUFDcEIsT0FDSyxJQUFJUyxPQUFPQyxhQUFhLENBQUNWLE1BQU07Z0JBQ2hDLE9BQU9BO1lBQ1g7UUFDSjtRQUNBLElBQUlGLFNBQVMsVUFBVTtZQUNuQixJQUFJLE9BQVFFLFFBQVMsWUFBWUEsSUFBSUosS0FBSyxDQUFDLGdCQUFnQjtnQkFDdkQsT0FBT2UsV0FBV1g7WUFDdEI7UUFDSjtRQUNBLElBQUlGLFNBQVMsUUFBUTtZQUNqQixJQUFJLE9BQVFFLFFBQVMsVUFBVTtnQkFDM0IsT0FBT2hCLGNBQWNnQjtZQUN6QjtRQUNKO1FBQ0EsSUFBSUYsU0FBUyxXQUFXTSxNQUFNQyxPQUFPLENBQUNMLE1BQU07WUFDeEMsT0FBT0E7UUFDWDtRQUNBLElBQUlGLFNBQVMsT0FBUUUsS0FBTTtZQUN2QixPQUFPQTtRQUNYO1FBQ0FsQiwrREFBY0EsQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVBQUVnQixLQUFLLENBQUMsQ0FBQyxFQUFFLFFBQVFEO0lBQ25FO0lBQ0EsT0FBT0c7QUFDWCxFQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkEsSUFDQSwwREFBMEQ7Q0FDMUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLElBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvdXRpbHMuanM/MTQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBAX2lnbm9yZVxuICovXG5pbXBvcnQgeyBnZXRCeXRlc0NvcHksIGFzc2VydEFyZ3VtZW50LCB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3NlQXJyYXlpZnkoaGV4U3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiAoaGV4U3RyaW5nKSA9PT0gXCJzdHJpbmdcIiAmJiAhaGV4U3RyaW5nLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICBoZXhTdHJpbmcgPSBcIjB4XCIgKyBoZXhTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlc0NvcHkoaGV4U3RyaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB6cGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBpZiAodHlwZW9mIChwYXNzd29yZCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KHBhc3N3b3JkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGVsdW5rKG9iamVjdCwgX3BhdGgpIHtcbiAgICBjb25zdCBtYXRjaCA9IF9wYXRoLm1hdGNoKC9eKFthLXowLTkkXy4tXSopKDooW2Etel0rKSk/KCEpPyQvaSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2ggIT0gbnVsbCwgXCJpbnZhbGlkIHBhdGhcIiwgXCJwYXRoXCIsIF9wYXRoKTtcbiAgICBjb25zdCBwYXRoID0gbWF0Y2hbMV07XG4gICAgY29uc3QgdHlwZSA9IG1hdGNoWzNdO1xuICAgIGNvbnN0IHJlcWQgPSAobWF0Y2hbNF0gPT09IFwiIVwiKTtcbiAgICBsZXQgY3VyID0gb2JqZWN0O1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBwYXRoLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKSkge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgY2hpbGQgb2JqZWN0IHdpdGggYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nIGtleVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXAubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGN1cltwYXJzZUludChjb21wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChjdXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gY3VyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KCFyZXFkIHx8IGN1ciAhPSBudWxsLCBcIm1pc3NpbmcgcmVxdWlyZWQgdmFsdWVcIiwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIGlmICh0eXBlICYmIGN1ciAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihjdXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIiAmJiBjdXIubWF0Y2goL14tP1swLTkuXSokLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb29zZUFycmF5aWZ5KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHR5cGVvZiAoY3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHdyb25nIHR5cGUgZm91bmQgZm9yICR7dHlwZX0gYCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xufVxuLypcbmV4cG9ydCBmdW5jdGlvbiBmb2xsb3cob2JqZWN0OiBhbnksIHBhdGg6IHN0cmluZyk6IG51bGwgfCBzdHJpbmcge1xuICAgIGxldCBjdXJyZW50Q2hpbGQgPSBvYmplY3Q7XG5cbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJykpIHtcblxuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgY2hpbGQgb2JqZWN0IHdpdGggYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nIGtleVxuICAgICAgICBsZXQgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gY29tcCkge1xuICAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XG4gICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgY3VycmVudENoaWxkID0gbWF0Y2hpbmdDaGlsZDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENoaWxkO1xufVxuXG4vLyBcInBhdGgvdG8vc29tZXRoaW5nOnR5cGUhXCJcbmV4cG9ydCBmdW5jdGlvbiBmb2xsb3dSZXF1aXJlZChkYXRhOiBhbnksIHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFsdWUgPSBmb2xsb3coZGF0YSwgcGF0aCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsIGBkYXRhOiR7IHBhdGggfWAsXG4gICAgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufVxuKi9cbi8vIFNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcbi8qXG5leHBvcnQgZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzOiBCeXRlc0xpa2UpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMocmFuZG9tQnl0ZXMsIFwicmFuZG9tQnl0ZXNcIik7XG5cbiAgICAvLyBTZWN0aW9uOiA0LjEuMzpcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG5cbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgY29uc3QgdmFsdWUgPSBoZXhsaWZ5KGJ5dGVzKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTAsIDE0KSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMjIsIDM0KSxcbiAgICBdLmpvaW4oXCItXCIpO1xufVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlc0NvcHkiLCJhc3NlcnRBcmd1bWVudCIsInRvVXRmOEJ5dGVzIiwibG9vc2VBcnJheWlmeSIsImhleFN0cmluZyIsInN0YXJ0c1dpdGgiLCJ6cGFkIiwidmFsdWUiLCJsZW5ndGgiLCJTdHJpbmciLCJnZXRQYXNzd29yZCIsInBhc3N3b3JkIiwic3BlbHVuayIsIm9iamVjdCIsIl9wYXRoIiwibWF0Y2giLCJwYXRoIiwidHlwZSIsInJlcWQiLCJjdXIiLCJjb21wIiwidG9Mb3dlckNhc2UiLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlSW50IiwiZm91bmQiLCJrZXkiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwicGFyc2VGbG9hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wallet/wallet.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wallet/wallet.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wallet: () => (/* binding */ Wallet)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-wallet.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hdwallet.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/hdwallet.js\");\n/* harmony import */ var _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json-crowdsale.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/json-crowdsale.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-keystore.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mnemonic.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n\n\n\n\n\n\n\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            resolve();\n        }, duration);\n    });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */ class Wallet extends _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__.BaseWallet {\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */ constructor(key, provider){\n        if (typeof key === \"string\" && !key.startsWith(\"0x\")) {\n            key = \"0x\" + key;\n        }\n        let signingKey = typeof key === \"string\" ? new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey(key) : key;\n        super(signingKey, provider);\n    }\n    connect(provider) {\n        return new Wallet(this.signingKey, provider);\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */ async encrypt(password, progressCallback) {\n        const account = {\n            address: this.address,\n            privateKey: this.privateKey\n        };\n        return await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.encryptKeystoreJson)(account, password, {\n            progressCallback\n        });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */ encryptSync(password) {\n        const account = {\n            address: this.address,\n            privateKey: this.privateKey\n        };\n        return (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.encryptKeystoreJsonSync)(account, password);\n    }\n    static #fromAccount(account) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n            const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__.Mnemonic.fromEntropy(account.mnemonic.entropy);\n            const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n                return wallet;\n            }\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n        }\n        const wallet = new Wallet(account.privateKey);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n        return wallet;\n    }\n    /**\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n     *  with %%password%%.\n     *\n     *  If %%progress%% is provided, it is called periodically during\n     *  decryption so that any UI can be updated.\n     */ static async fromEncryptedJson(json, password, progress) {\n        let account = null;\n        if ((0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.isKeystoreJson)(json)) {\n            account = await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.decryptKeystoreJson)(json, password, progress);\n        } else if ((0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.isCrowdsaleJson)(json)) {\n            if (progress) {\n                progress(0);\n                await stall(0);\n            }\n            account = (0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.decryptCrowdsaleJson)(json, password);\n            if (progress) {\n                progress(1);\n                await stall(0);\n            }\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n     *\n     *  The [[fromEncryptedJson]] method is preferred, as this method\n     *  will lock up and freeze the UI during decryption, which may take\n     *  some time.\n     */ static fromEncryptedJsonSync(json, password) {\n        let account = null;\n        if ((0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.isKeystoreJson)(json)) {\n            account = (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.decryptKeystoreJsonSync)(json, password);\n        } else if ((0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.isCrowdsaleJson)(json)) {\n            account = (0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.decryptCrowdsaleJson)(json, password);\n        } else {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a new random [[HDNodeWallet]] using the avavilable\n     *  [cryptographic random source](randomBytes).\n     *\n     *  If there is no crytographic random source, this will throw.\n     */ static createRandom(provider) {\n        const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.createRandom();\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n    /**\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\n     */ static fromPhrase(phrase, provider) {\n        const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.fromPhrase(phrase);\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n} //# sourceMappingURL=wallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC93YWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDRztBQUNMO0FBQ0Q7QUFDK0I7QUFDb0U7QUFDdkc7QUFDekMsU0FBU1ksTUFBTUMsUUFBUTtJQUNuQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0M7UUFBY0MsV0FBVztZQUFRRDtRQUFXLEdBQUdGO0lBQVc7QUFDbEY7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNSSxlQUFlZix1REFBVUE7SUFDbEM7OztLQUdDLEdBQ0RnQixZQUFZQyxHQUFHLEVBQUVDLFFBQVEsQ0FBRTtRQUN2QixJQUFJLE9BQVFELFFBQVMsWUFBWSxDQUFDQSxJQUFJRSxVQUFVLENBQUMsT0FBTztZQUNwREYsTUFBTSxPQUFPQTtRQUNqQjtRQUNBLElBQUlHLGFBQWEsT0FBU0gsUUFBUyxXQUFZLElBQUluQix3REFBVUEsQ0FBQ21CLE9BQU9BO1FBQ3JFLEtBQUssQ0FBQ0csWUFBWUY7SUFDdEI7SUFDQUcsUUFBUUgsUUFBUSxFQUFFO1FBQ2QsT0FBTyxJQUFJSCxPQUFPLElBQUksQ0FBQ0ssVUFBVSxFQUFFRjtJQUN2QztJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1JLFFBQVFDLFFBQVEsRUFBRUMsZ0JBQWdCLEVBQUU7UUFDdEMsTUFBTUMsVUFBVTtZQUFFQyxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUFFQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUFDO1FBQ3JFLE9BQU8sTUFBTXJCLHNFQUFtQkEsQ0FBQ21CLFNBQVNGLFVBQVU7WUFBRUM7UUFBaUI7SUFDM0U7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDREksWUFBWUwsUUFBUSxFQUFFO1FBQ2xCLE1BQU1FLFVBQVU7WUFBRUMsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFBRUMsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFBQztRQUNyRSxPQUFPcEIsMEVBQXVCQSxDQUFDa0IsU0FBU0Y7SUFDNUM7SUFDQSxPQUFPLENBQUNNLFdBQVcsQ0FBQ0osT0FBTztRQUN2QjFCLCtEQUFjQSxDQUFDMEIsU0FBUyx1QkFBdUIsUUFBUTtRQUN2RCxJQUFJLGNBQWNBLFdBQVdBLFFBQVFLLFFBQVEsSUFBSUwsUUFBUUssUUFBUSxDQUFDQyxNQUFNLEtBQUssTUFBTTtZQUMvRSxNQUFNRCxXQUFXckIsa0RBQVFBLENBQUN1QixXQUFXLENBQUNQLFFBQVFLLFFBQVEsQ0FBQ0csT0FBTztZQUM5RCxNQUFNQyxTQUFTakMsc0RBQVlBLENBQUNrQyxZQUFZLENBQUNMLFVBQVVMLFFBQVFLLFFBQVEsQ0FBQ00sSUFBSTtZQUN4RSxJQUFJRixPQUFPUixPQUFPLEtBQUtELFFBQVFDLE9BQU8sSUFBSVEsT0FBT1AsVUFBVSxLQUFLRixRQUFRRSxVQUFVLEVBQUU7Z0JBQ2hGLE9BQU9PO1lBQ1g7WUFDQUcsUUFBUUMsR0FBRyxDQUFDO1FBQ2hCO1FBQ0EsTUFBTUosU0FBUyxJQUFJbkIsT0FBT1UsUUFBUUUsVUFBVTtRQUM1QzVCLCtEQUFjQSxDQUFDbUMsT0FBT1IsT0FBTyxLQUFLRCxRQUFRQyxPQUFPLEVBQUUsK0JBQStCLFFBQVE7UUFDMUYsT0FBT1E7SUFDWDtJQUNBOzs7Ozs7S0FNQyxHQUNELGFBQWFLLGtCQUFrQkMsSUFBSSxFQUFFakIsUUFBUSxFQUFFa0IsUUFBUSxFQUFFO1FBQ3JELElBQUloQixVQUFVO1FBQ2QsSUFBSWpCLGlFQUFjQSxDQUFDZ0MsT0FBTztZQUN0QmYsVUFBVSxNQUFNckIsc0VBQW1CQSxDQUFDb0MsTUFBTWpCLFVBQVVrQjtRQUN4RCxPQUNLLElBQUl0QyxtRUFBZUEsQ0FBQ3FDLE9BQU87WUFDNUIsSUFBSUMsVUFBVTtnQkFDVkEsU0FBUztnQkFDVCxNQUFNL0IsTUFBTTtZQUNoQjtZQUNBZSxVQUFVdkIsd0VBQW9CQSxDQUFDc0MsTUFBTWpCO1lBQ3JDLElBQUlrQixVQUFVO2dCQUNWQSxTQUFTO2dCQUNULE1BQU0vQixNQUFNO1lBQ2hCO1FBQ0o7UUFDQSxPQUFPSyxPQUFPLENBQUNjLFdBQVcsQ0FBQ0o7SUFDL0I7SUFDQTs7Ozs7O0tBTUMsR0FDRCxPQUFPaUIsc0JBQXNCRixJQUFJLEVBQUVqQixRQUFRLEVBQUU7UUFDekMsSUFBSUUsVUFBVTtRQUNkLElBQUlqQixpRUFBY0EsQ0FBQ2dDLE9BQU87WUFDdEJmLFVBQVVwQiwwRUFBdUJBLENBQUNtQyxNQUFNakI7UUFDNUMsT0FDSyxJQUFJcEIsbUVBQWVBLENBQUNxQyxPQUFPO1lBQzVCZixVQUFVdkIsd0VBQW9CQSxDQUFDc0MsTUFBTWpCO1FBQ3pDLE9BQ0s7WUFDRHhCLCtEQUFjQSxDQUFDLE9BQU8sdUJBQXVCLFFBQVE7UUFDekQ7UUFDQSxPQUFPZ0IsT0FBTyxDQUFDYyxXQUFXLENBQUNKO0lBQy9CO0lBQ0E7Ozs7O0tBS0MsR0FDRCxPQUFPa0IsYUFBYXpCLFFBQVEsRUFBRTtRQUMxQixNQUFNZ0IsU0FBU2pDLHNEQUFZQSxDQUFDMEMsWUFBWTtRQUN4QyxJQUFJekIsVUFBVTtZQUNWLE9BQU9nQixPQUFPYixPQUFPLENBQUNIO1FBQzFCO1FBQ0EsT0FBT2dCO0lBQ1g7SUFDQTs7S0FFQyxHQUNELE9BQU9VLFdBQVdDLE1BQU0sRUFBRTNCLFFBQVEsRUFBRTtRQUNoQyxNQUFNZ0IsU0FBU2pDLHNEQUFZQSxDQUFDMkMsVUFBVSxDQUFDQztRQUN2QyxJQUFJM0IsVUFBVTtZQUNWLE9BQU9nQixPQUFPYixPQUFPLENBQUNIO1FBQzFCO1FBQ0EsT0FBT2dCO0lBQ1g7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L3dhbGxldC5qcz8wMzNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFzZVdhbGxldCB9IGZyb20gXCIuL2Jhc2Utd2FsbGV0LmpzXCI7XG5pbXBvcnQgeyBIRE5vZGVXYWxsZXQgfSBmcm9tIFwiLi9oZHdhbGxldC5qc1wiO1xuaW1wb3J0IHsgZGVjcnlwdENyb3dkc2FsZUpzb24sIGlzQ3Jvd2RzYWxlSnNvbiB9IGZyb20gXCIuL2pzb24tY3Jvd2RzYWxlLmpzXCI7XG5pbXBvcnQgeyBkZWNyeXB0S2V5c3RvcmVKc29uLCBkZWNyeXB0S2V5c3RvcmVKc29uU3luYywgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIGlzS2V5c3RvcmVKc29uIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xuaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tIFwiLi9tbmVtb25pYy5qc1wiO1xuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcbn1cbi8qKlxuICogIEEgKipXYWxsZXQqKiBtYW5hZ2VzIGEgc2luZ2xlIHByaXZhdGUga2V5IHdoaWNoIGlzIHVzZWQgdG8gc2lnblxuICogIHRyYW5zYWN0aW9ucywgbWVzc2FnZXMgYW5kIG90aGVyIGNvbW1vbiBwYXlsb2Fkcy5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGRldmVsb3BlcnNcbiAqICB0aGF0IHdpc2ggdG8gdXNlIGEgcHJpdmF0ZSBrZXkgZGlyZWN0bHksIGFzIGl0IGNhbiBjcmVhdGVcbiAqICBpbnN0YW5jZXMgZnJvbSBhIGxhcmdlIHZhcmlldHkgb2YgY29tbW9uIHNvdXJjZXMsIGluY2x1ZGluZ1xuICogIHJhdyBwcml2YXRlIGtleSwgW1tsaW5rLWJpcC0zOV1dIG1uZW1vbmljcyBhbmQgZW5jcnlwdGUgSlNPTlxuICogIHdhbGxldHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWxsZXQgZXh0ZW5kcyBCYXNlV2FsbGV0IHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IHdhbGxldCBmb3IgdGhlIHByaXZhdGUgJSVrZXklJSwgb3B0aW9uYWxseSBjb25uZWN0ZWRcbiAgICAgKiAgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIiAmJiAha2V5LnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAga2V5ID0gXCIweFwiICsga2V5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduaW5nS2V5ID0gKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikgPyBuZXcgU2lnbmluZ0tleShrZXkpIDoga2V5O1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcy5zaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXB0ZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzc0NhbGxiYWNrJSUgaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlY2VpdmUgcGVyaW9kaWNcbiAgICAgKiAgdXBkYXRlcyBhcyB0aGUgZW5jcnlwdGlvbiBwcm9jZXNzIHByb2dyZXNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0KHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIHJldHVybiBhd2FpdCBlbmNyeXB0S2V5c3RvcmVKc29uKGFjY291bnQsIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCk7XG4gICAgfVxuICAgIHN0YXRpYyAjZnJvbUFjY291bnQoYWNjb3VudCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChhY2NvdW50LCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBpZiAoXCJtbmVtb25pY1wiIGluIGFjY291bnQgJiYgYWNjb3VudC5tbmVtb25pYyAmJiBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSA9PT0gXCJlblwiKSB7XG4gICAgICAgICAgICBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLmZyb21FbnRyb3B5KGFjY291bnQubW5lbW9uaWMuZW50cm9weSk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBhY2NvdW50Lm1uZW1vbmljLnBhdGgpO1xuICAgICAgICAgICAgaWYgKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MgJiYgd2FsbGV0LnByaXZhdGVLZXkgPT09IGFjY291bnQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IEpTT04gbWlzbWF0Y2ggYWRkcmVzcy9wcml2YXRlS2V5ICE9IG1uZW1vbmljOyBmYWxsYmFjayBvbnRvIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQoYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcywgXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyAoYXN5bmNocm9ub3VzbHkpIGEgKipXYWxsZXQqKiBieSBkZWNyeXB0aW5nIHRoZSAlJWpzb24lJVxuICAgICAqICB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzJSUgaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nXG4gICAgICogIGRlY3J5cHRpb24gc28gdGhhdCBhbnkgVUkgY2FuIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21FbmNyeXB0ZWRKc29uKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzcykge1xuICAgICAgICBsZXQgYWNjb3VudCA9IG51bGw7XG4gICAgICAgIGlmIChpc0tleXN0b3JlSnNvbihqc29uKSkge1xuICAgICAgICAgICAgYWNjb3VudCA9IGF3YWl0IGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Nyb3dkc2FsZUpzb24oanNvbikpIHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzKDApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIFtbZnJvbUVuY3J5cHRlZEpzb25dXSBtZXRob2QgaXMgcHJlZmVycmVkLCBhcyB0aGlzIG1ldGhvZFxuICAgICAqICB3aWxsIGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgZHVyaW5nIGRlY3J5cHRpb24sIHdoaWNoIG1heSB0YWtlXG4gICAgICogIHNvbWUgdGltZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVuY3J5cHRlZEpzb25TeW5jKGpzb24sIHBhc3N3b3JkKSB7XG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzS2V5c3RvcmVKc29uKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdEtleXN0b3JlSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3Jvd2RzYWxlSnNvbihqc29uKSkge1xuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gW1tIRE5vZGVXYWxsZXRdXSB1c2luZyB0aGUgYXZhdmlsYWJsZVxuICAgICAqICBbY3J5cHRvZ3JhcGhpYyByYW5kb20gc291cmNlXShyYW5kb21CeXRlcykuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlcmUgaXMgbm8gY3J5dG9ncmFwaGljIHJhbmRvbSBzb3VyY2UsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmFuZG9tKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IEhETm9kZVdhbGxldC5jcmVhdGVSYW5kb20oKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0LmNvbm5lY3QocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgW1tIRE5vZGVXYWxsZXRdXSBmb3IgJSVwaHJhc2UlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IEhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldC5qcy5tYXAiXSwibmFtZXMiOlsiU2lnbmluZ0tleSIsImFzc2VydEFyZ3VtZW50IiwiQmFzZVdhbGxldCIsIkhETm9kZVdhbGxldCIsImRlY3J5cHRDcm93ZHNhbGVKc29uIiwiaXNDcm93ZHNhbGVKc29uIiwiZGVjcnlwdEtleXN0b3JlSnNvbiIsImRlY3J5cHRLZXlzdG9yZUpzb25TeW5jIiwiZW5jcnlwdEtleXN0b3JlSnNvbiIsImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jIiwiaXNLZXlzdG9yZUpzb24iLCJNbmVtb25pYyIsInN0YWxsIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJXYWxsZXQiLCJjb25zdHJ1Y3RvciIsImtleSIsInByb3ZpZGVyIiwic3RhcnRzV2l0aCIsInNpZ25pbmdLZXkiLCJjb25uZWN0IiwiZW5jcnlwdCIsInBhc3N3b3JkIiwicHJvZ3Jlc3NDYWxsYmFjayIsImFjY291bnQiLCJhZGRyZXNzIiwicHJpdmF0ZUtleSIsImVuY3J5cHRTeW5jIiwiZnJvbUFjY291bnQiLCJtbmVtb25pYyIsImxvY2FsZSIsImZyb21FbnRyb3B5IiwiZW50cm9weSIsIndhbGxldCIsImZyb21NbmVtb25pYyIsInBhdGgiLCJjb25zb2xlIiwibG9nIiwiZnJvbUVuY3J5cHRlZEpzb24iLCJqc29uIiwicHJvZ3Jlc3MiLCJmcm9tRW5jcnlwdGVkSnNvblN5bmMiLCJjcmVhdGVSYW5kb20iLCJmcm9tUGhyYXNlIiwicGhyYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wallet/wallet.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wordlists/decode-owl.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wordlists/decode-owl.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeOwl: () => (/* binding */ decodeOwl)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n\nconst subsChrs = \" !#$%&'()*+,-./<=>?@[]^_`{|}~\";\nconst Word = /^[a-z]*$/i;\nfunction unfold(words, sep) {\n    let initial = 97;\n    return words.reduce((accum, word)=>{\n        if (word === sep) {\n            initial++;\n        } else if (word.match(Word)) {\n            accum.push(String.fromCharCode(initial) + word);\n        } else {\n            initial = 97;\n            accum.push(word);\n        }\n        return accum;\n    }, []);\n}\n/**\n *  @_ignore\n */ function decode(data, subs) {\n    // Replace all the substitutions with their expanded form\n    for(let i = subsChrs.length - 1; i >= 0; i--){\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\n    }\n    // Get all tle clumps; each suffix, first-increment and second-increment\n    const clumps = [];\n    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word)=>{\n        if (semi) {\n            for(let i = parseInt(semi); i >= 0; i--){\n                clumps.push(\";\");\n            }\n        } else {\n            clumps.push(item.toLowerCase());\n        }\n        return \"\";\n    });\n    /* c8 ignore start */ if (leftover) {\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);\n    }\n    /* c8 ignore stop */ return unfold(unfold(clumps, \";\"), \":\");\n}\n/**\n *  @_ignore\n */ function decodeOwl(data) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(data[0] === \"0\", \"unsupported auwl data\", \"data\", data);\n    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));\n} //# sourceMappingURL=decode-owl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy9kZWNvZGUtb3dsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtRDtBQUNuRCxNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLE9BQU87QUFDYixTQUFTQyxPQUFPQyxLQUFLLEVBQUVDLEdBQUc7SUFDdEIsSUFBSUMsVUFBVTtJQUNkLE9BQU9GLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztRQUN4QixJQUFJQSxTQUFTSixLQUFLO1lBQ2RDO1FBQ0osT0FDSyxJQUFJRyxLQUFLQyxLQUFLLENBQUNSLE9BQU87WUFDdkJNLE1BQU1HLElBQUksQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDUCxXQUFXRztRQUM5QyxPQUNLO1lBQ0RILFVBQVU7WUFDVkUsTUFBTUcsSUFBSSxDQUFDRjtRQUNmO1FBQ0EsT0FBT0Q7SUFDWCxHQUFHLEVBQUU7QUFDVDtBQUNBOztDQUVDLEdBQ00sU0FBU00sT0FBT0MsSUFBSSxFQUFFQyxJQUFJO0lBQzdCLHlEQUF5RDtJQUN6RCxJQUFLLElBQUlDLElBQUloQixTQUFTaUIsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztRQUMzQ0YsT0FBT0EsS0FBS0ksS0FBSyxDQUFDbEIsUUFBUSxDQUFDZ0IsRUFBRSxFQUFFRyxJQUFJLENBQUNKLEtBQUtLLFNBQVMsQ0FBQyxJQUFJSixHQUFHLElBQUlBLElBQUk7SUFDdEU7SUFDQSx3RUFBd0U7SUFDeEUsTUFBTUssU0FBUyxFQUFFO0lBQ2pCLE1BQU1DLFdBQVdSLEtBQUtTLE9BQU8sQ0FBQyw4QkFBOEIsQ0FBQ0MsS0FBS0MsTUFBTUMsTUFBTWxCO1FBQzFFLElBQUlrQixNQUFNO1lBQ04sSUFBSyxJQUFJVixJQUFJVyxTQUFTRCxPQUFPVixLQUFLLEdBQUdBLElBQUs7Z0JBQ3RDSyxPQUFPWCxJQUFJLENBQUM7WUFDaEI7UUFDSixPQUNLO1lBQ0RXLE9BQU9YLElBQUksQ0FBQ2UsS0FBS0csV0FBVztRQUNoQztRQUNBLE9BQU87SUFDWDtJQUNBLG1CQUFtQixHQUNuQixJQUFJTixVQUFVO1FBQ1YsTUFBTSxJQUFJTyxNQUFNLENBQUMsV0FBVyxFQUFFQyxLQUFLQyxTQUFTLENBQUNULFVBQVUsQ0FBQztJQUM1RDtJQUNBLGtCQUFrQixHQUNsQixPQUFPcEIsT0FBT0EsT0FBT21CLFFBQVEsTUFBTTtBQUN2QztBQUNBOztDQUVDLEdBQ00sU0FBU1csVUFBVWxCLElBQUk7SUFDMUJmLCtEQUFjQSxDQUFDZSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUsseUJBQXlCLFFBQVFBO0lBQ2pFLE9BQU9ELE9BQU9DLEtBQUtNLFNBQVMsQ0FBQyxJQUFJLElBQUlwQixTQUFTaUIsTUFBTSxHQUFHSCxLQUFLTSxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUlwQixTQUFTaUIsTUFBTTtBQUNwRyxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2RlY29kZS1vd2wuanM/ZDY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3Qgc3Vic0NocnMgPSBcIiAhIyQlJicoKSorLC0uLzw9Pj9AW11eX2B7fH1+XCI7XG5jb25zdCBXb3JkID0gL15bYS16XSokL2k7XG5mdW5jdGlvbiB1bmZvbGQod29yZHMsIHNlcCkge1xuICAgIGxldCBpbml0aWFsID0gOTc7XG4gICAgcmV0dXJuIHdvcmRzLnJlZHVjZSgoYWNjdW0sIHdvcmQpID0+IHtcbiAgICAgICAgaWYgKHdvcmQgPT09IHNlcCkge1xuICAgICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdvcmQubWF0Y2goV29yZCkpIHtcbiAgICAgICAgICAgIGFjY3VtLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpbml0aWFsKSArIHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbCA9IDk3O1xuICAgICAgICAgICAgYWNjdW0ucHVzaCh3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgW10pO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBzdWJzKSB7XG4gICAgLy8gUmVwbGFjZSBhbGwgdGhlIHN1YnN0aXR1dGlvbnMgd2l0aCB0aGVpciBleHBhbmRlZCBmb3JtXG4gICAgZm9yIChsZXQgaSA9IHN1YnNDaHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KHN1YnNDaHJzW2ldKS5qb2luKHN1YnMuc3Vic3RyaW5nKDIgKiBpLCAyICogaSArIDIpKTtcbiAgICB9XG4gICAgLy8gR2V0IGFsbCB0bGUgY2x1bXBzOyBlYWNoIHN1ZmZpeCwgZmlyc3QtaW5jcmVtZW50IGFuZCBzZWNvbmQtaW5jcmVtZW50XG4gICAgY29uc3QgY2x1bXBzID0gW107XG4gICAgY29uc3QgbGVmdG92ZXIgPSBkYXRhLnJlcGxhY2UoLyg6fChbMC05XSl8KFtBLVpdW2Etel0qKSkvZywgKGFsbCwgaXRlbSwgc2VtaSwgd29yZCkgPT4ge1xuICAgICAgICBpZiAoc2VtaSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KHNlbWkpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNsdW1wcy5wdXNoKFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsdW1wcy5wdXNoKGl0ZW0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSk7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGxlZnRvdmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbGVmdG92ZXJzOiAke0pTT04uc3RyaW5naWZ5KGxlZnRvdmVyKX1gKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICByZXR1cm4gdW5mb2xkKHVuZm9sZChjbHVtcHMsIFwiO1wiKSwgXCI6XCIpO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU93bChkYXRhKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGF0YVswXSA9PT0gXCIwXCIsIFwidW5zdXBwb3J0ZWQgYXV3bCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSwgZGF0YS5zdWJzdHJpbmcoMSwgMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1vd2wuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydEFyZ3VtZW50Iiwic3Vic0NocnMiLCJXb3JkIiwidW5mb2xkIiwid29yZHMiLCJzZXAiLCJpbml0aWFsIiwicmVkdWNlIiwiYWNjdW0iLCJ3b3JkIiwibWF0Y2giLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGVjb2RlIiwiZGF0YSIsInN1YnMiLCJpIiwibGVuZ3RoIiwic3BsaXQiLCJqb2luIiwic3Vic3RyaW5nIiwiY2x1bXBzIiwibGVmdG92ZXIiLCJyZXBsYWNlIiwiYWxsIiwiaXRlbSIsInNlbWkiLCJwYXJzZUludCIsInRvTG93ZXJDYXNlIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVjb2RlT3dsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wordlists/decode-owl.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wordlists/lang-en.js":
/*!**************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wordlists/lang-en.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangEn: () => (/* binding */ LangEn)\n/* harmony export */ });\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n\nconst words = \"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";\nconst checksum = \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangEn extends _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__.WordlistOwl {\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"en\", words, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangEn``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangEn();\n        }\n        return wordlist;\n    }\n} //# sourceMappingURL=lang-en.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy9sYW5nLWVuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdEO0FBQ2hELE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxXQUFXO0FBQ2pCLElBQUlDLFdBQVc7QUFDZjs7OztDQUlDLEdBQ00sTUFBTUMsZUFBZUoseURBQVdBO0lBQ25DOzs7Ozs7O0tBT0MsR0FDREssYUFBYztRQUFFLEtBQUssQ0FBQyxNQUFNSixPQUFPQztJQUFXO0lBQzlDOzs7S0FHQyxHQUNELE9BQU9DLFdBQVc7UUFDZCxJQUFJQSxZQUFZLE1BQU07WUFDbEJBLFdBQVcsSUFBSUM7UUFDbkI7UUFDQSxPQUFPRDtJQUNYO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy9sYW5nLWVuLmpzPzNmNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV29yZGxpc3RPd2wgfSBmcm9tIFwiLi93b3JkbGlzdC1vd2wuanNcIjtcbmNvbnN0IHdvcmRzID0gXCIwZXJsZW9uYWxvcmVuc2VpbmNlcmVnZXN0aWNpdFN0YW52ZXRlYXJjdHNzaSNjaDJBdGhjayZ0bmVMbDBBbmQjSWwueUxlT3V0Tz1TfFMlYi9yYUBTdXJkVScwQ2VbQ2lkfENvdW50Q3UnSGllPUlkT3UsLVF1aSpSb1tUVF1UJVQqW1R1JDBBcHRERC10RCpbSnUsTS5VbHRWPClWaSkwUm9iLTBGYWlyRiVkUmFpZDBBKEVFbnRSZWUwRWFkME1SUnAldFMhX3JtQnVtQ29ob2xFcnRJJkxMZXlMb3dNbyxPfVBoYVJlYWR5U29UIFdheXMwQT51ckF6KGdPbmdPdW50VSdkMEFseSxDaCVDaXxHIEchR3J5SW0kSyFOb3VuKU51JE9gIFN3IFQmbmFUaXF1ZVhpZXR5WTFBcnRPbG9neVBlP1AhUHJvPVJpbDFDaEN0LUVhRW5hR3VlTU1lZE0lTXlPdW5kUjwrUmUsUmk9Um93VFRlZmFAVGksVHclazBLUGVAU2F1bHRTZXRTaSxTdW1lVGhtYTBIIT5PbVRhe1QmZFQudWRlVHJhQDBDdF1ELkd1LE50VGglVG9UdW1uMEVyYStPY2Fkb09pZDBBa2VBKkF5RXNvbWVGdWxLdz9kMElzOkJ5Q2hlbCVDI0QrR0w8KUxjI3l+TWJvb048YU5uIFJSZWx5UmdhKFIqbFNlUy1Ta2V0VHQhM0FeQW5BdXR5Q2F1J0NvbWVFZkYlZUcoSGE9SChkTGllPUxvd0x0Tl5OZWYuL1RyYXlUdCBUd2UmWSNkM0N5YyFES2VOZE9sb2d5UmRSYFR0IF97QWRlQW1lQW5rZXRBLEVha0VbSW5kT29kT1tvbU91J1VlVXJVc2hfcmRBdER5SWxNYk5lTnVzT2tPLFJkIFIoZ1Jyb3dTc1R0b21VbilYWV97ZXRBKEFuZEFbQT1FYWRFZXplSXtJZCtJZWZJZ2h0SW5nSXNrT2Njb2xpT2smT256ZU9vbU9gIE93blVzaDJCYiFEZHlEK3RGZiRvSWxkTGJMa0whdE5kIU5rIFJkJlJnIFIsU1MoZVtTeVR0IFkgWno6QmJhK0IoQiFDdHVzR2VLZX5MbU0gYU1wTk4kTilsTmR5Tm4jTm9lTnZhc055I1BhYiFQLiRQdGEoUlJiI1JkUmdvUnBldFJyeVJ0U2VTaFMoby8hU3UkVFQkb2dUXlRlZyV5VHQhVWdodFUnVXRdVmUzSWwoZ0wgeU18TnN1c050dXJ5UmUkUnRhKF9pckFsa0FtcF1BbitBb3NBcHQgQXIrQSdBdEVhcEV7RWUnRWZFcnJ5RSxJeyZJZWZJbGRJbX15T2kpT28nUiMtVXshVW5rVXJuMEc/Tm5hbSNSYyFUaXomVHlWaWxfaW1BcEFyaWZ5QXdBeUU8RXJrRXYgSXtJfElmZkltYkluLUlwT3tPZ08nT2BPdWRPd25VYlVtcFUsIFV0Xl9eQSxDI3V0RGVGZmVlSWxJbkwhQEwlTHVtbk1iKGVNZU1mJXRNLU1tI01wPHlOYyB0TmR1QE5maXJtTmcqW059QE5zaWQgTnRyb2xOdigpT2tPbFBwIFB5UiRSZVJuUipAL1R0I1VeVW50cnlVcCFVcidVcyhWIFlvPl97QWQhQWZ0QW1BfUFzaEF0IEF3bEF6eUVhbUVkLkVla0V3SXtldEltZUlzcEl0LU9wT1tPdV5Pd2RVY2kkVWVsVWknVW1iIVVuXlVzaFlZLCQyQmVMdHUqUFBibz9kUmlvdXNScnxSdGEoUj1TaF0vb21UZTNDITpETWErTXBOKU5nIFIoZ1NoVWdodCBXblkzQWxCYT5CcmlzQ2FkZUNlbWIgQ2lkZUNsKGVDJWE+QyphJ0VyRiYnRihlRnlHKmVMYXlMaXYgTTxkTWknTmkkTnRpLE55UD90UCZkUG9zLlBgUHV0eVJpPVNjcmliZVMgdFNpZ25Ta1NwYWlyL3JveVRhaWxUZUBWZWxvcFZpKVZvPjNBZ3JhbUFsQW0jZEFyeUNlRSdsRXRGZiBHLiRHbi55TGVtbWFObiBOb3NhdXJSZUBSdFNhZyplU2NvdiBTZWEnU2hTbWlbUyVkIFNwbGF5LzwpViB0VmlkZVYlKVp6eTVDdCVDdW18R35McGgoTWEoTmE+TmtleU4lT3JTZVViIVZlX2Z0QWcjQW1hQSwtQXdFYW1FW0lmdElsbElua0lwST1PcFVtWTJDa01iTmVSKGcvVF5UeTFBcmYxTmFtLTpHIEchUmx5Um5SYFNpbHkvU3kxSG9PbG9neU9ub215MEdlSXRVY2E+MUYldDBHMUdodFRoIDJCb3dEIEVAci1FZzx0RW18RXBoPHRFdmF0JUk+U2UwQj9rQm9keUJyYSlFcitPdF1QbG95UG93IFB0eTBBYiFBQEREIVtEJSdFbXlFcmd5RiUpR2ErRyhlSDwpSm95TGksT3VnaFItaFJvbGxTdSpUIFRpKlRyeVZlbG9wZTFJc29kZTBVJFVpcDBBQSdPZGVPc11SJVVwdDBDYXBlU2F5UyYpVGE+MEVybiRILXMxSWQmKUlsT2tlT2w9MUFAQW1wIUNlW0NoPCtDLmVDbHVkZUN1J0VjdT5FcmNpJ0hhdSxIaWIuSSFJLEl0T3QtUDxkUGVAUGkqUGxhKFBvJ1AqW1QmZFRyYTBFRWJyb3c6QnItQ2VDdWx0eURlSW50SWB+TCdNZU1pbHlNb3VzTk5jeU50YXN5Um1TaF1UVCRUaCBUaWd1ZVVsdFYlLmUzQXR1KkJydT95RCAkRUVkRWxNYSFOKS9pdiRUXlYgVzNCIEN0XUVsZEd1KkxlTG1MdCBOJE5kTmVOZyBOaXNoUmVSbVIsU2MkU2hUVH1bWF9nQW1lQXNoQXRBdiVFZUlnaHRJcE9hdE97TyVPdyBVaWRVc2hZX21DdXNHSWxMZH5vd09kT3RSKVJlLFIrdFJrUnR1fVJ1bVJ3P2RTc2lsLyBVbmRYX2dpIUFtZUVxdXxFc2hJJmRJbitPZ09udE8sT3duT3omVS4yRWxOTm55Um5hKVJ5VHUqOkQrdEluTGF4eX4geU1lUFJhK1JiYStSZCZSbC1SbXxTU3BUZVRoIFUrWmUzTiAkTml1c04qTnQhTnUoZS91KjJPLDBBbnRGdEdnIU5nIFJhZmZlUmxWZV9kQW4pQSpBW0lkZUltcCdPYmVPb21PcnlPPU93VWVfdERkZVtMZE9kTydSaWxsYVNwZWxTc2lwViBuV25fYkEpQShBbnRBcGVBW0F2LnlFYXRFJklkSWVmSXRPYyB5T3VwT3dVbnRfcmRFW0lkZUlsdEl0P04zTTpCLklyTGZNbSBNLCBOZFBweVJiJVJkUnNoUj0sVFZlV2taP2QzQWRBbGBBcnRBdnlEK2hvZ0lnaHR+b0xtZXRMcE5SbzNEZCZHaH5OdFBSZS8leTVCYnlDa2V5TGRMZUxpZGF5fm93TWVOZXlPZFBlUm5SciVSJ1NwLiQvVGVsVXJWIDVCR2VNPE1iIU0lTmQqZE5ncnlOdFJkIVJyeVJ0U2I8ZDNCcmlkOjFFT24wRWFFbnRpZnlMZTJOJWU0TExlZyRMfVswQStJdGE+TSYnTXV9UGFAUG8nUHJvPVB1bCcwQ2hDbHVkZUNvbWVDKmEnRGV4RC1hPkRvJUR1LHJ5Rjx0RmwtdEYlbUhhIUggLkl0aSRKZUBKdXJ5TWE+TiBOb2N8UHV0UXVpcnlTPGVTZUBTaWRlU3BpKi8kbFRhQFQgZSxUb1ZlLFYuZVZvbD0zT24wTDxkT2xhPlN1ZTBFbTFPcnk6Q2tldEd1P1JaejNBbG91c0Fuc355V2VsOUJJbktlVXJ9eVk1RCtJKU1wTmchTmklTmsvOk5nP29vM0VuRXBUXnVwWTNDa0REfXlOZE5nZG9tU3NUVF4mVGVUdCZXaTRFZUlmZU97T3c6QkJlbEIlRGQgRHlLZU1wTmd1YStQdG9wUitUIFQoVWdoVW5kcnlWYVdXbldzdS5ZIFp5M0FkIEFmQXJuQT1DdHUqRnRHRyRHJmRJc3UqTSNOZE5nYE5zT3A/ZFNzI1R0IFZlbDNBckIgdHlCcj95QyYnRmVGdEdodEtlTWJNLk5rT25RdWlkL1R0IVZlWj9kNUFkQW5CLCBDJENrRy1OZWx5TmdPcFR0IHlVZFVuK1ZlWSQ1Q2t5R2dhK01iIE4/Tl5YdXJ5M1ItczpDaChlREctR310SWRJbEluSiVLZU1tJE5OYStOZGE+TmdvTnNdTnUkUCFSYiFSXlJnKFIoZVJrZXRScmlhK1NrU3MvIFReVCBpJFRoVHJpeFR0IFhpbXVtWmUzQWRvd0FuQXN1KkF0Q2g8LUQkRGlhTG9keUx0TWIgTSV5TnRdTnVSY3lSK1IuUnJ5U2hTc2ErVCRUaG9kM0RkIURuaWdodExrfl1NLU5kTmltdW1OJU51PlJhYyFSciVTIHlTcy9ha2VYWGVkWHR1KjVCaSFEZWxEaWZ5TU18Ti4lTmtleU4sIE5gT25SJFJlUm4oZ1NxdS5vVGggVF1UJVVudGEoVSdWZVZpZTVDaEZmKExlTHRpcGx5U2MhU2V1bVNocm9vbVMtL1R1JDNTZWxmLyB5VGg6ST1NZVBrKFJyb3cveVRdVHUqM0FyQ2tFZEdhdGk9RyFASWAgUGhld1I9L1RUdyVrVXRyJFYgV3NYdDNDZUdodDVCIUknTShlZU9kIVJtJFJgU2VUYWIhVGVUaChnVGkpVmVsVzVDIT9NYiBSJ1Q6SzBFeUplQExpK1NjdSpTID1UYShWaW91czBDdXJFPFRvYiAwT3IxRkYgRmkpVCYyTDFBeTBEST1ZbXAtMEl0MENlRUkjTChlTHkxRW5FcmFJbl1QbydUXTFBbitCLkNoP2REIEQoP3lHPEl8SWcoJFBoPDBUci1oMEggMFRkbyVUIFRwdXRUc2lkZTBBbEVuRXIwTk4gMFlnJjAvIDBPfTpDdERkIUdlSXJMYSlMbU5kYU5lbE4tTmAgUCBSYWRlUnxSa1Jyb3RSdHlTc1ReVGhUaXxUcm9sVHQgblUnVmVZbXwzQSlBbnV0QXJBczx0TC08Tk4kdHlOY2lsT3AhUHAgUmZlQFJtLlJzI1QyT31PdG9SYSdZcy0kMEFub0NuLUN0dSpFKUdHZSN+TG90TmtPfSBQZS9vbFReWnphXylBfXRBLC1BPkF5RWEnRWQrVXtVZ1VuKzJFbUV0SW50TD9MZUxpKU5kTnlPbFB1bD9SdF1TLl1Tc2liIS9UYXRvVHQgeVYgdHlXZCBXIF9AaSlBaSdFZC10RWYgRXBhKkVzfEV0dHlFdnxJKUlkZUltP3lJbnRJJS55SXMjSXZhPkl6ZU9iIW1PKVtPZHUpT2YuT2dyYW1PamVAT21vPk9vZk9wIHR5T3NwIE8+QE91ZE92aWRlMkJsLURkKGd+THBMJ01wayhOXlBpbFBweVJeYSdSLnlScG8nUidTaFRaeiEzUmFtaWQ6OTlBbC55QW50dW1BcnQgRSxdSXtJdEl6Tz46QmIuQ2NvI0NlQ2tEP0Rpb0lsSW5JJ355TXBOXk5kb21OK1BpZFJlVGVUaCBWJldaJTNBZHlBbEFzI0JlbEJ1aWxkQyRsQ2VpPUNpcGVDJWRDeWMhRHUpRiFARiVtRnUnR11HKnRHdWw/SmVATGF4TGVhJ0xpZWZMeU1hKE1lbWIgTShkTW89TmQgTmV3TnRPcCZQYWlyUGVhdFBsYSlQJXRRdWkqU2N1ZVNlbWIhU2ksU291cilTcCMnU3VsdFRpKlQqYXRUdXJuVW5dVmUkVmlld1c/ZDJZYG0wQkJiI0NlQ2hEZUQrRiFHaHRHaWROZ090UHAhU2tUdSRWJFYgNUFkQSxCb3RCdSxDa2V0TTwpT2ZPa2llT21TZVRhPlVnaFVuZFU+WSQ1QmIgRGVHTGVOTndheVIkOkREZCFEfVtGZUlsTGFkTG0jTCNMdEx1Pk1lTXAhTmRUaXNmeVRvc2hpVSlVc2ErVmVZMUEhQW5BKkF0dCBFfUhlbWVIb29sSSYpSVslc09ycF1PdXRSYXBSZSZSaXB0UnViMUFBcl5BcyNBdEMjZEMqdEN0XUN1ci55RWRFa0dtfExlQH5NKD9OaSVOJ050JilSaWVzUnZpKVNzXVR0IVR1cFYmX2Rvd0FmdEFsbG93QSpFZEVsbEVyaWZmSWVsZElmdEl9SXBJdiBPe09lT290T3BPcnRPdWxkIE89UmltcFJ1Z1VmZiFZMEJsKGdDa0RlRStHaHRHbkx8TGt+eUx2IE1pbD9NcCFOKU5nUiYvIFR1YT5YWmUxQT5FdF5JSWxsSW5JcnRVbGwwQWJBbUVlcEVuZCBJKUlkZUlnaHRJbU9nPE90T3dVc2gwQWxsQXJ0SSFPa2VPb2AwQXtBa2VBcElmZk93MEFwQ2MgQ2kkQ2tEYUZ0TD9MZGkgTGlkTHV0XUw9TWUjZU5nT25ScnlSdFVsVW5kVXBVcilVYDBBKUEqQXRpJEF3bkVha0VjaSRFZWRFbGxFbmRIIGVJKUlkIElrZUluSXIuTC5PaWxPbnMlTyNPcnRPdFJheVJlYWRSKGdZMFVhKlVlZXplVWlyKmxfYiFBZGl1bUFmZkErQWlyc0FtcEFuZEFydEE+QXlFYWtFZWxFbUVwRSpvSXtJbGxJbmdPe09tYV5PfU9vbE9yeU89UmE+Z3lSZWV0UmlrZVIjZ1J1Z2chVWR8VWZmVW1iIVkhMEJqZUBCbS5Cd2F5QylbQ2hEZCZGZiBHP0crLEl0TW0gTk5ueU4ndFAgUHBseVAqbWVSZVJmYSlSK1JwcmknUnJvdW5kUj15U3BlQC9hKDFBbGxvd0FtcEFwQXJtRT9FZXRJZnRJbUluZ0l0Xk9yZDFNYm9sTXB0b21SdXAvZW06QiFDayFHSWxMfExrTmtQZVIrdFNrL2VUdG9vWGkzQV5BbX5OTjx0Tm5pc050Um0vWHRfbmtBdEVtZUVuRSV5RSpFeUluZ0lzT3VnaHRSZWVSaT1Sb3dVbWJVbmQgMENrZXREZUcgTHRNYiBNZU55UFJlZFNzdWVUITVBLEJhY2NvRGF5RGRsIEVHZWAgSSF0SyZNYXRvTSVyb3dOZU5ndWVOaWdodE9sT2BQUC1QcCFSXlJuYWRvUnRvaSdTc1QkVXJpLFc/ZFcgV25ZX3tBZGVBZmYtQWctQShBbnNmIEFwQXNoQT1sQXlFYXRFZUVuZEkkSWJlSXtJZ2cgSW1JcE9waHlPdWIhVXtVZVVseVVtcGV0VSxVYFkyQmVJdF1NYiFOYU59bFJrZXlSblJ0ITFFbD1FbnR5SSlJbkksTzFQZVAtJDo1THk1QipsbGEwQWIhQXdhKkMhQ292IEQgRG9GYWlyRm9sZEhhcHB5SWYlbUlxdWVJdEl2ICdLbm93bkxve1RpbFVzdSRWZWlsMURhPkdyYWRlSG9sZE9uUCBTZXQxQjxHZTBBK0VFZEVmdWxFIVtVJDBJbC55OkM8dEN1dW1HdWVMaWRMIXlMPU5OaXNoUCVSaW91cy9VbHQzSC0hTD10TmQlTnR1Kk51ZVJiUmlmeVJzXVJ5UydsVCA8M0FiIUJyPHRDaW91c0N0JXlEZW9Fd35hK050YStPbChSdHUkUnVzU2FTLlN1JFQkVmlkNUMkSSlJZExjPG9MdW1lVGVZYSs6R2VHI0l0TGt+TG51dE50UmZhKlJtUnJpJVNoU3AvZVQgVmVZM0FsYEFwI0FyQSdsQWAgQkRkKGdFayZkSXJkTGNvbWUvVF8hQXRFYXRFZWxFbkUqSXBJc3AgMERlRGBGZUxkfk5OZG93TmVOZ05rTm4gTnQgUmVTZG9tU2VTaFR9WzVMZk08TmQgT2RPbFJkUmtSbGRScnlSYF9wRXtFLCFJLEk+T25nOjpSZDNBcn5vdzlVVW5nVWA6M0JyYVJvOU5lT1wiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktZW5dXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmdFbiBleHRlbmRzIFdvcmRsaXN0T3dsIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgRW5nbGlzaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdFbl1dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImVuXCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0VuYGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdFbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVuLmpzLm1hcCJdLCJuYW1lcyI6WyJXb3JkbGlzdE93bCIsIndvcmRzIiwiY2hlY2tzdW0iLCJ3b3JkbGlzdCIsIkxhbmdFbiIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wordlists/lang-en.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wordlists/wordlist-owl.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wordlists/wordlist-owl.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WordlistOwl: () => (/* binding */ WordlistOwl)\n/* harmony export */ });\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _decode_owl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode-owl.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wordlists/decode-owl.js\");\n/* harmony import */ var _wordlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist.js */ \"(rsc)/../../node_modules/ethers/lib.esm/wordlists/wordlist.js\");\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\n\n\n\n\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */ class WordlistOwl extends _wordlist_js__WEBPACK_IMPORTED_MODULE_0__.Wordlist {\n    #data;\n    #checksum;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */ constructor(locale, data, checksum){\n        super(locale);\n        this.#data = data;\n        this.#checksum = checksum;\n        this.#words = null;\n    }\n    /**\n     *  The OWL-encoded data.\n     */ get _data() {\n        return this.#data;\n    }\n    /**\n     *  Decode all the words for the wordlist.\n     */ _decodeWords() {\n        return (0,_decode_owl_js__WEBPACK_IMPORTED_MODULE_1__.decodeOwl)(this.#data);\n    }\n    #words;\n    #loadWords() {\n        if (this.#words == null) {\n            const words = this._decodeWords();\n            // Verify the computed list matches the official list\n            const checksum = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.id)(words.join(\"\\n\") + \"\\n\");\n            /* c8 ignore start */ if (checksum !== this.#checksum) {\n                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\n            }\n            /* c8 ignore stop */ this.#words = words;\n        }\n        return this.#words;\n    }\n    getWord(index) {\n        const words = this.#loadWords();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return this.#loadWords().indexOf(word);\n    }\n} //# sourceMappingURL=wordlist-owl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC1vd2wuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSx5REFBeUQ7QUFDekQsMENBQTBDO0FBQ0o7QUFDYTtBQUNQO0FBQ0g7QUFDekM7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxNQUFNSSxvQkFBb0JELGtEQUFRQTtJQUNyQyxDQUFDRSxJQUFJLENBQUM7SUFDTixDQUFDQyxRQUFRLENBQUM7SUFDVjs7O0tBR0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFSCxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUNoQyxLQUFLLENBQUNFO1FBQ04sSUFBSSxDQUFDLENBQUNILElBQUksR0FBR0E7UUFDYixJQUFJLENBQUMsQ0FBQ0MsUUFBUSxHQUFHQTtRQUNqQixJQUFJLENBQUMsQ0FBQ0csS0FBSyxHQUFHO0lBQ2xCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxRQUFRO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0wsSUFBSTtJQUFFO0lBQ2pDOztLQUVDLEdBQ0RNLGVBQWU7UUFDWCxPQUFPVCx5REFBU0EsQ0FBQyxJQUFJLENBQUMsQ0FBQ0csSUFBSTtJQUMvQjtJQUNBLENBQUNJLEtBQUssQ0FBQztJQUNQLENBQUNHLFNBQVM7UUFDTixJQUFJLElBQUksQ0FBQyxDQUFDSCxLQUFLLElBQUksTUFBTTtZQUNyQixNQUFNQSxRQUFRLElBQUksQ0FBQ0UsWUFBWTtZQUMvQixxREFBcUQ7WUFDckQsTUFBTUwsV0FBV04sa0RBQUVBLENBQUNTLE1BQU1JLElBQUksQ0FBQyxRQUFRO1lBQ3ZDLG1CQUFtQixHQUNuQixJQUFJUCxhQUFhLElBQUksQ0FBQyxDQUFDQSxRQUFRLEVBQUU7Z0JBQzdCLE1BQU0sSUFBSVEsTUFBTSxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQ04sTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUM5RDtZQUNBLGtCQUFrQixHQUNsQixJQUFJLENBQUMsQ0FBQ0MsS0FBSyxHQUFHQTtRQUNsQjtRQUNBLE9BQU8sSUFBSSxDQUFDLENBQUNBLEtBQUs7SUFDdEI7SUFDQU0sUUFBUUMsS0FBSyxFQUFFO1FBQ1gsTUFBTVAsUUFBUSxJQUFJLENBQUMsQ0FBQ0csU0FBUztRQUM3QlgsK0RBQWNBLENBQUNlLFNBQVMsS0FBS0EsUUFBUVAsTUFBTVEsTUFBTSxFQUFFLENBQUMsb0JBQW9CLEVBQUVELE1BQU0sQ0FBQyxFQUFFLFNBQVNBO1FBQzVGLE9BQU9QLEtBQUssQ0FBQ08sTUFBTTtJQUN2QjtJQUNBRSxhQUFhQyxJQUFJLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQyxDQUFDUCxTQUFTLEdBQUdRLE9BQU8sQ0FBQ0Q7SUFDckM7QUFDSixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL3dvcmRsaXN0LW93bC5qcz9iZjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVzZSB0aGUgZW5jb2RlLWxhdGluLmpzIHNjcmlwdCB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeVxuLy8gZGF0YSBmaWxlcyB0byBiZSBjb25zdW1lZCBieSB0aGlzIGNsYXNzXG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlT3dsIH0gZnJvbSBcIi4vZGVjb2RlLW93bC5qc1wiO1xuaW1wb3J0IHsgV29yZGxpc3QgfSBmcm9tIFwiLi93b3JkbGlzdC5qc1wiO1xuLyoqXG4gKiAgQW4gT1dMIGZvcm1hdCBXb3JkbGlzdCBpcyBhbiBlbmNvZGluZyBtZXRob2QgdGhhdCBleHBsb2l0c1xuICogIHRoZSBnZW5lcmFsIGxvY2FsaXR5IG9mIGFscGhhYmV0aWNhbGx5IHNvcnRlZCB3b3JkcyB0b1xuICogIGFjaGlldmUgYSBzaW1wbGUgYnV0IGVmZmVjdGl2ZSBtZWFucyBvZiBjb21wcmVzc2lvbi5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0byBtb3N0IGRldmVsb3BlcnMgYXNcbiAqICBpdCBpcyB1c2VkIG1haW5seSBpbnRlcm5hbGx5IHRvIGtlZXAgV29yZGxpc3RzIGZvciBsYW5ndWFnZXNcbiAqICBiYXNlZCBvbiBBU0NJSS03IHNtYWxsLlxuICpcbiAqICBJZiBuZWNlc3NhcnksIHRoZXJlIGFyZSB0b29scyB3aXRoaW4gdGhlIGBgZ2VuZXJhdGlvbi9gYCBmb2xkZXJcbiAqICB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICovXG5leHBvcnQgY2xhc3MgV29yZGxpc3RPd2wgZXh0ZW5kcyBXb3JkbGlzdCB7XG4gICAgI2RhdGE7XG4gICAgI2NoZWNrc3VtO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFdvcmRsaXN0IGZvciAlJWxvY2FsZSUlIHVzaW5nIHRoZSBPV0wgJSVkYXRhJSVcbiAgICAgKiAgYW5kIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSAlJWNoZWNrc3VtJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBkYXRhLCBjaGVja3N1bSkge1xuICAgICAgICBzdXBlcihsb2NhbGUpO1xuICAgICAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy4jY2hlY2tzdW0gPSBjaGVja3N1bTtcbiAgICAgICAgdGhpcy4jd29yZHMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIE9XTC1lbmNvZGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IF9kYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxuICAgICAqL1xuICAgIF9kZWNvZGVXb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU93bCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgI3dvcmRzO1xuICAgICNsb2FkV29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLiN3b3JkcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuX2RlY29kZVdvcmRzKCk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbXB1dGVkIGxpc3QgbWF0Y2hlcyB0aGUgb2ZmaWNpYWwgbGlzdFxuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBpZCh3b3Jkcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gdGhpcy4jY2hlY2tzdW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJJUDM5IFdvcmRsaXN0IGZvciAke3RoaXMubG9jYWxlfSBGQUlMRURgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiN3b3JkcyA9IHdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3b3JkcztcbiAgICB9XG4gICAgZ2V0V29yZChpbmRleCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuI2xvYWRXb3JkcygpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwICYmIGluZGV4IDwgd29yZHMubGVuZ3RoLCBgaW52YWxpZCB3b3JkIGluZGV4OiAke2luZGV4fWAsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd29yZHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRXb3JkSW5kZXgod29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbG9hZFdvcmRzKCkuaW5kZXhPZih3b3JkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2wuanMubWFwIl0sIm5hbWVzIjpbImlkIiwiYXNzZXJ0QXJndW1lbnQiLCJkZWNvZGVPd2wiLCJXb3JkbGlzdCIsIldvcmRsaXN0T3dsIiwiZGF0YSIsImNoZWNrc3VtIiwiY29uc3RydWN0b3IiLCJsb2NhbGUiLCJ3b3JkcyIsIl9kYXRhIiwiX2RlY29kZVdvcmRzIiwibG9hZFdvcmRzIiwiam9pbiIsIkVycm9yIiwiZ2V0V29yZCIsImluZGV4IiwibGVuZ3RoIiwiZ2V0V29yZEluZGV4Iiwid29yZCIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/lib.esm/wordlists/wordlist.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ethers/lib.esm/wordlists/wordlist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wordlist: () => (/* binding */ Wordlist)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n *  A Wordlist represents a collection of language-specific\n *  words used to encode and devoce [[link-bip-39]] encoded data\n *  by mapping words to 11-bit values and vice versa.\n */ class Wordlist {\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances of a Wordlist,\n     *  since each language-specific Wordlist creates an instance and\n     *  there is no state kept internally, so they are safe to share.\n     */ constructor(locale){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            locale\n        });\n    }\n    /**\n     *  Sub-classes may override this to provide a language-specific\n     *  method for spliting %%phrase%% into individual words.\n     *\n     *  By default, %%phrase%% is split using any sequences of\n     *  white-space as defined by regular expressions (i.e. ``/\\s+/``).\n     */ split(phrase) {\n        return phrase.toLowerCase().split(/\\s+/g);\n    }\n    /**\n     *  Sub-classes may override this to provider a language-specific\n     *  method for joining %%words%% into a phrase.\n     *\n     *  By default, %%words%% are joined by a single space.\n     */ join(words) {\n        return words.join(\" \");\n    }\n} //# sourceMappingURL=wordlist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRDtBQUNyRDs7OztDQUlDLEdBQ00sTUFBTUM7SUFFVDs7Ozs7Ozs7O0tBU0MsR0FDREMsWUFBWUMsTUFBTSxDQUFFO1FBQ2hCSCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVHO1FBQU87SUFDcEM7SUFDQTs7Ozs7O0tBTUMsR0FDREMsTUFBTUMsTUFBTSxFQUFFO1FBQ1YsT0FBT0EsT0FBT0MsV0FBVyxHQUFHRixLQUFLLENBQUM7SUFDdEM7SUFDQTs7Ozs7S0FLQyxHQUNERyxLQUFLQyxLQUFLLEVBQUU7UUFDUixPQUFPQSxNQUFNRCxJQUFJLENBQUM7SUFDdEI7QUFDSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL3dvcmRsaXN0LmpzP2U0YTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBXb3JkbGlzdCByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBsYW5ndWFnZS1zcGVjaWZpY1xuICogIHdvcmRzIHVzZWQgdG8gZW5jb2RlIGFuZCBkZXZvY2UgW1tsaW5rLWJpcC0zOV1dIGVuY29kZWQgZGF0YVxuICogIGJ5IG1hcHBpbmcgd29yZHMgdG8gMTEtYml0IHZhbHVlcyBhbmQgdmljZSB2ZXJzYS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmRsaXN0IHtcbiAgICBsb2NhbGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHRoaXMgaWYgdGhleSBwcm92aWRlIHRoZWlyIG93biBjb25zdHJ1Y3RvcixcbiAgICAgKiAgcGFzc2luZyBpbiB0aGUgbG9jYWxlIHN0cmluZyBvZiB0aGUgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiAgR2VuZXJhbGx5IHRoZXJlIGlzIG5vIG5lZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhIFdvcmRsaXN0LFxuICAgICAqICBzaW5jZSBlYWNoIGxhbmd1YWdlLXNwZWNpZmljIFdvcmRsaXN0IGNyZWF0ZXMgYW4gaW5zdGFuY2UgYW5kXG4gICAgICogIHRoZXJlIGlzIG5vIHN0YXRlIGtlcHQgaW50ZXJuYWxseSwgc28gdGhleSBhcmUgc2FmZSB0byBzaGFyZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGxvY2FsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgYSBsYW5ndWFnZS1zcGVjaWZpY1xuICAgICAqICBtZXRob2QgZm9yIHNwbGl0aW5nICUlcGhyYXNlJSUgaW50byBpbmRpdmlkdWFsIHdvcmRzLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUlcGhyYXNlJSUgaXMgc3BsaXQgdXNpbmcgYW55IHNlcXVlbmNlcyBvZlxuICAgICAqICB3aGl0ZS1zcGFjZSBhcyBkZWZpbmVkIGJ5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgKGkuZS4gYGAvXFxzKy9gYCkuXG4gICAgICovXG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBwaHJhc2UudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGVyIGEgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAgICAgKiAgbWV0aG9kIGZvciBqb2luaW5nICUld29yZHMlJSBpbnRvIGEgcGhyYXNlLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUld29yZHMlJSBhcmUgam9pbmVkIGJ5IGEgc2luZ2xlIHNwYWNlLlxuICAgICAqL1xuICAgIGpvaW4od29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiV29yZGxpc3QiLCJjb25zdHJ1Y3RvciIsImxvY2FsZSIsInNwbGl0IiwicGhyYXNlIiwidG9Mb3dlckNhc2UiLCJqb2luIiwid29yZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/lib.esm/wordlists/wordlist.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/aes.js":
/*!********************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/aes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: () => (/* binding */ AES)\n/* harmony export */ });\n/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */ var __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _AES_key, _AES_Kd, _AES_Ke;\n// Number of rounds by keysize\nconst numberOfRounds = {\n    16: 10,\n    24: 12,\n    32: 14\n};\n// Round constant words\nconst rcon = [\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a,\n    0x2f,\n    0x5e,\n    0xbc,\n    0x63,\n    0xc6,\n    0x97,\n    0x35,\n    0x6a,\n    0xd4,\n    0xb3,\n    0x7d,\n    0xfa,\n    0xef,\n    0xc5,\n    0x91\n];\n// S-box and Inverse S-box (S is for Substitution)\nconst S = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\nconst Si = [\n    0x52,\n    0x09,\n    0x6a,\n    0xd5,\n    0x30,\n    0x36,\n    0xa5,\n    0x38,\n    0xbf,\n    0x40,\n    0xa3,\n    0x9e,\n    0x81,\n    0xf3,\n    0xd7,\n    0xfb,\n    0x7c,\n    0xe3,\n    0x39,\n    0x82,\n    0x9b,\n    0x2f,\n    0xff,\n    0x87,\n    0x34,\n    0x8e,\n    0x43,\n    0x44,\n    0xc4,\n    0xde,\n    0xe9,\n    0xcb,\n    0x54,\n    0x7b,\n    0x94,\n    0x32,\n    0xa6,\n    0xc2,\n    0x23,\n    0x3d,\n    0xee,\n    0x4c,\n    0x95,\n    0x0b,\n    0x42,\n    0xfa,\n    0xc3,\n    0x4e,\n    0x08,\n    0x2e,\n    0xa1,\n    0x66,\n    0x28,\n    0xd9,\n    0x24,\n    0xb2,\n    0x76,\n    0x5b,\n    0xa2,\n    0x49,\n    0x6d,\n    0x8b,\n    0xd1,\n    0x25,\n    0x72,\n    0xf8,\n    0xf6,\n    0x64,\n    0x86,\n    0x68,\n    0x98,\n    0x16,\n    0xd4,\n    0xa4,\n    0x5c,\n    0xcc,\n    0x5d,\n    0x65,\n    0xb6,\n    0x92,\n    0x6c,\n    0x70,\n    0x48,\n    0x50,\n    0xfd,\n    0xed,\n    0xb9,\n    0xda,\n    0x5e,\n    0x15,\n    0x46,\n    0x57,\n    0xa7,\n    0x8d,\n    0x9d,\n    0x84,\n    0x90,\n    0xd8,\n    0xab,\n    0x00,\n    0x8c,\n    0xbc,\n    0xd3,\n    0x0a,\n    0xf7,\n    0xe4,\n    0x58,\n    0x05,\n    0xb8,\n    0xb3,\n    0x45,\n    0x06,\n    0xd0,\n    0x2c,\n    0x1e,\n    0x8f,\n    0xca,\n    0x3f,\n    0x0f,\n    0x02,\n    0xc1,\n    0xaf,\n    0xbd,\n    0x03,\n    0x01,\n    0x13,\n    0x8a,\n    0x6b,\n    0x3a,\n    0x91,\n    0x11,\n    0x41,\n    0x4f,\n    0x67,\n    0xdc,\n    0xea,\n    0x97,\n    0xf2,\n    0xcf,\n    0xce,\n    0xf0,\n    0xb4,\n    0xe6,\n    0x73,\n    0x96,\n    0xac,\n    0x74,\n    0x22,\n    0xe7,\n    0xad,\n    0x35,\n    0x85,\n    0xe2,\n    0xf9,\n    0x37,\n    0xe8,\n    0x1c,\n    0x75,\n    0xdf,\n    0x6e,\n    0x47,\n    0xf1,\n    0x1a,\n    0x71,\n    0x1d,\n    0x29,\n    0xc5,\n    0x89,\n    0x6f,\n    0xb7,\n    0x62,\n    0x0e,\n    0xaa,\n    0x18,\n    0xbe,\n    0x1b,\n    0xfc,\n    0x56,\n    0x3e,\n    0x4b,\n    0xc6,\n    0xd2,\n    0x79,\n    0x20,\n    0x9a,\n    0xdb,\n    0xc0,\n    0xfe,\n    0x78,\n    0xcd,\n    0x5a,\n    0xf4,\n    0x1f,\n    0xdd,\n    0xa8,\n    0x33,\n    0x88,\n    0x07,\n    0xc7,\n    0x31,\n    0xb1,\n    0x12,\n    0x10,\n    0x59,\n    0x27,\n    0x80,\n    0xec,\n    0x5f,\n    0x60,\n    0x51,\n    0x7f,\n    0xa9,\n    0x19,\n    0xb5,\n    0x4a,\n    0x0d,\n    0x2d,\n    0xe5,\n    0x7a,\n    0x9f,\n    0x93,\n    0xc9,\n    0x9c,\n    0xef,\n    0xa0,\n    0xe0,\n    0x3b,\n    0x4d,\n    0xae,\n    0x2a,\n    0xf5,\n    0xb0,\n    0xc8,\n    0xeb,\n    0xbb,\n    0x3c,\n    0x83,\n    0x53,\n    0x99,\n    0x61,\n    0x17,\n    0x2b,\n    0x04,\n    0x7e,\n    0xba,\n    0x77,\n    0xd6,\n    0x26,\n    0xe1,\n    0x69,\n    0x14,\n    0x63,\n    0x55,\n    0x21,\n    0x0c,\n    0x7d\n];\n// Transformations for encryption\nconst T1 = [\n    0xc66363a5,\n    0xf87c7c84,\n    0xee777799,\n    0xf67b7b8d,\n    0xfff2f20d,\n    0xd66b6bbd,\n    0xde6f6fb1,\n    0x91c5c554,\n    0x60303050,\n    0x02010103,\n    0xce6767a9,\n    0x562b2b7d,\n    0xe7fefe19,\n    0xb5d7d762,\n    0x4dababe6,\n    0xec76769a,\n    0x8fcaca45,\n    0x1f82829d,\n    0x89c9c940,\n    0xfa7d7d87,\n    0xeffafa15,\n    0xb25959eb,\n    0x8e4747c9,\n    0xfbf0f00b,\n    0x41adadec,\n    0xb3d4d467,\n    0x5fa2a2fd,\n    0x45afafea,\n    0x239c9cbf,\n    0x53a4a4f7,\n    0xe4727296,\n    0x9bc0c05b,\n    0x75b7b7c2,\n    0xe1fdfd1c,\n    0x3d9393ae,\n    0x4c26266a,\n    0x6c36365a,\n    0x7e3f3f41,\n    0xf5f7f702,\n    0x83cccc4f,\n    0x6834345c,\n    0x51a5a5f4,\n    0xd1e5e534,\n    0xf9f1f108,\n    0xe2717193,\n    0xabd8d873,\n    0x62313153,\n    0x2a15153f,\n    0x0804040c,\n    0x95c7c752,\n    0x46232365,\n    0x9dc3c35e,\n    0x30181828,\n    0x379696a1,\n    0x0a05050f,\n    0x2f9a9ab5,\n    0x0e070709,\n    0x24121236,\n    0x1b80809b,\n    0xdfe2e23d,\n    0xcdebeb26,\n    0x4e272769,\n    0x7fb2b2cd,\n    0xea75759f,\n    0x1209091b,\n    0x1d83839e,\n    0x582c2c74,\n    0x341a1a2e,\n    0x361b1b2d,\n    0xdc6e6eb2,\n    0xb45a5aee,\n    0x5ba0a0fb,\n    0xa45252f6,\n    0x763b3b4d,\n    0xb7d6d661,\n    0x7db3b3ce,\n    0x5229297b,\n    0xdde3e33e,\n    0x5e2f2f71,\n    0x13848497,\n    0xa65353f5,\n    0xb9d1d168,\n    0x00000000,\n    0xc1eded2c,\n    0x40202060,\n    0xe3fcfc1f,\n    0x79b1b1c8,\n    0xb65b5bed,\n    0xd46a6abe,\n    0x8dcbcb46,\n    0x67bebed9,\n    0x7239394b,\n    0x944a4ade,\n    0x984c4cd4,\n    0xb05858e8,\n    0x85cfcf4a,\n    0xbbd0d06b,\n    0xc5efef2a,\n    0x4faaaae5,\n    0xedfbfb16,\n    0x864343c5,\n    0x9a4d4dd7,\n    0x66333355,\n    0x11858594,\n    0x8a4545cf,\n    0xe9f9f910,\n    0x04020206,\n    0xfe7f7f81,\n    0xa05050f0,\n    0x783c3c44,\n    0x259f9fba,\n    0x4ba8a8e3,\n    0xa25151f3,\n    0x5da3a3fe,\n    0x804040c0,\n    0x058f8f8a,\n    0x3f9292ad,\n    0x219d9dbc,\n    0x70383848,\n    0xf1f5f504,\n    0x63bcbcdf,\n    0x77b6b6c1,\n    0xafdada75,\n    0x42212163,\n    0x20101030,\n    0xe5ffff1a,\n    0xfdf3f30e,\n    0xbfd2d26d,\n    0x81cdcd4c,\n    0x180c0c14,\n    0x26131335,\n    0xc3ecec2f,\n    0xbe5f5fe1,\n    0x359797a2,\n    0x884444cc,\n    0x2e171739,\n    0x93c4c457,\n    0x55a7a7f2,\n    0xfc7e7e82,\n    0x7a3d3d47,\n    0xc86464ac,\n    0xba5d5de7,\n    0x3219192b,\n    0xe6737395,\n    0xc06060a0,\n    0x19818198,\n    0x9e4f4fd1,\n    0xa3dcdc7f,\n    0x44222266,\n    0x542a2a7e,\n    0x3b9090ab,\n    0x0b888883,\n    0x8c4646ca,\n    0xc7eeee29,\n    0x6bb8b8d3,\n    0x2814143c,\n    0xa7dede79,\n    0xbc5e5ee2,\n    0x160b0b1d,\n    0xaddbdb76,\n    0xdbe0e03b,\n    0x64323256,\n    0x743a3a4e,\n    0x140a0a1e,\n    0x924949db,\n    0x0c06060a,\n    0x4824246c,\n    0xb85c5ce4,\n    0x9fc2c25d,\n    0xbdd3d36e,\n    0x43acacef,\n    0xc46262a6,\n    0x399191a8,\n    0x319595a4,\n    0xd3e4e437,\n    0xf279798b,\n    0xd5e7e732,\n    0x8bc8c843,\n    0x6e373759,\n    0xda6d6db7,\n    0x018d8d8c,\n    0xb1d5d564,\n    0x9c4e4ed2,\n    0x49a9a9e0,\n    0xd86c6cb4,\n    0xac5656fa,\n    0xf3f4f407,\n    0xcfeaea25,\n    0xca6565af,\n    0xf47a7a8e,\n    0x47aeaee9,\n    0x10080818,\n    0x6fbabad5,\n    0xf0787888,\n    0x4a25256f,\n    0x5c2e2e72,\n    0x381c1c24,\n    0x57a6a6f1,\n    0x73b4b4c7,\n    0x97c6c651,\n    0xcbe8e823,\n    0xa1dddd7c,\n    0xe874749c,\n    0x3e1f1f21,\n    0x964b4bdd,\n    0x61bdbddc,\n    0x0d8b8b86,\n    0x0f8a8a85,\n    0xe0707090,\n    0x7c3e3e42,\n    0x71b5b5c4,\n    0xcc6666aa,\n    0x904848d8,\n    0x06030305,\n    0xf7f6f601,\n    0x1c0e0e12,\n    0xc26161a3,\n    0x6a35355f,\n    0xae5757f9,\n    0x69b9b9d0,\n    0x17868691,\n    0x99c1c158,\n    0x3a1d1d27,\n    0x279e9eb9,\n    0xd9e1e138,\n    0xebf8f813,\n    0x2b9898b3,\n    0x22111133,\n    0xd26969bb,\n    0xa9d9d970,\n    0x078e8e89,\n    0x339494a7,\n    0x2d9b9bb6,\n    0x3c1e1e22,\n    0x15878792,\n    0xc9e9e920,\n    0x87cece49,\n    0xaa5555ff,\n    0x50282878,\n    0xa5dfdf7a,\n    0x038c8c8f,\n    0x59a1a1f8,\n    0x09898980,\n    0x1a0d0d17,\n    0x65bfbfda,\n    0xd7e6e631,\n    0x844242c6,\n    0xd06868b8,\n    0x824141c3,\n    0x299999b0,\n    0x5a2d2d77,\n    0x1e0f0f11,\n    0x7bb0b0cb,\n    0xa85454fc,\n    0x6dbbbbd6,\n    0x2c16163a\n];\nconst T2 = [\n    0xa5c66363,\n    0x84f87c7c,\n    0x99ee7777,\n    0x8df67b7b,\n    0x0dfff2f2,\n    0xbdd66b6b,\n    0xb1de6f6f,\n    0x5491c5c5,\n    0x50603030,\n    0x03020101,\n    0xa9ce6767,\n    0x7d562b2b,\n    0x19e7fefe,\n    0x62b5d7d7,\n    0xe64dabab,\n    0x9aec7676,\n    0x458fcaca,\n    0x9d1f8282,\n    0x4089c9c9,\n    0x87fa7d7d,\n    0x15effafa,\n    0xebb25959,\n    0xc98e4747,\n    0x0bfbf0f0,\n    0xec41adad,\n    0x67b3d4d4,\n    0xfd5fa2a2,\n    0xea45afaf,\n    0xbf239c9c,\n    0xf753a4a4,\n    0x96e47272,\n    0x5b9bc0c0,\n    0xc275b7b7,\n    0x1ce1fdfd,\n    0xae3d9393,\n    0x6a4c2626,\n    0x5a6c3636,\n    0x417e3f3f,\n    0x02f5f7f7,\n    0x4f83cccc,\n    0x5c683434,\n    0xf451a5a5,\n    0x34d1e5e5,\n    0x08f9f1f1,\n    0x93e27171,\n    0x73abd8d8,\n    0x53623131,\n    0x3f2a1515,\n    0x0c080404,\n    0x5295c7c7,\n    0x65462323,\n    0x5e9dc3c3,\n    0x28301818,\n    0xa1379696,\n    0x0f0a0505,\n    0xb52f9a9a,\n    0x090e0707,\n    0x36241212,\n    0x9b1b8080,\n    0x3ddfe2e2,\n    0x26cdebeb,\n    0x694e2727,\n    0xcd7fb2b2,\n    0x9fea7575,\n    0x1b120909,\n    0x9e1d8383,\n    0x74582c2c,\n    0x2e341a1a,\n    0x2d361b1b,\n    0xb2dc6e6e,\n    0xeeb45a5a,\n    0xfb5ba0a0,\n    0xf6a45252,\n    0x4d763b3b,\n    0x61b7d6d6,\n    0xce7db3b3,\n    0x7b522929,\n    0x3edde3e3,\n    0x715e2f2f,\n    0x97138484,\n    0xf5a65353,\n    0x68b9d1d1,\n    0x00000000,\n    0x2cc1eded,\n    0x60402020,\n    0x1fe3fcfc,\n    0xc879b1b1,\n    0xedb65b5b,\n    0xbed46a6a,\n    0x468dcbcb,\n    0xd967bebe,\n    0x4b723939,\n    0xde944a4a,\n    0xd4984c4c,\n    0xe8b05858,\n    0x4a85cfcf,\n    0x6bbbd0d0,\n    0x2ac5efef,\n    0xe54faaaa,\n    0x16edfbfb,\n    0xc5864343,\n    0xd79a4d4d,\n    0x55663333,\n    0x94118585,\n    0xcf8a4545,\n    0x10e9f9f9,\n    0x06040202,\n    0x81fe7f7f,\n    0xf0a05050,\n    0x44783c3c,\n    0xba259f9f,\n    0xe34ba8a8,\n    0xf3a25151,\n    0xfe5da3a3,\n    0xc0804040,\n    0x8a058f8f,\n    0xad3f9292,\n    0xbc219d9d,\n    0x48703838,\n    0x04f1f5f5,\n    0xdf63bcbc,\n    0xc177b6b6,\n    0x75afdada,\n    0x63422121,\n    0x30201010,\n    0x1ae5ffff,\n    0x0efdf3f3,\n    0x6dbfd2d2,\n    0x4c81cdcd,\n    0x14180c0c,\n    0x35261313,\n    0x2fc3ecec,\n    0xe1be5f5f,\n    0xa2359797,\n    0xcc884444,\n    0x392e1717,\n    0x5793c4c4,\n    0xf255a7a7,\n    0x82fc7e7e,\n    0x477a3d3d,\n    0xacc86464,\n    0xe7ba5d5d,\n    0x2b321919,\n    0x95e67373,\n    0xa0c06060,\n    0x98198181,\n    0xd19e4f4f,\n    0x7fa3dcdc,\n    0x66442222,\n    0x7e542a2a,\n    0xab3b9090,\n    0x830b8888,\n    0xca8c4646,\n    0x29c7eeee,\n    0xd36bb8b8,\n    0x3c281414,\n    0x79a7dede,\n    0xe2bc5e5e,\n    0x1d160b0b,\n    0x76addbdb,\n    0x3bdbe0e0,\n    0x56643232,\n    0x4e743a3a,\n    0x1e140a0a,\n    0xdb924949,\n    0x0a0c0606,\n    0x6c482424,\n    0xe4b85c5c,\n    0x5d9fc2c2,\n    0x6ebdd3d3,\n    0xef43acac,\n    0xa6c46262,\n    0xa8399191,\n    0xa4319595,\n    0x37d3e4e4,\n    0x8bf27979,\n    0x32d5e7e7,\n    0x438bc8c8,\n    0x596e3737,\n    0xb7da6d6d,\n    0x8c018d8d,\n    0x64b1d5d5,\n    0xd29c4e4e,\n    0xe049a9a9,\n    0xb4d86c6c,\n    0xfaac5656,\n    0x07f3f4f4,\n    0x25cfeaea,\n    0xafca6565,\n    0x8ef47a7a,\n    0xe947aeae,\n    0x18100808,\n    0xd56fbaba,\n    0x88f07878,\n    0x6f4a2525,\n    0x725c2e2e,\n    0x24381c1c,\n    0xf157a6a6,\n    0xc773b4b4,\n    0x5197c6c6,\n    0x23cbe8e8,\n    0x7ca1dddd,\n    0x9ce87474,\n    0x213e1f1f,\n    0xdd964b4b,\n    0xdc61bdbd,\n    0x860d8b8b,\n    0x850f8a8a,\n    0x90e07070,\n    0x427c3e3e,\n    0xc471b5b5,\n    0xaacc6666,\n    0xd8904848,\n    0x05060303,\n    0x01f7f6f6,\n    0x121c0e0e,\n    0xa3c26161,\n    0x5f6a3535,\n    0xf9ae5757,\n    0xd069b9b9,\n    0x91178686,\n    0x5899c1c1,\n    0x273a1d1d,\n    0xb9279e9e,\n    0x38d9e1e1,\n    0x13ebf8f8,\n    0xb32b9898,\n    0x33221111,\n    0xbbd26969,\n    0x70a9d9d9,\n    0x89078e8e,\n    0xa7339494,\n    0xb62d9b9b,\n    0x223c1e1e,\n    0x92158787,\n    0x20c9e9e9,\n    0x4987cece,\n    0xffaa5555,\n    0x78502828,\n    0x7aa5dfdf,\n    0x8f038c8c,\n    0xf859a1a1,\n    0x80098989,\n    0x171a0d0d,\n    0xda65bfbf,\n    0x31d7e6e6,\n    0xc6844242,\n    0xb8d06868,\n    0xc3824141,\n    0xb0299999,\n    0x775a2d2d,\n    0x111e0f0f,\n    0xcb7bb0b0,\n    0xfca85454,\n    0xd66dbbbb,\n    0x3a2c1616\n];\nconst T3 = [\n    0x63a5c663,\n    0x7c84f87c,\n    0x7799ee77,\n    0x7b8df67b,\n    0xf20dfff2,\n    0x6bbdd66b,\n    0x6fb1de6f,\n    0xc55491c5,\n    0x30506030,\n    0x01030201,\n    0x67a9ce67,\n    0x2b7d562b,\n    0xfe19e7fe,\n    0xd762b5d7,\n    0xabe64dab,\n    0x769aec76,\n    0xca458fca,\n    0x829d1f82,\n    0xc94089c9,\n    0x7d87fa7d,\n    0xfa15effa,\n    0x59ebb259,\n    0x47c98e47,\n    0xf00bfbf0,\n    0xadec41ad,\n    0xd467b3d4,\n    0xa2fd5fa2,\n    0xafea45af,\n    0x9cbf239c,\n    0xa4f753a4,\n    0x7296e472,\n    0xc05b9bc0,\n    0xb7c275b7,\n    0xfd1ce1fd,\n    0x93ae3d93,\n    0x266a4c26,\n    0x365a6c36,\n    0x3f417e3f,\n    0xf702f5f7,\n    0xcc4f83cc,\n    0x345c6834,\n    0xa5f451a5,\n    0xe534d1e5,\n    0xf108f9f1,\n    0x7193e271,\n    0xd873abd8,\n    0x31536231,\n    0x153f2a15,\n    0x040c0804,\n    0xc75295c7,\n    0x23654623,\n    0xc35e9dc3,\n    0x18283018,\n    0x96a13796,\n    0x050f0a05,\n    0x9ab52f9a,\n    0x07090e07,\n    0x12362412,\n    0x809b1b80,\n    0xe23ddfe2,\n    0xeb26cdeb,\n    0x27694e27,\n    0xb2cd7fb2,\n    0x759fea75,\n    0x091b1209,\n    0x839e1d83,\n    0x2c74582c,\n    0x1a2e341a,\n    0x1b2d361b,\n    0x6eb2dc6e,\n    0x5aeeb45a,\n    0xa0fb5ba0,\n    0x52f6a452,\n    0x3b4d763b,\n    0xd661b7d6,\n    0xb3ce7db3,\n    0x297b5229,\n    0xe33edde3,\n    0x2f715e2f,\n    0x84971384,\n    0x53f5a653,\n    0xd168b9d1,\n    0x00000000,\n    0xed2cc1ed,\n    0x20604020,\n    0xfc1fe3fc,\n    0xb1c879b1,\n    0x5bedb65b,\n    0x6abed46a,\n    0xcb468dcb,\n    0xbed967be,\n    0x394b7239,\n    0x4ade944a,\n    0x4cd4984c,\n    0x58e8b058,\n    0xcf4a85cf,\n    0xd06bbbd0,\n    0xef2ac5ef,\n    0xaae54faa,\n    0xfb16edfb,\n    0x43c58643,\n    0x4dd79a4d,\n    0x33556633,\n    0x85941185,\n    0x45cf8a45,\n    0xf910e9f9,\n    0x02060402,\n    0x7f81fe7f,\n    0x50f0a050,\n    0x3c44783c,\n    0x9fba259f,\n    0xa8e34ba8,\n    0x51f3a251,\n    0xa3fe5da3,\n    0x40c08040,\n    0x8f8a058f,\n    0x92ad3f92,\n    0x9dbc219d,\n    0x38487038,\n    0xf504f1f5,\n    0xbcdf63bc,\n    0xb6c177b6,\n    0xda75afda,\n    0x21634221,\n    0x10302010,\n    0xff1ae5ff,\n    0xf30efdf3,\n    0xd26dbfd2,\n    0xcd4c81cd,\n    0x0c14180c,\n    0x13352613,\n    0xec2fc3ec,\n    0x5fe1be5f,\n    0x97a23597,\n    0x44cc8844,\n    0x17392e17,\n    0xc45793c4,\n    0xa7f255a7,\n    0x7e82fc7e,\n    0x3d477a3d,\n    0x64acc864,\n    0x5de7ba5d,\n    0x192b3219,\n    0x7395e673,\n    0x60a0c060,\n    0x81981981,\n    0x4fd19e4f,\n    0xdc7fa3dc,\n    0x22664422,\n    0x2a7e542a,\n    0x90ab3b90,\n    0x88830b88,\n    0x46ca8c46,\n    0xee29c7ee,\n    0xb8d36bb8,\n    0x143c2814,\n    0xde79a7de,\n    0x5ee2bc5e,\n    0x0b1d160b,\n    0xdb76addb,\n    0xe03bdbe0,\n    0x32566432,\n    0x3a4e743a,\n    0x0a1e140a,\n    0x49db9249,\n    0x060a0c06,\n    0x246c4824,\n    0x5ce4b85c,\n    0xc25d9fc2,\n    0xd36ebdd3,\n    0xacef43ac,\n    0x62a6c462,\n    0x91a83991,\n    0x95a43195,\n    0xe437d3e4,\n    0x798bf279,\n    0xe732d5e7,\n    0xc8438bc8,\n    0x37596e37,\n    0x6db7da6d,\n    0x8d8c018d,\n    0xd564b1d5,\n    0x4ed29c4e,\n    0xa9e049a9,\n    0x6cb4d86c,\n    0x56faac56,\n    0xf407f3f4,\n    0xea25cfea,\n    0x65afca65,\n    0x7a8ef47a,\n    0xaee947ae,\n    0x08181008,\n    0xbad56fba,\n    0x7888f078,\n    0x256f4a25,\n    0x2e725c2e,\n    0x1c24381c,\n    0xa6f157a6,\n    0xb4c773b4,\n    0xc65197c6,\n    0xe823cbe8,\n    0xdd7ca1dd,\n    0x749ce874,\n    0x1f213e1f,\n    0x4bdd964b,\n    0xbddc61bd,\n    0x8b860d8b,\n    0x8a850f8a,\n    0x7090e070,\n    0x3e427c3e,\n    0xb5c471b5,\n    0x66aacc66,\n    0x48d89048,\n    0x03050603,\n    0xf601f7f6,\n    0x0e121c0e,\n    0x61a3c261,\n    0x355f6a35,\n    0x57f9ae57,\n    0xb9d069b9,\n    0x86911786,\n    0xc15899c1,\n    0x1d273a1d,\n    0x9eb9279e,\n    0xe138d9e1,\n    0xf813ebf8,\n    0x98b32b98,\n    0x11332211,\n    0x69bbd269,\n    0xd970a9d9,\n    0x8e89078e,\n    0x94a73394,\n    0x9bb62d9b,\n    0x1e223c1e,\n    0x87921587,\n    0xe920c9e9,\n    0xce4987ce,\n    0x55ffaa55,\n    0x28785028,\n    0xdf7aa5df,\n    0x8c8f038c,\n    0xa1f859a1,\n    0x89800989,\n    0x0d171a0d,\n    0xbfda65bf,\n    0xe631d7e6,\n    0x42c68442,\n    0x68b8d068,\n    0x41c38241,\n    0x99b02999,\n    0x2d775a2d,\n    0x0f111e0f,\n    0xb0cb7bb0,\n    0x54fca854,\n    0xbbd66dbb,\n    0x163a2c16\n];\nconst T4 = [\n    0x6363a5c6,\n    0x7c7c84f8,\n    0x777799ee,\n    0x7b7b8df6,\n    0xf2f20dff,\n    0x6b6bbdd6,\n    0x6f6fb1de,\n    0xc5c55491,\n    0x30305060,\n    0x01010302,\n    0x6767a9ce,\n    0x2b2b7d56,\n    0xfefe19e7,\n    0xd7d762b5,\n    0xababe64d,\n    0x76769aec,\n    0xcaca458f,\n    0x82829d1f,\n    0xc9c94089,\n    0x7d7d87fa,\n    0xfafa15ef,\n    0x5959ebb2,\n    0x4747c98e,\n    0xf0f00bfb,\n    0xadadec41,\n    0xd4d467b3,\n    0xa2a2fd5f,\n    0xafafea45,\n    0x9c9cbf23,\n    0xa4a4f753,\n    0x727296e4,\n    0xc0c05b9b,\n    0xb7b7c275,\n    0xfdfd1ce1,\n    0x9393ae3d,\n    0x26266a4c,\n    0x36365a6c,\n    0x3f3f417e,\n    0xf7f702f5,\n    0xcccc4f83,\n    0x34345c68,\n    0xa5a5f451,\n    0xe5e534d1,\n    0xf1f108f9,\n    0x717193e2,\n    0xd8d873ab,\n    0x31315362,\n    0x15153f2a,\n    0x04040c08,\n    0xc7c75295,\n    0x23236546,\n    0xc3c35e9d,\n    0x18182830,\n    0x9696a137,\n    0x05050f0a,\n    0x9a9ab52f,\n    0x0707090e,\n    0x12123624,\n    0x80809b1b,\n    0xe2e23ddf,\n    0xebeb26cd,\n    0x2727694e,\n    0xb2b2cd7f,\n    0x75759fea,\n    0x09091b12,\n    0x83839e1d,\n    0x2c2c7458,\n    0x1a1a2e34,\n    0x1b1b2d36,\n    0x6e6eb2dc,\n    0x5a5aeeb4,\n    0xa0a0fb5b,\n    0x5252f6a4,\n    0x3b3b4d76,\n    0xd6d661b7,\n    0xb3b3ce7d,\n    0x29297b52,\n    0xe3e33edd,\n    0x2f2f715e,\n    0x84849713,\n    0x5353f5a6,\n    0xd1d168b9,\n    0x00000000,\n    0xeded2cc1,\n    0x20206040,\n    0xfcfc1fe3,\n    0xb1b1c879,\n    0x5b5bedb6,\n    0x6a6abed4,\n    0xcbcb468d,\n    0xbebed967,\n    0x39394b72,\n    0x4a4ade94,\n    0x4c4cd498,\n    0x5858e8b0,\n    0xcfcf4a85,\n    0xd0d06bbb,\n    0xefef2ac5,\n    0xaaaae54f,\n    0xfbfb16ed,\n    0x4343c586,\n    0x4d4dd79a,\n    0x33335566,\n    0x85859411,\n    0x4545cf8a,\n    0xf9f910e9,\n    0x02020604,\n    0x7f7f81fe,\n    0x5050f0a0,\n    0x3c3c4478,\n    0x9f9fba25,\n    0xa8a8e34b,\n    0x5151f3a2,\n    0xa3a3fe5d,\n    0x4040c080,\n    0x8f8f8a05,\n    0x9292ad3f,\n    0x9d9dbc21,\n    0x38384870,\n    0xf5f504f1,\n    0xbcbcdf63,\n    0xb6b6c177,\n    0xdada75af,\n    0x21216342,\n    0x10103020,\n    0xffff1ae5,\n    0xf3f30efd,\n    0xd2d26dbf,\n    0xcdcd4c81,\n    0x0c0c1418,\n    0x13133526,\n    0xecec2fc3,\n    0x5f5fe1be,\n    0x9797a235,\n    0x4444cc88,\n    0x1717392e,\n    0xc4c45793,\n    0xa7a7f255,\n    0x7e7e82fc,\n    0x3d3d477a,\n    0x6464acc8,\n    0x5d5de7ba,\n    0x19192b32,\n    0x737395e6,\n    0x6060a0c0,\n    0x81819819,\n    0x4f4fd19e,\n    0xdcdc7fa3,\n    0x22226644,\n    0x2a2a7e54,\n    0x9090ab3b,\n    0x8888830b,\n    0x4646ca8c,\n    0xeeee29c7,\n    0xb8b8d36b,\n    0x14143c28,\n    0xdede79a7,\n    0x5e5ee2bc,\n    0x0b0b1d16,\n    0xdbdb76ad,\n    0xe0e03bdb,\n    0x32325664,\n    0x3a3a4e74,\n    0x0a0a1e14,\n    0x4949db92,\n    0x06060a0c,\n    0x24246c48,\n    0x5c5ce4b8,\n    0xc2c25d9f,\n    0xd3d36ebd,\n    0xacacef43,\n    0x6262a6c4,\n    0x9191a839,\n    0x9595a431,\n    0xe4e437d3,\n    0x79798bf2,\n    0xe7e732d5,\n    0xc8c8438b,\n    0x3737596e,\n    0x6d6db7da,\n    0x8d8d8c01,\n    0xd5d564b1,\n    0x4e4ed29c,\n    0xa9a9e049,\n    0x6c6cb4d8,\n    0x5656faac,\n    0xf4f407f3,\n    0xeaea25cf,\n    0x6565afca,\n    0x7a7a8ef4,\n    0xaeaee947,\n    0x08081810,\n    0xbabad56f,\n    0x787888f0,\n    0x25256f4a,\n    0x2e2e725c,\n    0x1c1c2438,\n    0xa6a6f157,\n    0xb4b4c773,\n    0xc6c65197,\n    0xe8e823cb,\n    0xdddd7ca1,\n    0x74749ce8,\n    0x1f1f213e,\n    0x4b4bdd96,\n    0xbdbddc61,\n    0x8b8b860d,\n    0x8a8a850f,\n    0x707090e0,\n    0x3e3e427c,\n    0xb5b5c471,\n    0x6666aacc,\n    0x4848d890,\n    0x03030506,\n    0xf6f601f7,\n    0x0e0e121c,\n    0x6161a3c2,\n    0x35355f6a,\n    0x5757f9ae,\n    0xb9b9d069,\n    0x86869117,\n    0xc1c15899,\n    0x1d1d273a,\n    0x9e9eb927,\n    0xe1e138d9,\n    0xf8f813eb,\n    0x9898b32b,\n    0x11113322,\n    0x6969bbd2,\n    0xd9d970a9,\n    0x8e8e8907,\n    0x9494a733,\n    0x9b9bb62d,\n    0x1e1e223c,\n    0x87879215,\n    0xe9e920c9,\n    0xcece4987,\n    0x5555ffaa,\n    0x28287850,\n    0xdfdf7aa5,\n    0x8c8c8f03,\n    0xa1a1f859,\n    0x89898009,\n    0x0d0d171a,\n    0xbfbfda65,\n    0xe6e631d7,\n    0x4242c684,\n    0x6868b8d0,\n    0x4141c382,\n    0x9999b029,\n    0x2d2d775a,\n    0x0f0f111e,\n    0xb0b0cb7b,\n    0x5454fca8,\n    0xbbbbd66d,\n    0x16163a2c\n];\n// Transformations for decryption\nconst T5 = [\n    0x51f4a750,\n    0x7e416553,\n    0x1a17a4c3,\n    0x3a275e96,\n    0x3bab6bcb,\n    0x1f9d45f1,\n    0xacfa58ab,\n    0x4be30393,\n    0x2030fa55,\n    0xad766df6,\n    0x88cc7691,\n    0xf5024c25,\n    0x4fe5d7fc,\n    0xc52acbd7,\n    0x26354480,\n    0xb562a38f,\n    0xdeb15a49,\n    0x25ba1b67,\n    0x45ea0e98,\n    0x5dfec0e1,\n    0xc32f7502,\n    0x814cf012,\n    0x8d4697a3,\n    0x6bd3f9c6,\n    0x038f5fe7,\n    0x15929c95,\n    0xbf6d7aeb,\n    0x955259da,\n    0xd4be832d,\n    0x587421d3,\n    0x49e06929,\n    0x8ec9c844,\n    0x75c2896a,\n    0xf48e7978,\n    0x99583e6b,\n    0x27b971dd,\n    0xbee14fb6,\n    0xf088ad17,\n    0xc920ac66,\n    0x7dce3ab4,\n    0x63df4a18,\n    0xe51a3182,\n    0x97513360,\n    0x62537f45,\n    0xb16477e0,\n    0xbb6bae84,\n    0xfe81a01c,\n    0xf9082b94,\n    0x70486858,\n    0x8f45fd19,\n    0x94de6c87,\n    0x527bf8b7,\n    0xab73d323,\n    0x724b02e2,\n    0xe31f8f57,\n    0x6655ab2a,\n    0xb2eb2807,\n    0x2fb5c203,\n    0x86c57b9a,\n    0xd33708a5,\n    0x302887f2,\n    0x23bfa5b2,\n    0x02036aba,\n    0xed16825c,\n    0x8acf1c2b,\n    0xa779b492,\n    0xf307f2f0,\n    0x4e69e2a1,\n    0x65daf4cd,\n    0x0605bed5,\n    0xd134621f,\n    0xc4a6fe8a,\n    0x342e539d,\n    0xa2f355a0,\n    0x058ae132,\n    0xa4f6eb75,\n    0x0b83ec39,\n    0x4060efaa,\n    0x5e719f06,\n    0xbd6e1051,\n    0x3e218af9,\n    0x96dd063d,\n    0xdd3e05ae,\n    0x4de6bd46,\n    0x91548db5,\n    0x71c45d05,\n    0x0406d46f,\n    0x605015ff,\n    0x1998fb24,\n    0xd6bde997,\n    0x894043cc,\n    0x67d99e77,\n    0xb0e842bd,\n    0x07898b88,\n    0xe7195b38,\n    0x79c8eedb,\n    0xa17c0a47,\n    0x7c420fe9,\n    0xf8841ec9,\n    0x00000000,\n    0x09808683,\n    0x322bed48,\n    0x1e1170ac,\n    0x6c5a724e,\n    0xfd0efffb,\n    0x0f853856,\n    0x3daed51e,\n    0x362d3927,\n    0x0a0fd964,\n    0x685ca621,\n    0x9b5b54d1,\n    0x24362e3a,\n    0x0c0a67b1,\n    0x9357e70f,\n    0xb4ee96d2,\n    0x1b9b919e,\n    0x80c0c54f,\n    0x61dc20a2,\n    0x5a774b69,\n    0x1c121a16,\n    0xe293ba0a,\n    0xc0a02ae5,\n    0x3c22e043,\n    0x121b171d,\n    0x0e090d0b,\n    0xf28bc7ad,\n    0x2db6a8b9,\n    0x141ea9c8,\n    0x57f11985,\n    0xaf75074c,\n    0xee99ddbb,\n    0xa37f60fd,\n    0xf701269f,\n    0x5c72f5bc,\n    0x44663bc5,\n    0x5bfb7e34,\n    0x8b432976,\n    0xcb23c6dc,\n    0xb6edfc68,\n    0xb8e4f163,\n    0xd731dcca,\n    0x42638510,\n    0x13972240,\n    0x84c61120,\n    0x854a247d,\n    0xd2bb3df8,\n    0xaef93211,\n    0xc729a16d,\n    0x1d9e2f4b,\n    0xdcb230f3,\n    0x0d8652ec,\n    0x77c1e3d0,\n    0x2bb3166c,\n    0xa970b999,\n    0x119448fa,\n    0x47e96422,\n    0xa8fc8cc4,\n    0xa0f03f1a,\n    0x567d2cd8,\n    0x223390ef,\n    0x87494ec7,\n    0xd938d1c1,\n    0x8ccaa2fe,\n    0x98d40b36,\n    0xa6f581cf,\n    0xa57ade28,\n    0xdab78e26,\n    0x3fadbfa4,\n    0x2c3a9de4,\n    0x5078920d,\n    0x6a5fcc9b,\n    0x547e4662,\n    0xf68d13c2,\n    0x90d8b8e8,\n    0x2e39f75e,\n    0x82c3aff5,\n    0x9f5d80be,\n    0x69d0937c,\n    0x6fd52da9,\n    0xcf2512b3,\n    0xc8ac993b,\n    0x10187da7,\n    0xe89c636e,\n    0xdb3bbb7b,\n    0xcd267809,\n    0x6e5918f4,\n    0xec9ab701,\n    0x834f9aa8,\n    0xe6956e65,\n    0xaaffe67e,\n    0x21bccf08,\n    0xef15e8e6,\n    0xbae79bd9,\n    0x4a6f36ce,\n    0xea9f09d4,\n    0x29b07cd6,\n    0x31a4b2af,\n    0x2a3f2331,\n    0xc6a59430,\n    0x35a266c0,\n    0x744ebc37,\n    0xfc82caa6,\n    0xe090d0b0,\n    0x33a7d815,\n    0xf104984a,\n    0x41ecdaf7,\n    0x7fcd500e,\n    0x1791f62f,\n    0x764dd68d,\n    0x43efb04d,\n    0xccaa4d54,\n    0xe49604df,\n    0x9ed1b5e3,\n    0x4c6a881b,\n    0xc12c1fb8,\n    0x4665517f,\n    0x9d5eea04,\n    0x018c355d,\n    0xfa877473,\n    0xfb0b412e,\n    0xb3671d5a,\n    0x92dbd252,\n    0xe9105633,\n    0x6dd64713,\n    0x9ad7618c,\n    0x37a10c7a,\n    0x59f8148e,\n    0xeb133c89,\n    0xcea927ee,\n    0xb761c935,\n    0xe11ce5ed,\n    0x7a47b13c,\n    0x9cd2df59,\n    0x55f2733f,\n    0x1814ce79,\n    0x73c737bf,\n    0x53f7cdea,\n    0x5ffdaa5b,\n    0xdf3d6f14,\n    0x7844db86,\n    0xcaaff381,\n    0xb968c43e,\n    0x3824342c,\n    0xc2a3405f,\n    0x161dc372,\n    0xbce2250c,\n    0x283c498b,\n    0xff0d9541,\n    0x39a80171,\n    0x080cb3de,\n    0xd8b4e49c,\n    0x6456c190,\n    0x7bcb8461,\n    0xd532b670,\n    0x486c5c74,\n    0xd0b85742\n];\nconst T6 = [\n    0x5051f4a7,\n    0x537e4165,\n    0xc31a17a4,\n    0x963a275e,\n    0xcb3bab6b,\n    0xf11f9d45,\n    0xabacfa58,\n    0x934be303,\n    0x552030fa,\n    0xf6ad766d,\n    0x9188cc76,\n    0x25f5024c,\n    0xfc4fe5d7,\n    0xd7c52acb,\n    0x80263544,\n    0x8fb562a3,\n    0x49deb15a,\n    0x6725ba1b,\n    0x9845ea0e,\n    0xe15dfec0,\n    0x02c32f75,\n    0x12814cf0,\n    0xa38d4697,\n    0xc66bd3f9,\n    0xe7038f5f,\n    0x9515929c,\n    0xebbf6d7a,\n    0xda955259,\n    0x2dd4be83,\n    0xd3587421,\n    0x2949e069,\n    0x448ec9c8,\n    0x6a75c289,\n    0x78f48e79,\n    0x6b99583e,\n    0xdd27b971,\n    0xb6bee14f,\n    0x17f088ad,\n    0x66c920ac,\n    0xb47dce3a,\n    0x1863df4a,\n    0x82e51a31,\n    0x60975133,\n    0x4562537f,\n    0xe0b16477,\n    0x84bb6bae,\n    0x1cfe81a0,\n    0x94f9082b,\n    0x58704868,\n    0x198f45fd,\n    0x8794de6c,\n    0xb7527bf8,\n    0x23ab73d3,\n    0xe2724b02,\n    0x57e31f8f,\n    0x2a6655ab,\n    0x07b2eb28,\n    0x032fb5c2,\n    0x9a86c57b,\n    0xa5d33708,\n    0xf2302887,\n    0xb223bfa5,\n    0xba02036a,\n    0x5ced1682,\n    0x2b8acf1c,\n    0x92a779b4,\n    0xf0f307f2,\n    0xa14e69e2,\n    0xcd65daf4,\n    0xd50605be,\n    0x1fd13462,\n    0x8ac4a6fe,\n    0x9d342e53,\n    0xa0a2f355,\n    0x32058ae1,\n    0x75a4f6eb,\n    0x390b83ec,\n    0xaa4060ef,\n    0x065e719f,\n    0x51bd6e10,\n    0xf93e218a,\n    0x3d96dd06,\n    0xaedd3e05,\n    0x464de6bd,\n    0xb591548d,\n    0x0571c45d,\n    0x6f0406d4,\n    0xff605015,\n    0x241998fb,\n    0x97d6bde9,\n    0xcc894043,\n    0x7767d99e,\n    0xbdb0e842,\n    0x8807898b,\n    0x38e7195b,\n    0xdb79c8ee,\n    0x47a17c0a,\n    0xe97c420f,\n    0xc9f8841e,\n    0x00000000,\n    0x83098086,\n    0x48322bed,\n    0xac1e1170,\n    0x4e6c5a72,\n    0xfbfd0eff,\n    0x560f8538,\n    0x1e3daed5,\n    0x27362d39,\n    0x640a0fd9,\n    0x21685ca6,\n    0xd19b5b54,\n    0x3a24362e,\n    0xb10c0a67,\n    0x0f9357e7,\n    0xd2b4ee96,\n    0x9e1b9b91,\n    0x4f80c0c5,\n    0xa261dc20,\n    0x695a774b,\n    0x161c121a,\n    0x0ae293ba,\n    0xe5c0a02a,\n    0x433c22e0,\n    0x1d121b17,\n    0x0b0e090d,\n    0xadf28bc7,\n    0xb92db6a8,\n    0xc8141ea9,\n    0x8557f119,\n    0x4caf7507,\n    0xbbee99dd,\n    0xfda37f60,\n    0x9ff70126,\n    0xbc5c72f5,\n    0xc544663b,\n    0x345bfb7e,\n    0x768b4329,\n    0xdccb23c6,\n    0x68b6edfc,\n    0x63b8e4f1,\n    0xcad731dc,\n    0x10426385,\n    0x40139722,\n    0x2084c611,\n    0x7d854a24,\n    0xf8d2bb3d,\n    0x11aef932,\n    0x6dc729a1,\n    0x4b1d9e2f,\n    0xf3dcb230,\n    0xec0d8652,\n    0xd077c1e3,\n    0x6c2bb316,\n    0x99a970b9,\n    0xfa119448,\n    0x2247e964,\n    0xc4a8fc8c,\n    0x1aa0f03f,\n    0xd8567d2c,\n    0xef223390,\n    0xc787494e,\n    0xc1d938d1,\n    0xfe8ccaa2,\n    0x3698d40b,\n    0xcfa6f581,\n    0x28a57ade,\n    0x26dab78e,\n    0xa43fadbf,\n    0xe42c3a9d,\n    0x0d507892,\n    0x9b6a5fcc,\n    0x62547e46,\n    0xc2f68d13,\n    0xe890d8b8,\n    0x5e2e39f7,\n    0xf582c3af,\n    0xbe9f5d80,\n    0x7c69d093,\n    0xa96fd52d,\n    0xb3cf2512,\n    0x3bc8ac99,\n    0xa710187d,\n    0x6ee89c63,\n    0x7bdb3bbb,\n    0x09cd2678,\n    0xf46e5918,\n    0x01ec9ab7,\n    0xa8834f9a,\n    0x65e6956e,\n    0x7eaaffe6,\n    0x0821bccf,\n    0xe6ef15e8,\n    0xd9bae79b,\n    0xce4a6f36,\n    0xd4ea9f09,\n    0xd629b07c,\n    0xaf31a4b2,\n    0x312a3f23,\n    0x30c6a594,\n    0xc035a266,\n    0x37744ebc,\n    0xa6fc82ca,\n    0xb0e090d0,\n    0x1533a7d8,\n    0x4af10498,\n    0xf741ecda,\n    0x0e7fcd50,\n    0x2f1791f6,\n    0x8d764dd6,\n    0x4d43efb0,\n    0x54ccaa4d,\n    0xdfe49604,\n    0xe39ed1b5,\n    0x1b4c6a88,\n    0xb8c12c1f,\n    0x7f466551,\n    0x049d5eea,\n    0x5d018c35,\n    0x73fa8774,\n    0x2efb0b41,\n    0x5ab3671d,\n    0x5292dbd2,\n    0x33e91056,\n    0x136dd647,\n    0x8c9ad761,\n    0x7a37a10c,\n    0x8e59f814,\n    0x89eb133c,\n    0xeecea927,\n    0x35b761c9,\n    0xede11ce5,\n    0x3c7a47b1,\n    0x599cd2df,\n    0x3f55f273,\n    0x791814ce,\n    0xbf73c737,\n    0xea53f7cd,\n    0x5b5ffdaa,\n    0x14df3d6f,\n    0x867844db,\n    0x81caaff3,\n    0x3eb968c4,\n    0x2c382434,\n    0x5fc2a340,\n    0x72161dc3,\n    0x0cbce225,\n    0x8b283c49,\n    0x41ff0d95,\n    0x7139a801,\n    0xde080cb3,\n    0x9cd8b4e4,\n    0x906456c1,\n    0x617bcb84,\n    0x70d532b6,\n    0x74486c5c,\n    0x42d0b857\n];\nconst T7 = [\n    0xa75051f4,\n    0x65537e41,\n    0xa4c31a17,\n    0x5e963a27,\n    0x6bcb3bab,\n    0x45f11f9d,\n    0x58abacfa,\n    0x03934be3,\n    0xfa552030,\n    0x6df6ad76,\n    0x769188cc,\n    0x4c25f502,\n    0xd7fc4fe5,\n    0xcbd7c52a,\n    0x44802635,\n    0xa38fb562,\n    0x5a49deb1,\n    0x1b6725ba,\n    0x0e9845ea,\n    0xc0e15dfe,\n    0x7502c32f,\n    0xf012814c,\n    0x97a38d46,\n    0xf9c66bd3,\n    0x5fe7038f,\n    0x9c951592,\n    0x7aebbf6d,\n    0x59da9552,\n    0x832dd4be,\n    0x21d35874,\n    0x692949e0,\n    0xc8448ec9,\n    0x896a75c2,\n    0x7978f48e,\n    0x3e6b9958,\n    0x71dd27b9,\n    0x4fb6bee1,\n    0xad17f088,\n    0xac66c920,\n    0x3ab47dce,\n    0x4a1863df,\n    0x3182e51a,\n    0x33609751,\n    0x7f456253,\n    0x77e0b164,\n    0xae84bb6b,\n    0xa01cfe81,\n    0x2b94f908,\n    0x68587048,\n    0xfd198f45,\n    0x6c8794de,\n    0xf8b7527b,\n    0xd323ab73,\n    0x02e2724b,\n    0x8f57e31f,\n    0xab2a6655,\n    0x2807b2eb,\n    0xc2032fb5,\n    0x7b9a86c5,\n    0x08a5d337,\n    0x87f23028,\n    0xa5b223bf,\n    0x6aba0203,\n    0x825ced16,\n    0x1c2b8acf,\n    0xb492a779,\n    0xf2f0f307,\n    0xe2a14e69,\n    0xf4cd65da,\n    0xbed50605,\n    0x621fd134,\n    0xfe8ac4a6,\n    0x539d342e,\n    0x55a0a2f3,\n    0xe132058a,\n    0xeb75a4f6,\n    0xec390b83,\n    0xefaa4060,\n    0x9f065e71,\n    0x1051bd6e,\n    0x8af93e21,\n    0x063d96dd,\n    0x05aedd3e,\n    0xbd464de6,\n    0x8db59154,\n    0x5d0571c4,\n    0xd46f0406,\n    0x15ff6050,\n    0xfb241998,\n    0xe997d6bd,\n    0x43cc8940,\n    0x9e7767d9,\n    0x42bdb0e8,\n    0x8b880789,\n    0x5b38e719,\n    0xeedb79c8,\n    0x0a47a17c,\n    0x0fe97c42,\n    0x1ec9f884,\n    0x00000000,\n    0x86830980,\n    0xed48322b,\n    0x70ac1e11,\n    0x724e6c5a,\n    0xfffbfd0e,\n    0x38560f85,\n    0xd51e3dae,\n    0x3927362d,\n    0xd9640a0f,\n    0xa621685c,\n    0x54d19b5b,\n    0x2e3a2436,\n    0x67b10c0a,\n    0xe70f9357,\n    0x96d2b4ee,\n    0x919e1b9b,\n    0xc54f80c0,\n    0x20a261dc,\n    0x4b695a77,\n    0x1a161c12,\n    0xba0ae293,\n    0x2ae5c0a0,\n    0xe0433c22,\n    0x171d121b,\n    0x0d0b0e09,\n    0xc7adf28b,\n    0xa8b92db6,\n    0xa9c8141e,\n    0x198557f1,\n    0x074caf75,\n    0xddbbee99,\n    0x60fda37f,\n    0x269ff701,\n    0xf5bc5c72,\n    0x3bc54466,\n    0x7e345bfb,\n    0x29768b43,\n    0xc6dccb23,\n    0xfc68b6ed,\n    0xf163b8e4,\n    0xdccad731,\n    0x85104263,\n    0x22401397,\n    0x112084c6,\n    0x247d854a,\n    0x3df8d2bb,\n    0x3211aef9,\n    0xa16dc729,\n    0x2f4b1d9e,\n    0x30f3dcb2,\n    0x52ec0d86,\n    0xe3d077c1,\n    0x166c2bb3,\n    0xb999a970,\n    0x48fa1194,\n    0x642247e9,\n    0x8cc4a8fc,\n    0x3f1aa0f0,\n    0x2cd8567d,\n    0x90ef2233,\n    0x4ec78749,\n    0xd1c1d938,\n    0xa2fe8cca,\n    0x0b3698d4,\n    0x81cfa6f5,\n    0xde28a57a,\n    0x8e26dab7,\n    0xbfa43fad,\n    0x9de42c3a,\n    0x920d5078,\n    0xcc9b6a5f,\n    0x4662547e,\n    0x13c2f68d,\n    0xb8e890d8,\n    0xf75e2e39,\n    0xaff582c3,\n    0x80be9f5d,\n    0x937c69d0,\n    0x2da96fd5,\n    0x12b3cf25,\n    0x993bc8ac,\n    0x7da71018,\n    0x636ee89c,\n    0xbb7bdb3b,\n    0x7809cd26,\n    0x18f46e59,\n    0xb701ec9a,\n    0x9aa8834f,\n    0x6e65e695,\n    0xe67eaaff,\n    0xcf0821bc,\n    0xe8e6ef15,\n    0x9bd9bae7,\n    0x36ce4a6f,\n    0x09d4ea9f,\n    0x7cd629b0,\n    0xb2af31a4,\n    0x23312a3f,\n    0x9430c6a5,\n    0x66c035a2,\n    0xbc37744e,\n    0xcaa6fc82,\n    0xd0b0e090,\n    0xd81533a7,\n    0x984af104,\n    0xdaf741ec,\n    0x500e7fcd,\n    0xf62f1791,\n    0xd68d764d,\n    0xb04d43ef,\n    0x4d54ccaa,\n    0x04dfe496,\n    0xb5e39ed1,\n    0x881b4c6a,\n    0x1fb8c12c,\n    0x517f4665,\n    0xea049d5e,\n    0x355d018c,\n    0x7473fa87,\n    0x412efb0b,\n    0x1d5ab367,\n    0xd25292db,\n    0x5633e910,\n    0x47136dd6,\n    0x618c9ad7,\n    0x0c7a37a1,\n    0x148e59f8,\n    0x3c89eb13,\n    0x27eecea9,\n    0xc935b761,\n    0xe5ede11c,\n    0xb13c7a47,\n    0xdf599cd2,\n    0x733f55f2,\n    0xce791814,\n    0x37bf73c7,\n    0xcdea53f7,\n    0xaa5b5ffd,\n    0x6f14df3d,\n    0xdb867844,\n    0xf381caaf,\n    0xc43eb968,\n    0x342c3824,\n    0x405fc2a3,\n    0xc372161d,\n    0x250cbce2,\n    0x498b283c,\n    0x9541ff0d,\n    0x017139a8,\n    0xb3de080c,\n    0xe49cd8b4,\n    0xc1906456,\n    0x84617bcb,\n    0xb670d532,\n    0x5c74486c,\n    0x5742d0b8\n];\nconst T8 = [\n    0xf4a75051,\n    0x4165537e,\n    0x17a4c31a,\n    0x275e963a,\n    0xab6bcb3b,\n    0x9d45f11f,\n    0xfa58abac,\n    0xe303934b,\n    0x30fa5520,\n    0x766df6ad,\n    0xcc769188,\n    0x024c25f5,\n    0xe5d7fc4f,\n    0x2acbd7c5,\n    0x35448026,\n    0x62a38fb5,\n    0xb15a49de,\n    0xba1b6725,\n    0xea0e9845,\n    0xfec0e15d,\n    0x2f7502c3,\n    0x4cf01281,\n    0x4697a38d,\n    0xd3f9c66b,\n    0x8f5fe703,\n    0x929c9515,\n    0x6d7aebbf,\n    0x5259da95,\n    0xbe832dd4,\n    0x7421d358,\n    0xe0692949,\n    0xc9c8448e,\n    0xc2896a75,\n    0x8e7978f4,\n    0x583e6b99,\n    0xb971dd27,\n    0xe14fb6be,\n    0x88ad17f0,\n    0x20ac66c9,\n    0xce3ab47d,\n    0xdf4a1863,\n    0x1a3182e5,\n    0x51336097,\n    0x537f4562,\n    0x6477e0b1,\n    0x6bae84bb,\n    0x81a01cfe,\n    0x082b94f9,\n    0x48685870,\n    0x45fd198f,\n    0xde6c8794,\n    0x7bf8b752,\n    0x73d323ab,\n    0x4b02e272,\n    0x1f8f57e3,\n    0x55ab2a66,\n    0xeb2807b2,\n    0xb5c2032f,\n    0xc57b9a86,\n    0x3708a5d3,\n    0x2887f230,\n    0xbfa5b223,\n    0x036aba02,\n    0x16825ced,\n    0xcf1c2b8a,\n    0x79b492a7,\n    0x07f2f0f3,\n    0x69e2a14e,\n    0xdaf4cd65,\n    0x05bed506,\n    0x34621fd1,\n    0xa6fe8ac4,\n    0x2e539d34,\n    0xf355a0a2,\n    0x8ae13205,\n    0xf6eb75a4,\n    0x83ec390b,\n    0x60efaa40,\n    0x719f065e,\n    0x6e1051bd,\n    0x218af93e,\n    0xdd063d96,\n    0x3e05aedd,\n    0xe6bd464d,\n    0x548db591,\n    0xc45d0571,\n    0x06d46f04,\n    0x5015ff60,\n    0x98fb2419,\n    0xbde997d6,\n    0x4043cc89,\n    0xd99e7767,\n    0xe842bdb0,\n    0x898b8807,\n    0x195b38e7,\n    0xc8eedb79,\n    0x7c0a47a1,\n    0x420fe97c,\n    0x841ec9f8,\n    0x00000000,\n    0x80868309,\n    0x2bed4832,\n    0x1170ac1e,\n    0x5a724e6c,\n    0x0efffbfd,\n    0x8538560f,\n    0xaed51e3d,\n    0x2d392736,\n    0x0fd9640a,\n    0x5ca62168,\n    0x5b54d19b,\n    0x362e3a24,\n    0x0a67b10c,\n    0x57e70f93,\n    0xee96d2b4,\n    0x9b919e1b,\n    0xc0c54f80,\n    0xdc20a261,\n    0x774b695a,\n    0x121a161c,\n    0x93ba0ae2,\n    0xa02ae5c0,\n    0x22e0433c,\n    0x1b171d12,\n    0x090d0b0e,\n    0x8bc7adf2,\n    0xb6a8b92d,\n    0x1ea9c814,\n    0xf1198557,\n    0x75074caf,\n    0x99ddbbee,\n    0x7f60fda3,\n    0x01269ff7,\n    0x72f5bc5c,\n    0x663bc544,\n    0xfb7e345b,\n    0x4329768b,\n    0x23c6dccb,\n    0xedfc68b6,\n    0xe4f163b8,\n    0x31dccad7,\n    0x63851042,\n    0x97224013,\n    0xc6112084,\n    0x4a247d85,\n    0xbb3df8d2,\n    0xf93211ae,\n    0x29a16dc7,\n    0x9e2f4b1d,\n    0xb230f3dc,\n    0x8652ec0d,\n    0xc1e3d077,\n    0xb3166c2b,\n    0x70b999a9,\n    0x9448fa11,\n    0xe9642247,\n    0xfc8cc4a8,\n    0xf03f1aa0,\n    0x7d2cd856,\n    0x3390ef22,\n    0x494ec787,\n    0x38d1c1d9,\n    0xcaa2fe8c,\n    0xd40b3698,\n    0xf581cfa6,\n    0x7ade28a5,\n    0xb78e26da,\n    0xadbfa43f,\n    0x3a9de42c,\n    0x78920d50,\n    0x5fcc9b6a,\n    0x7e466254,\n    0x8d13c2f6,\n    0xd8b8e890,\n    0x39f75e2e,\n    0xc3aff582,\n    0x5d80be9f,\n    0xd0937c69,\n    0xd52da96f,\n    0x2512b3cf,\n    0xac993bc8,\n    0x187da710,\n    0x9c636ee8,\n    0x3bbb7bdb,\n    0x267809cd,\n    0x5918f46e,\n    0x9ab701ec,\n    0x4f9aa883,\n    0x956e65e6,\n    0xffe67eaa,\n    0xbccf0821,\n    0x15e8e6ef,\n    0xe79bd9ba,\n    0x6f36ce4a,\n    0x9f09d4ea,\n    0xb07cd629,\n    0xa4b2af31,\n    0x3f23312a,\n    0xa59430c6,\n    0xa266c035,\n    0x4ebc3774,\n    0x82caa6fc,\n    0x90d0b0e0,\n    0xa7d81533,\n    0x04984af1,\n    0xecdaf741,\n    0xcd500e7f,\n    0x91f62f17,\n    0x4dd68d76,\n    0xefb04d43,\n    0xaa4d54cc,\n    0x9604dfe4,\n    0xd1b5e39e,\n    0x6a881b4c,\n    0x2c1fb8c1,\n    0x65517f46,\n    0x5eea049d,\n    0x8c355d01,\n    0x877473fa,\n    0x0b412efb,\n    0x671d5ab3,\n    0xdbd25292,\n    0x105633e9,\n    0xd647136d,\n    0xd7618c9a,\n    0xa10c7a37,\n    0xf8148e59,\n    0x133c89eb,\n    0xa927eece,\n    0x61c935b7,\n    0x1ce5ede1,\n    0x47b13c7a,\n    0xd2df599c,\n    0xf2733f55,\n    0x14ce7918,\n    0xc737bf73,\n    0xf7cdea53,\n    0xfdaa5b5f,\n    0x3d6f14df,\n    0x44db8678,\n    0xaff381ca,\n    0x68c43eb9,\n    0x24342c38,\n    0xa3405fc2,\n    0x1dc37216,\n    0xe2250cbc,\n    0x3c498b28,\n    0x0d9541ff,\n    0xa8017139,\n    0x0cb3de08,\n    0xb4e49cd8,\n    0x56c19064,\n    0xcb84617b,\n    0x32b670d5,\n    0x6c5c7448,\n    0xb85742d0\n];\n// Transformations for decryption key expansion\nconst U1 = [\n    0x00000000,\n    0x0e090d0b,\n    0x1c121a16,\n    0x121b171d,\n    0x3824342c,\n    0x362d3927,\n    0x24362e3a,\n    0x2a3f2331,\n    0x70486858,\n    0x7e416553,\n    0x6c5a724e,\n    0x62537f45,\n    0x486c5c74,\n    0x4665517f,\n    0x547e4662,\n    0x5a774b69,\n    0xe090d0b0,\n    0xee99ddbb,\n    0xfc82caa6,\n    0xf28bc7ad,\n    0xd8b4e49c,\n    0xd6bde997,\n    0xc4a6fe8a,\n    0xcaaff381,\n    0x90d8b8e8,\n    0x9ed1b5e3,\n    0x8ccaa2fe,\n    0x82c3aff5,\n    0xa8fc8cc4,\n    0xa6f581cf,\n    0xb4ee96d2,\n    0xbae79bd9,\n    0xdb3bbb7b,\n    0xd532b670,\n    0xc729a16d,\n    0xc920ac66,\n    0xe31f8f57,\n    0xed16825c,\n    0xff0d9541,\n    0xf104984a,\n    0xab73d323,\n    0xa57ade28,\n    0xb761c935,\n    0xb968c43e,\n    0x9357e70f,\n    0x9d5eea04,\n    0x8f45fd19,\n    0x814cf012,\n    0x3bab6bcb,\n    0x35a266c0,\n    0x27b971dd,\n    0x29b07cd6,\n    0x038f5fe7,\n    0x0d8652ec,\n    0x1f9d45f1,\n    0x119448fa,\n    0x4be30393,\n    0x45ea0e98,\n    0x57f11985,\n    0x59f8148e,\n    0x73c737bf,\n    0x7dce3ab4,\n    0x6fd52da9,\n    0x61dc20a2,\n    0xad766df6,\n    0xa37f60fd,\n    0xb16477e0,\n    0xbf6d7aeb,\n    0x955259da,\n    0x9b5b54d1,\n    0x894043cc,\n    0x87494ec7,\n    0xdd3e05ae,\n    0xd33708a5,\n    0xc12c1fb8,\n    0xcf2512b3,\n    0xe51a3182,\n    0xeb133c89,\n    0xf9082b94,\n    0xf701269f,\n    0x4de6bd46,\n    0x43efb04d,\n    0x51f4a750,\n    0x5ffdaa5b,\n    0x75c2896a,\n    0x7bcb8461,\n    0x69d0937c,\n    0x67d99e77,\n    0x3daed51e,\n    0x33a7d815,\n    0x21bccf08,\n    0x2fb5c203,\n    0x058ae132,\n    0x0b83ec39,\n    0x1998fb24,\n    0x1791f62f,\n    0x764dd68d,\n    0x7844db86,\n    0x6a5fcc9b,\n    0x6456c190,\n    0x4e69e2a1,\n    0x4060efaa,\n    0x527bf8b7,\n    0x5c72f5bc,\n    0x0605bed5,\n    0x080cb3de,\n    0x1a17a4c3,\n    0x141ea9c8,\n    0x3e218af9,\n    0x302887f2,\n    0x223390ef,\n    0x2c3a9de4,\n    0x96dd063d,\n    0x98d40b36,\n    0x8acf1c2b,\n    0x84c61120,\n    0xaef93211,\n    0xa0f03f1a,\n    0xb2eb2807,\n    0xbce2250c,\n    0xe6956e65,\n    0xe89c636e,\n    0xfa877473,\n    0xf48e7978,\n    0xdeb15a49,\n    0xd0b85742,\n    0xc2a3405f,\n    0xccaa4d54,\n    0x41ecdaf7,\n    0x4fe5d7fc,\n    0x5dfec0e1,\n    0x53f7cdea,\n    0x79c8eedb,\n    0x77c1e3d0,\n    0x65daf4cd,\n    0x6bd3f9c6,\n    0x31a4b2af,\n    0x3fadbfa4,\n    0x2db6a8b9,\n    0x23bfa5b2,\n    0x09808683,\n    0x07898b88,\n    0x15929c95,\n    0x1b9b919e,\n    0xa17c0a47,\n    0xaf75074c,\n    0xbd6e1051,\n    0xb3671d5a,\n    0x99583e6b,\n    0x97513360,\n    0x854a247d,\n    0x8b432976,\n    0xd134621f,\n    0xdf3d6f14,\n    0xcd267809,\n    0xc32f7502,\n    0xe9105633,\n    0xe7195b38,\n    0xf5024c25,\n    0xfb0b412e,\n    0x9ad7618c,\n    0x94de6c87,\n    0x86c57b9a,\n    0x88cc7691,\n    0xa2f355a0,\n    0xacfa58ab,\n    0xbee14fb6,\n    0xb0e842bd,\n    0xea9f09d4,\n    0xe49604df,\n    0xf68d13c2,\n    0xf8841ec9,\n    0xd2bb3df8,\n    0xdcb230f3,\n    0xcea927ee,\n    0xc0a02ae5,\n    0x7a47b13c,\n    0x744ebc37,\n    0x6655ab2a,\n    0x685ca621,\n    0x42638510,\n    0x4c6a881b,\n    0x5e719f06,\n    0x5078920d,\n    0x0a0fd964,\n    0x0406d46f,\n    0x161dc372,\n    0x1814ce79,\n    0x322bed48,\n    0x3c22e043,\n    0x2e39f75e,\n    0x2030fa55,\n    0xec9ab701,\n    0xe293ba0a,\n    0xf088ad17,\n    0xfe81a01c,\n    0xd4be832d,\n    0xdab78e26,\n    0xc8ac993b,\n    0xc6a59430,\n    0x9cd2df59,\n    0x92dbd252,\n    0x80c0c54f,\n    0x8ec9c844,\n    0xa4f6eb75,\n    0xaaffe67e,\n    0xb8e4f163,\n    0xb6edfc68,\n    0x0c0a67b1,\n    0x02036aba,\n    0x10187da7,\n    0x1e1170ac,\n    0x342e539d,\n    0x3a275e96,\n    0x283c498b,\n    0x26354480,\n    0x7c420fe9,\n    0x724b02e2,\n    0x605015ff,\n    0x6e5918f4,\n    0x44663bc5,\n    0x4a6f36ce,\n    0x587421d3,\n    0x567d2cd8,\n    0x37a10c7a,\n    0x39a80171,\n    0x2bb3166c,\n    0x25ba1b67,\n    0x0f853856,\n    0x018c355d,\n    0x13972240,\n    0x1d9e2f4b,\n    0x47e96422,\n    0x49e06929,\n    0x5bfb7e34,\n    0x55f2733f,\n    0x7fcd500e,\n    0x71c45d05,\n    0x63df4a18,\n    0x6dd64713,\n    0xd731dcca,\n    0xd938d1c1,\n    0xcb23c6dc,\n    0xc52acbd7,\n    0xef15e8e6,\n    0xe11ce5ed,\n    0xf307f2f0,\n    0xfd0efffb,\n    0xa779b492,\n    0xa970b999,\n    0xbb6bae84,\n    0xb562a38f,\n    0x9f5d80be,\n    0x91548db5,\n    0x834f9aa8,\n    0x8d4697a3\n];\nconst U2 = [\n    0x00000000,\n    0x0b0e090d,\n    0x161c121a,\n    0x1d121b17,\n    0x2c382434,\n    0x27362d39,\n    0x3a24362e,\n    0x312a3f23,\n    0x58704868,\n    0x537e4165,\n    0x4e6c5a72,\n    0x4562537f,\n    0x74486c5c,\n    0x7f466551,\n    0x62547e46,\n    0x695a774b,\n    0xb0e090d0,\n    0xbbee99dd,\n    0xa6fc82ca,\n    0xadf28bc7,\n    0x9cd8b4e4,\n    0x97d6bde9,\n    0x8ac4a6fe,\n    0x81caaff3,\n    0xe890d8b8,\n    0xe39ed1b5,\n    0xfe8ccaa2,\n    0xf582c3af,\n    0xc4a8fc8c,\n    0xcfa6f581,\n    0xd2b4ee96,\n    0xd9bae79b,\n    0x7bdb3bbb,\n    0x70d532b6,\n    0x6dc729a1,\n    0x66c920ac,\n    0x57e31f8f,\n    0x5ced1682,\n    0x41ff0d95,\n    0x4af10498,\n    0x23ab73d3,\n    0x28a57ade,\n    0x35b761c9,\n    0x3eb968c4,\n    0x0f9357e7,\n    0x049d5eea,\n    0x198f45fd,\n    0x12814cf0,\n    0xcb3bab6b,\n    0xc035a266,\n    0xdd27b971,\n    0xd629b07c,\n    0xe7038f5f,\n    0xec0d8652,\n    0xf11f9d45,\n    0xfa119448,\n    0x934be303,\n    0x9845ea0e,\n    0x8557f119,\n    0x8e59f814,\n    0xbf73c737,\n    0xb47dce3a,\n    0xa96fd52d,\n    0xa261dc20,\n    0xf6ad766d,\n    0xfda37f60,\n    0xe0b16477,\n    0xebbf6d7a,\n    0xda955259,\n    0xd19b5b54,\n    0xcc894043,\n    0xc787494e,\n    0xaedd3e05,\n    0xa5d33708,\n    0xb8c12c1f,\n    0xb3cf2512,\n    0x82e51a31,\n    0x89eb133c,\n    0x94f9082b,\n    0x9ff70126,\n    0x464de6bd,\n    0x4d43efb0,\n    0x5051f4a7,\n    0x5b5ffdaa,\n    0x6a75c289,\n    0x617bcb84,\n    0x7c69d093,\n    0x7767d99e,\n    0x1e3daed5,\n    0x1533a7d8,\n    0x0821bccf,\n    0x032fb5c2,\n    0x32058ae1,\n    0x390b83ec,\n    0x241998fb,\n    0x2f1791f6,\n    0x8d764dd6,\n    0x867844db,\n    0x9b6a5fcc,\n    0x906456c1,\n    0xa14e69e2,\n    0xaa4060ef,\n    0xb7527bf8,\n    0xbc5c72f5,\n    0xd50605be,\n    0xde080cb3,\n    0xc31a17a4,\n    0xc8141ea9,\n    0xf93e218a,\n    0xf2302887,\n    0xef223390,\n    0xe42c3a9d,\n    0x3d96dd06,\n    0x3698d40b,\n    0x2b8acf1c,\n    0x2084c611,\n    0x11aef932,\n    0x1aa0f03f,\n    0x07b2eb28,\n    0x0cbce225,\n    0x65e6956e,\n    0x6ee89c63,\n    0x73fa8774,\n    0x78f48e79,\n    0x49deb15a,\n    0x42d0b857,\n    0x5fc2a340,\n    0x54ccaa4d,\n    0xf741ecda,\n    0xfc4fe5d7,\n    0xe15dfec0,\n    0xea53f7cd,\n    0xdb79c8ee,\n    0xd077c1e3,\n    0xcd65daf4,\n    0xc66bd3f9,\n    0xaf31a4b2,\n    0xa43fadbf,\n    0xb92db6a8,\n    0xb223bfa5,\n    0x83098086,\n    0x8807898b,\n    0x9515929c,\n    0x9e1b9b91,\n    0x47a17c0a,\n    0x4caf7507,\n    0x51bd6e10,\n    0x5ab3671d,\n    0x6b99583e,\n    0x60975133,\n    0x7d854a24,\n    0x768b4329,\n    0x1fd13462,\n    0x14df3d6f,\n    0x09cd2678,\n    0x02c32f75,\n    0x33e91056,\n    0x38e7195b,\n    0x25f5024c,\n    0x2efb0b41,\n    0x8c9ad761,\n    0x8794de6c,\n    0x9a86c57b,\n    0x9188cc76,\n    0xa0a2f355,\n    0xabacfa58,\n    0xb6bee14f,\n    0xbdb0e842,\n    0xd4ea9f09,\n    0xdfe49604,\n    0xc2f68d13,\n    0xc9f8841e,\n    0xf8d2bb3d,\n    0xf3dcb230,\n    0xeecea927,\n    0xe5c0a02a,\n    0x3c7a47b1,\n    0x37744ebc,\n    0x2a6655ab,\n    0x21685ca6,\n    0x10426385,\n    0x1b4c6a88,\n    0x065e719f,\n    0x0d507892,\n    0x640a0fd9,\n    0x6f0406d4,\n    0x72161dc3,\n    0x791814ce,\n    0x48322bed,\n    0x433c22e0,\n    0x5e2e39f7,\n    0x552030fa,\n    0x01ec9ab7,\n    0x0ae293ba,\n    0x17f088ad,\n    0x1cfe81a0,\n    0x2dd4be83,\n    0x26dab78e,\n    0x3bc8ac99,\n    0x30c6a594,\n    0x599cd2df,\n    0x5292dbd2,\n    0x4f80c0c5,\n    0x448ec9c8,\n    0x75a4f6eb,\n    0x7eaaffe6,\n    0x63b8e4f1,\n    0x68b6edfc,\n    0xb10c0a67,\n    0xba02036a,\n    0xa710187d,\n    0xac1e1170,\n    0x9d342e53,\n    0x963a275e,\n    0x8b283c49,\n    0x80263544,\n    0xe97c420f,\n    0xe2724b02,\n    0xff605015,\n    0xf46e5918,\n    0xc544663b,\n    0xce4a6f36,\n    0xd3587421,\n    0xd8567d2c,\n    0x7a37a10c,\n    0x7139a801,\n    0x6c2bb316,\n    0x6725ba1b,\n    0x560f8538,\n    0x5d018c35,\n    0x40139722,\n    0x4b1d9e2f,\n    0x2247e964,\n    0x2949e069,\n    0x345bfb7e,\n    0x3f55f273,\n    0x0e7fcd50,\n    0x0571c45d,\n    0x1863df4a,\n    0x136dd647,\n    0xcad731dc,\n    0xc1d938d1,\n    0xdccb23c6,\n    0xd7c52acb,\n    0xe6ef15e8,\n    0xede11ce5,\n    0xf0f307f2,\n    0xfbfd0eff,\n    0x92a779b4,\n    0x99a970b9,\n    0x84bb6bae,\n    0x8fb562a3,\n    0xbe9f5d80,\n    0xb591548d,\n    0xa8834f9a,\n    0xa38d4697\n];\nconst U3 = [\n    0x00000000,\n    0x0d0b0e09,\n    0x1a161c12,\n    0x171d121b,\n    0x342c3824,\n    0x3927362d,\n    0x2e3a2436,\n    0x23312a3f,\n    0x68587048,\n    0x65537e41,\n    0x724e6c5a,\n    0x7f456253,\n    0x5c74486c,\n    0x517f4665,\n    0x4662547e,\n    0x4b695a77,\n    0xd0b0e090,\n    0xddbbee99,\n    0xcaa6fc82,\n    0xc7adf28b,\n    0xe49cd8b4,\n    0xe997d6bd,\n    0xfe8ac4a6,\n    0xf381caaf,\n    0xb8e890d8,\n    0xb5e39ed1,\n    0xa2fe8cca,\n    0xaff582c3,\n    0x8cc4a8fc,\n    0x81cfa6f5,\n    0x96d2b4ee,\n    0x9bd9bae7,\n    0xbb7bdb3b,\n    0xb670d532,\n    0xa16dc729,\n    0xac66c920,\n    0x8f57e31f,\n    0x825ced16,\n    0x9541ff0d,\n    0x984af104,\n    0xd323ab73,\n    0xde28a57a,\n    0xc935b761,\n    0xc43eb968,\n    0xe70f9357,\n    0xea049d5e,\n    0xfd198f45,\n    0xf012814c,\n    0x6bcb3bab,\n    0x66c035a2,\n    0x71dd27b9,\n    0x7cd629b0,\n    0x5fe7038f,\n    0x52ec0d86,\n    0x45f11f9d,\n    0x48fa1194,\n    0x03934be3,\n    0x0e9845ea,\n    0x198557f1,\n    0x148e59f8,\n    0x37bf73c7,\n    0x3ab47dce,\n    0x2da96fd5,\n    0x20a261dc,\n    0x6df6ad76,\n    0x60fda37f,\n    0x77e0b164,\n    0x7aebbf6d,\n    0x59da9552,\n    0x54d19b5b,\n    0x43cc8940,\n    0x4ec78749,\n    0x05aedd3e,\n    0x08a5d337,\n    0x1fb8c12c,\n    0x12b3cf25,\n    0x3182e51a,\n    0x3c89eb13,\n    0x2b94f908,\n    0x269ff701,\n    0xbd464de6,\n    0xb04d43ef,\n    0xa75051f4,\n    0xaa5b5ffd,\n    0x896a75c2,\n    0x84617bcb,\n    0x937c69d0,\n    0x9e7767d9,\n    0xd51e3dae,\n    0xd81533a7,\n    0xcf0821bc,\n    0xc2032fb5,\n    0xe132058a,\n    0xec390b83,\n    0xfb241998,\n    0xf62f1791,\n    0xd68d764d,\n    0xdb867844,\n    0xcc9b6a5f,\n    0xc1906456,\n    0xe2a14e69,\n    0xefaa4060,\n    0xf8b7527b,\n    0xf5bc5c72,\n    0xbed50605,\n    0xb3de080c,\n    0xa4c31a17,\n    0xa9c8141e,\n    0x8af93e21,\n    0x87f23028,\n    0x90ef2233,\n    0x9de42c3a,\n    0x063d96dd,\n    0x0b3698d4,\n    0x1c2b8acf,\n    0x112084c6,\n    0x3211aef9,\n    0x3f1aa0f0,\n    0x2807b2eb,\n    0x250cbce2,\n    0x6e65e695,\n    0x636ee89c,\n    0x7473fa87,\n    0x7978f48e,\n    0x5a49deb1,\n    0x5742d0b8,\n    0x405fc2a3,\n    0x4d54ccaa,\n    0xdaf741ec,\n    0xd7fc4fe5,\n    0xc0e15dfe,\n    0xcdea53f7,\n    0xeedb79c8,\n    0xe3d077c1,\n    0xf4cd65da,\n    0xf9c66bd3,\n    0xb2af31a4,\n    0xbfa43fad,\n    0xa8b92db6,\n    0xa5b223bf,\n    0x86830980,\n    0x8b880789,\n    0x9c951592,\n    0x919e1b9b,\n    0x0a47a17c,\n    0x074caf75,\n    0x1051bd6e,\n    0x1d5ab367,\n    0x3e6b9958,\n    0x33609751,\n    0x247d854a,\n    0x29768b43,\n    0x621fd134,\n    0x6f14df3d,\n    0x7809cd26,\n    0x7502c32f,\n    0x5633e910,\n    0x5b38e719,\n    0x4c25f502,\n    0x412efb0b,\n    0x618c9ad7,\n    0x6c8794de,\n    0x7b9a86c5,\n    0x769188cc,\n    0x55a0a2f3,\n    0x58abacfa,\n    0x4fb6bee1,\n    0x42bdb0e8,\n    0x09d4ea9f,\n    0x04dfe496,\n    0x13c2f68d,\n    0x1ec9f884,\n    0x3df8d2bb,\n    0x30f3dcb2,\n    0x27eecea9,\n    0x2ae5c0a0,\n    0xb13c7a47,\n    0xbc37744e,\n    0xab2a6655,\n    0xa621685c,\n    0x85104263,\n    0x881b4c6a,\n    0x9f065e71,\n    0x920d5078,\n    0xd9640a0f,\n    0xd46f0406,\n    0xc372161d,\n    0xce791814,\n    0xed48322b,\n    0xe0433c22,\n    0xf75e2e39,\n    0xfa552030,\n    0xb701ec9a,\n    0xba0ae293,\n    0xad17f088,\n    0xa01cfe81,\n    0x832dd4be,\n    0x8e26dab7,\n    0x993bc8ac,\n    0x9430c6a5,\n    0xdf599cd2,\n    0xd25292db,\n    0xc54f80c0,\n    0xc8448ec9,\n    0xeb75a4f6,\n    0xe67eaaff,\n    0xf163b8e4,\n    0xfc68b6ed,\n    0x67b10c0a,\n    0x6aba0203,\n    0x7da71018,\n    0x70ac1e11,\n    0x539d342e,\n    0x5e963a27,\n    0x498b283c,\n    0x44802635,\n    0x0fe97c42,\n    0x02e2724b,\n    0x15ff6050,\n    0x18f46e59,\n    0x3bc54466,\n    0x36ce4a6f,\n    0x21d35874,\n    0x2cd8567d,\n    0x0c7a37a1,\n    0x017139a8,\n    0x166c2bb3,\n    0x1b6725ba,\n    0x38560f85,\n    0x355d018c,\n    0x22401397,\n    0x2f4b1d9e,\n    0x642247e9,\n    0x692949e0,\n    0x7e345bfb,\n    0x733f55f2,\n    0x500e7fcd,\n    0x5d0571c4,\n    0x4a1863df,\n    0x47136dd6,\n    0xdccad731,\n    0xd1c1d938,\n    0xc6dccb23,\n    0xcbd7c52a,\n    0xe8e6ef15,\n    0xe5ede11c,\n    0xf2f0f307,\n    0xfffbfd0e,\n    0xb492a779,\n    0xb999a970,\n    0xae84bb6b,\n    0xa38fb562,\n    0x80be9f5d,\n    0x8db59154,\n    0x9aa8834f,\n    0x97a38d46\n];\nconst U4 = [\n    0x00000000,\n    0x090d0b0e,\n    0x121a161c,\n    0x1b171d12,\n    0x24342c38,\n    0x2d392736,\n    0x362e3a24,\n    0x3f23312a,\n    0x48685870,\n    0x4165537e,\n    0x5a724e6c,\n    0x537f4562,\n    0x6c5c7448,\n    0x65517f46,\n    0x7e466254,\n    0x774b695a,\n    0x90d0b0e0,\n    0x99ddbbee,\n    0x82caa6fc,\n    0x8bc7adf2,\n    0xb4e49cd8,\n    0xbde997d6,\n    0xa6fe8ac4,\n    0xaff381ca,\n    0xd8b8e890,\n    0xd1b5e39e,\n    0xcaa2fe8c,\n    0xc3aff582,\n    0xfc8cc4a8,\n    0xf581cfa6,\n    0xee96d2b4,\n    0xe79bd9ba,\n    0x3bbb7bdb,\n    0x32b670d5,\n    0x29a16dc7,\n    0x20ac66c9,\n    0x1f8f57e3,\n    0x16825ced,\n    0x0d9541ff,\n    0x04984af1,\n    0x73d323ab,\n    0x7ade28a5,\n    0x61c935b7,\n    0x68c43eb9,\n    0x57e70f93,\n    0x5eea049d,\n    0x45fd198f,\n    0x4cf01281,\n    0xab6bcb3b,\n    0xa266c035,\n    0xb971dd27,\n    0xb07cd629,\n    0x8f5fe703,\n    0x8652ec0d,\n    0x9d45f11f,\n    0x9448fa11,\n    0xe303934b,\n    0xea0e9845,\n    0xf1198557,\n    0xf8148e59,\n    0xc737bf73,\n    0xce3ab47d,\n    0xd52da96f,\n    0xdc20a261,\n    0x766df6ad,\n    0x7f60fda3,\n    0x6477e0b1,\n    0x6d7aebbf,\n    0x5259da95,\n    0x5b54d19b,\n    0x4043cc89,\n    0x494ec787,\n    0x3e05aedd,\n    0x3708a5d3,\n    0x2c1fb8c1,\n    0x2512b3cf,\n    0x1a3182e5,\n    0x133c89eb,\n    0x082b94f9,\n    0x01269ff7,\n    0xe6bd464d,\n    0xefb04d43,\n    0xf4a75051,\n    0xfdaa5b5f,\n    0xc2896a75,\n    0xcb84617b,\n    0xd0937c69,\n    0xd99e7767,\n    0xaed51e3d,\n    0xa7d81533,\n    0xbccf0821,\n    0xb5c2032f,\n    0x8ae13205,\n    0x83ec390b,\n    0x98fb2419,\n    0x91f62f17,\n    0x4dd68d76,\n    0x44db8678,\n    0x5fcc9b6a,\n    0x56c19064,\n    0x69e2a14e,\n    0x60efaa40,\n    0x7bf8b752,\n    0x72f5bc5c,\n    0x05bed506,\n    0x0cb3de08,\n    0x17a4c31a,\n    0x1ea9c814,\n    0x218af93e,\n    0x2887f230,\n    0x3390ef22,\n    0x3a9de42c,\n    0xdd063d96,\n    0xd40b3698,\n    0xcf1c2b8a,\n    0xc6112084,\n    0xf93211ae,\n    0xf03f1aa0,\n    0xeb2807b2,\n    0xe2250cbc,\n    0x956e65e6,\n    0x9c636ee8,\n    0x877473fa,\n    0x8e7978f4,\n    0xb15a49de,\n    0xb85742d0,\n    0xa3405fc2,\n    0xaa4d54cc,\n    0xecdaf741,\n    0xe5d7fc4f,\n    0xfec0e15d,\n    0xf7cdea53,\n    0xc8eedb79,\n    0xc1e3d077,\n    0xdaf4cd65,\n    0xd3f9c66b,\n    0xa4b2af31,\n    0xadbfa43f,\n    0xb6a8b92d,\n    0xbfa5b223,\n    0x80868309,\n    0x898b8807,\n    0x929c9515,\n    0x9b919e1b,\n    0x7c0a47a1,\n    0x75074caf,\n    0x6e1051bd,\n    0x671d5ab3,\n    0x583e6b99,\n    0x51336097,\n    0x4a247d85,\n    0x4329768b,\n    0x34621fd1,\n    0x3d6f14df,\n    0x267809cd,\n    0x2f7502c3,\n    0x105633e9,\n    0x195b38e7,\n    0x024c25f5,\n    0x0b412efb,\n    0xd7618c9a,\n    0xde6c8794,\n    0xc57b9a86,\n    0xcc769188,\n    0xf355a0a2,\n    0xfa58abac,\n    0xe14fb6be,\n    0xe842bdb0,\n    0x9f09d4ea,\n    0x9604dfe4,\n    0x8d13c2f6,\n    0x841ec9f8,\n    0xbb3df8d2,\n    0xb230f3dc,\n    0xa927eece,\n    0xa02ae5c0,\n    0x47b13c7a,\n    0x4ebc3774,\n    0x55ab2a66,\n    0x5ca62168,\n    0x63851042,\n    0x6a881b4c,\n    0x719f065e,\n    0x78920d50,\n    0x0fd9640a,\n    0x06d46f04,\n    0x1dc37216,\n    0x14ce7918,\n    0x2bed4832,\n    0x22e0433c,\n    0x39f75e2e,\n    0x30fa5520,\n    0x9ab701ec,\n    0x93ba0ae2,\n    0x88ad17f0,\n    0x81a01cfe,\n    0xbe832dd4,\n    0xb78e26da,\n    0xac993bc8,\n    0xa59430c6,\n    0xd2df599c,\n    0xdbd25292,\n    0xc0c54f80,\n    0xc9c8448e,\n    0xf6eb75a4,\n    0xffe67eaa,\n    0xe4f163b8,\n    0xedfc68b6,\n    0x0a67b10c,\n    0x036aba02,\n    0x187da710,\n    0x1170ac1e,\n    0x2e539d34,\n    0x275e963a,\n    0x3c498b28,\n    0x35448026,\n    0x420fe97c,\n    0x4b02e272,\n    0x5015ff60,\n    0x5918f46e,\n    0x663bc544,\n    0x6f36ce4a,\n    0x7421d358,\n    0x7d2cd856,\n    0xa10c7a37,\n    0xa8017139,\n    0xb3166c2b,\n    0xba1b6725,\n    0x8538560f,\n    0x8c355d01,\n    0x97224013,\n    0x9e2f4b1d,\n    0xe9642247,\n    0xe0692949,\n    0xfb7e345b,\n    0xf2733f55,\n    0xcd500e7f,\n    0xc45d0571,\n    0xdf4a1863,\n    0xd647136d,\n    0x31dccad7,\n    0x38d1c1d9,\n    0x23c6dccb,\n    0x2acbd7c5,\n    0x15e8e6ef,\n    0x1ce5ede1,\n    0x07f2f0f3,\n    0x0efffbfd,\n    0x79b492a7,\n    0x70b999a9,\n    0x6bae84bb,\n    0x62a38fb5,\n    0x5d80be9f,\n    0x548db591,\n    0x4f9aa883,\n    0x4697a38d\n];\nfunction convertToInt32(bytes) {\n    const result = [];\n    for(let i = 0; i < bytes.length; i += 4){\n        result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);\n    }\n    return result;\n}\nclass AES {\n    get key() {\n        return __classPrivateFieldGet(this, _AES_key, \"f\").slice();\n    }\n    constructor(key){\n        _AES_key.set(this, void 0);\n        _AES_Kd.set(this, void 0);\n        _AES_Ke.set(this, void 0);\n        if (!(this instanceof AES)) {\n            throw Error(\"AES must be instanitated with `new`\");\n        }\n        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), \"f\");\n        const rounds = numberOfRounds[this.key.length];\n        if (rounds == null) {\n            throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\");\n        }\n        // encryption round keys\n        __classPrivateFieldSet(this, _AES_Ke, [], \"f\");\n        // decryption round keys\n        __classPrivateFieldSet(this, _AES_Kd, [], \"f\");\n        for(let i = 0; i <= rounds; i++){\n            __classPrivateFieldGet(this, _AES_Ke, \"f\").push([\n                0,\n                0,\n                0,\n                0\n            ]);\n            __classPrivateFieldGet(this, _AES_Kd, \"f\").push([\n                0,\n                0,\n                0,\n                0\n            ]);\n        }\n        const roundKeyCount = (rounds + 1) * 4;\n        const KC = this.key.length / 4;\n        // convert the key into ints\n        const tk = convertToInt32(this.key);\n        // copy values into round key arrays\n        let index;\n        for(let i = 0; i < KC; i++){\n            index = i >> 2;\n            __classPrivateFieldGet(this, _AES_Ke, \"f\")[index][i % 4] = tk[i];\n            __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - index][i % 4] = tk[i];\n        }\n        // key expansion (fips-197 section 5.2)\n        let rconpointer = 0;\n        let t = KC, tt;\n        while(t < roundKeyCount){\n            tt = tk[KC - 1];\n            tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;\n            rconpointer += 1;\n            // key expansion (for non-256 bit)\n            if (KC != 8) {\n                for(let i = 1; i < KC; i++){\n                    tk[i] ^= tk[i - 1];\n                }\n            // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            } else {\n                for(let i = 1; i < KC / 2; i++){\n                    tk[i] ^= tk[i - 1];\n                }\n                tt = tk[KC / 2 - 1];\n                tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;\n                for(let i = KC / 2 + 1; i < KC; i++){\n                    tk[i] ^= tk[i - 1];\n                }\n            }\n            // copy values into round key arrays\n            let i = 0, r, c;\n            while(i < KC && t < roundKeyCount){\n                r = t >> 2;\n                c = t % 4;\n                __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][c] = tk[i];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - r][c] = tk[i++];\n                t++;\n            }\n        }\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for(let r = 1; r < rounds; r++){\n            for(let c = 0; c < 4; c++){\n                tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];\n            }\n        }\n    }\n    encrypt(plaintext) {\n        if (plaintext.length != 16) {\n            throw new TypeError(\"invalid plaintext size (must be 16 bytes)\");\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Ke, \"f\").length - 1;\n        const a = [\n            0,\n            0,\n            0,\n            0\n        ];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(plaintext);\n        for(let i = 0; i < 4; i++){\n            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, \"f\")[0][i];\n        }\n        // apply round transforms\n        for(let r = 1; r < rounds; r++){\n            for(let i = 0; i < 4; i++){\n                a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][i];\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for(let i = 0; i < 4; i++){\n            tt = __classPrivateFieldGet(this, _AES_Ke, \"f\")[rounds][i];\n            result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;\n            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;\n            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length != 16) {\n            throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\");\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Kd, \"f\").length - 1;\n        const a = [\n            0,\n            0,\n            0,\n            0\n        ];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(ciphertext);\n        for(let i = 0; i < 4; i++){\n            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, \"f\")[0][i];\n        }\n        // apply round transforms\n        for(let r = 1; r < rounds; r++){\n            for(let i = 0; i < 4; i++){\n                a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][i];\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for(let i = 0; i < 4; i++){\n            tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds][i];\n            result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;\n            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;\n            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n}\n_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap(); //# sourceMappingURL=aes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vYWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxxRkFBcUYsR0FDckYsSUFBSUEseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDTixZQUFZRyxJQUFJQSxFQUFFSSxLQUFLLEdBQUdOLE1BQU1PLEdBQUcsQ0FBQ1I7QUFDeEY7QUFDQSxJQUFJUyx5QkFBeUIsU0FBSyxJQUFJLFNBQUksQ0FBQ0Esc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVNLEtBQUssRUFBRUwsSUFBSSxFQUFFQyxDQUFDO0lBQzNHLElBQUlELFNBQVMsS0FBSyxNQUFNLElBQUlFLFVBQVU7SUFDdEMsSUFBSUYsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPLFNBQVUsTUFBTUQsRUFBRUcsSUFBSSxDQUFDTixVQUFVTyxTQUFTSixJQUFJQSxFQUFFSSxLQUFLLEdBQUdBLFFBQVFOLE1BQU1TLEdBQUcsQ0FBQ1YsVUFBVU8sUUFBU0E7QUFDeEc7QUFDQSxJQUFJSSxVQUFVQyxTQUFTQztBQUN2Qiw4QkFBOEI7QUFDOUIsTUFBTUMsaUJBQWlCO0lBQUUsSUFBSTtJQUFJLElBQUk7SUFBSSxJQUFJO0FBQUc7QUFDaEQsdUJBQXVCO0FBQ3ZCLE1BQU1DLE9BQU87SUFBQztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FBSztBQUNqTSxrREFBa0Q7QUFDbEQsTUFBTUMsSUFBSTtJQUFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFDMWdELE1BQU1DLEtBQUs7SUFBQztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUFLO0FBQzNnRCxpQ0FBaUM7QUFDakMsTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLGlDQUFpQztBQUNqQyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csK0NBQStDO0FBQy9DLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7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RSxJQUFJLElBQUssS0FBSyxHQUFJZ0IsTUFBTSxDQUFDLElBQUs7WUFDckVqQixNQUFNLENBQUMsSUFBSUMsSUFBSSxFQUFFLEdBQUcsQ0FBQ2hCLEVBQUUsQ0FBQytCLENBQUMsQ0FBQyxDQUFDZixJQUFJLEtBQUssRUFBRSxHQUFHLEtBQUssR0FBR2dCLEVBQUMsSUFBSztRQUMzRDtRQUNBLE9BQU9qQjtJQUNYO0FBQ0o7QUFDQXJCLFdBQVcsSUFBSThDLFdBQVc3QyxVQUFVLElBQUk2QyxXQUFXNUMsVUFBVSxJQUFJNEMsV0FDakUsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL2Flcy5qcz85ZGU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBNSVQgTGljZW5zZS4gQ29weXJpZ2h0IDIwMTUtMjAyMiBSaWNoYXJkIE1vb3JlIDxtZUByaWNtb28uY29tPi4gU2VlIExJQ0VOU0UudHh0LiAqL1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9BRVNfa2V5LCBfQUVTX0tkLCBfQUVTX0tlO1xuLy8gTnVtYmVyIG9mIHJvdW5kcyBieSBrZXlzaXplXG5jb25zdCBudW1iZXJPZlJvdW5kcyA9IHsgMTY6IDEwLCAyNDogMTIsIDMyOiAxNCB9O1xuLy8gUm91bmQgY29uc3RhbnQgd29yZHNcbmNvbnN0IHJjb24gPSBbMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSwgMHgyZiwgMHg1ZSwgMHhiYywgMHg2MywgMHhjNiwgMHg5NywgMHgzNSwgMHg2YSwgMHhkNCwgMHhiMywgMHg3ZCwgMHhmYSwgMHhlZiwgMHhjNSwgMHg5MV07XG4vLyBTLWJveCBhbmQgSW52ZXJzZSBTLWJveCAoUyBpcyBmb3IgU3Vic3RpdHV0aW9uKVxuY29uc3QgUyA9IFsweDYzLCAweDdjLCAweDc3LCAweDdiLCAweGYyLCAweDZiLCAweDZmLCAweGM1LCAweDMwLCAweDAxLCAweDY3LCAweDJiLCAweGZlLCAweGQ3LCAweGFiLCAweDc2LCAweGNhLCAweDgyLCAweGM5LCAweDdkLCAweGZhLCAweDU5LCAweDQ3LCAweGYwLCAweGFkLCAweGQ0LCAweGEyLCAweGFmLCAweDljLCAweGE0LCAweDcyLCAweGMwLCAweGI3LCAweGZkLCAweDkzLCAweDI2LCAweDM2LCAweDNmLCAweGY3LCAweGNjLCAweDM0LCAweGE1LCAweGU1LCAweGYxLCAweDcxLCAweGQ4LCAweDMxLCAweDE1LCAweDA0LCAweGM3LCAweDIzLCAweGMzLCAweDE4LCAweDk2LCAweDA1LCAweDlhLCAweDA3LCAweDEyLCAweDgwLCAweGUyLCAweGViLCAweDI3LCAweGIyLCAweDc1LCAweDA5LCAweDgzLCAweDJjLCAweDFhLCAweDFiLCAweDZlLCAweDVhLCAweGEwLCAweDUyLCAweDNiLCAweGQ2LCAweGIzLCAweDI5LCAweGUzLCAweDJmLCAweDg0LCAweDUzLCAweGQxLCAweDAwLCAweGVkLCAweDIwLCAweGZjLCAweGIxLCAweDViLCAweDZhLCAweGNiLCAweGJlLCAweDM5LCAweDRhLCAweDRjLCAweDU4LCAweGNmLCAweGQwLCAweGVmLCAweGFhLCAweGZiLCAweDQzLCAweDRkLCAweDMzLCAweDg1LCAweDQ1LCAweGY5LCAweDAyLCAweDdmLCAweDUwLCAweDNjLCAweDlmLCAweGE4LCAweDUxLCAweGEzLCAweDQwLCAweDhmLCAweDkyLCAweDlkLCAweDM4LCAweGY1LCAweGJjLCAweGI2LCAweGRhLCAweDIxLCAweDEwLCAweGZmLCAweGYzLCAweGQyLCAweGNkLCAweDBjLCAweDEzLCAweGVjLCAweDVmLCAweDk3LCAweDQ0LCAweDE3LCAweGM0LCAweGE3LCAweDdlLCAweDNkLCAweDY0LCAweDVkLCAweDE5LCAweDczLCAweDYwLCAweDgxLCAweDRmLCAweGRjLCAweDIyLCAweDJhLCAweDkwLCAweDg4LCAweDQ2LCAweGVlLCAweGI4LCAweDE0LCAweGRlLCAweDVlLCAweDBiLCAweGRiLCAweGUwLCAweDMyLCAweDNhLCAweDBhLCAweDQ5LCAweDA2LCAweDI0LCAweDVjLCAweGMyLCAweGQzLCAweGFjLCAweDYyLCAweDkxLCAweDk1LCAweGU0LCAweDc5LCAweGU3LCAweGM4LCAweDM3LCAweDZkLCAweDhkLCAweGQ1LCAweDRlLCAweGE5LCAweDZjLCAweDU2LCAweGY0LCAweGVhLCAweDY1LCAweDdhLCAweGFlLCAweDA4LCAweGJhLCAweDc4LCAweDI1LCAweDJlLCAweDFjLCAweGE2LCAweGI0LCAweGM2LCAweGU4LCAweGRkLCAweDc0LCAweDFmLCAweDRiLCAweGJkLCAweDhiLCAweDhhLCAweDcwLCAweDNlLCAweGI1LCAweDY2LCAweDQ4LCAweDAzLCAweGY2LCAweDBlLCAweDYxLCAweDM1LCAweDU3LCAweGI5LCAweDg2LCAweGMxLCAweDFkLCAweDllLCAweGUxLCAweGY4LCAweDk4LCAweDExLCAweDY5LCAweGQ5LCAweDhlLCAweDk0LCAweDliLCAweDFlLCAweDg3LCAweGU5LCAweGNlLCAweDU1LCAweDI4LCAweGRmLCAweDhjLCAweGExLCAweDg5LCAweDBkLCAweGJmLCAweGU2LCAweDQyLCAweDY4LCAweDQxLCAweDk5LCAweDJkLCAweDBmLCAweGIwLCAweDU0LCAweGJiLCAweDE2XTtcbmNvbnN0IFNpID0gWzB4NTIsIDB4MDksIDB4NmEsIDB4ZDUsIDB4MzAsIDB4MzYsIDB4YTUsIDB4MzgsIDB4YmYsIDB4NDAsIDB4YTMsIDB4OWUsIDB4ODEsIDB4ZjMsIDB4ZDcsIDB4ZmIsIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsIDB4NTQsIDB4N2IsIDB4OTQsIDB4MzIsIDB4YTYsIDB4YzIsIDB4MjMsIDB4M2QsIDB4ZWUsIDB4NGMsIDB4OTUsIDB4MGIsIDB4NDIsIDB4ZmEsIDB4YzMsIDB4NGUsIDB4MDgsIDB4MmUsIDB4YTEsIDB4NjYsIDB4MjgsIDB4ZDksIDB4MjQsIDB4YjIsIDB4NzYsIDB4NWIsIDB4YTIsIDB4NDksIDB4NmQsIDB4OGIsIDB4ZDEsIDB4MjUsIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsIDB4NmMsIDB4NzAsIDB4NDgsIDB4NTAsIDB4ZmQsIDB4ZWQsIDB4YjksIDB4ZGEsIDB4NWUsIDB4MTUsIDB4NDYsIDB4NTcsIDB4YTcsIDB4OGQsIDB4OWQsIDB4ODQsIDB4OTAsIDB4ZDgsIDB4YWIsIDB4MDAsIDB4OGMsIDB4YmMsIDB4ZDMsIDB4MGEsIDB4ZjcsIDB4ZTQsIDB4NTgsIDB4MDUsIDB4YjgsIDB4YjMsIDB4NDUsIDB4MDYsIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsIDB4M2EsIDB4OTEsIDB4MTEsIDB4NDEsIDB4NGYsIDB4NjcsIDB4ZGMsIDB4ZWEsIDB4OTcsIDB4ZjIsIDB4Y2YsIDB4Y2UsIDB4ZjAsIDB4YjQsIDB4ZTYsIDB4NzMsIDB4OTYsIDB4YWMsIDB4NzQsIDB4MjIsIDB4ZTcsIDB4YWQsIDB4MzUsIDB4ODUsIDB4ZTIsIDB4ZjksIDB4MzcsIDB4ZTgsIDB4MWMsIDB4NzUsIDB4ZGYsIDB4NmUsIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsIDB4ZmMsIDB4NTYsIDB4M2UsIDB4NGIsIDB4YzYsIDB4ZDIsIDB4NzksIDB4MjAsIDB4OWEsIDB4ZGIsIDB4YzAsIDB4ZmUsIDB4NzgsIDB4Y2QsIDB4NWEsIDB4ZjQsIDB4MWYsIDB4ZGQsIDB4YTgsIDB4MzMsIDB4ODgsIDB4MDcsIDB4YzcsIDB4MzEsIDB4YjEsIDB4MTIsIDB4MTAsIDB4NTksIDB4MjcsIDB4ODAsIDB4ZWMsIDB4NWYsIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsIDB4YTAsIDB4ZTAsIDB4M2IsIDB4NGQsIDB4YWUsIDB4MmEsIDB4ZjUsIDB4YjAsIDB4YzgsIDB4ZWIsIDB4YmIsIDB4M2MsIDB4ODMsIDB4NTMsIDB4OTksIDB4NjEsIDB4MTcsIDB4MmIsIDB4MDQsIDB4N2UsIDB4YmEsIDB4NzcsIDB4ZDYsIDB4MjYsIDB4ZTEsIDB4NjksIDB4MTQsIDB4NjMsIDB4NTUsIDB4MjEsIDB4MGMsIDB4N2RdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBlbmNyeXB0aW9uXG5jb25zdCBUMSA9IFsweGM2NjM2M2E1LCAweGY4N2M3Yzg0LCAweGVlNzc3Nzk5LCAweGY2N2I3YjhkLCAweGZmZjJmMjBkLCAweGQ2NmI2YmJkLCAweGRlNmY2ZmIxLCAweDkxYzVjNTU0LCAweDYwMzAzMDUwLCAweDAyMDEwMTAzLCAweGNlNjc2N2E5LCAweDU2MmIyYjdkLCAweGU3ZmVmZTE5LCAweGI1ZDdkNzYyLCAweDRkYWJhYmU2LCAweGVjNzY3NjlhLCAweDhmY2FjYTQ1LCAweDFmODI4MjlkLCAweDg5YzljOTQwLCAweGZhN2Q3ZDg3LCAweGVmZmFmYTE1LCAweGIyNTk1OWViLCAweDhlNDc0N2M5LCAweGZiZjBmMDBiLCAweDQxYWRhZGVjLCAweGIzZDRkNDY3LCAweDVmYTJhMmZkLCAweDQ1YWZhZmVhLCAweDIzOWM5Y2JmLCAweDUzYTRhNGY3LCAweGU0NzI3Mjk2LCAweDliYzBjMDViLCAweDc1YjdiN2MyLCAweGUxZmRmZDFjLCAweDNkOTM5M2FlLCAweDRjMjYyNjZhLCAweDZjMzYzNjVhLCAweDdlM2YzZjQxLCAweGY1ZjdmNzAyLCAweDgzY2NjYzRmLCAweDY4MzQzNDVjLCAweDUxYTVhNWY0LCAweGQxZTVlNTM0LCAweGY5ZjFmMTA4LCAweGUyNzE3MTkzLCAweGFiZDhkODczLCAweDYyMzEzMTUzLCAweDJhMTUxNTNmLCAweDA4MDQwNDBjLCAweDk1YzdjNzUyLCAweDQ2MjMyMzY1LCAweDlkYzNjMzVlLCAweDMwMTgxODI4LCAweDM3OTY5NmExLCAweDBhMDUwNTBmLCAweDJmOWE5YWI1LCAweDBlMDcwNzA5LCAweDI0MTIxMjM2LCAweDFiODA4MDliLCAweGRmZTJlMjNkLCAweGNkZWJlYjI2LCAweDRlMjcyNzY5LCAweDdmYjJiMmNkLCAweGVhNzU3NTlmLCAweDEyMDkwOTFiLCAweDFkODM4MzllLCAweDU4MmMyYzc0LCAweDM0MWExYTJlLCAweDM2MWIxYjJkLCAweGRjNmU2ZWIyLCAweGI0NWE1YWVlLCAweDViYTBhMGZiLCAweGE0NTI1MmY2LCAweDc2M2IzYjRkLCAweGI3ZDZkNjYxLCAweDdkYjNiM2NlLCAweDUyMjkyOTdiLCAweGRkZTNlMzNlLCAweDVlMmYyZjcxLCAweDEzODQ4NDk3LCAweGE2NTM1M2Y1LCAweGI5ZDFkMTY4LCAweDAwMDAwMDAwLCAweGMxZWRlZDJjLCAweDQwMjAyMDYwLCAweGUzZmNmYzFmLCAweDc5YjFiMWM4LCAweGI2NWI1YmVkLCAweGQ0NmE2YWJlLCAweDhkY2JjYjQ2LCAweDY3YmViZWQ5LCAweDcyMzkzOTRiLCAweDk0NGE0YWRlLCAweDk4NGM0Y2Q0LCAweGIwNTg1OGU4LCAweDg1Y2ZjZjRhLCAweGJiZDBkMDZiLCAweGM1ZWZlZjJhLCAweDRmYWFhYWU1LCAweGVkZmJmYjE2LCAweDg2NDM0M2M1LCAweDlhNGQ0ZGQ3LCAweDY2MzMzMzU1LCAweDExODU4NTk0LCAweDhhNDU0NWNmLCAweGU5ZjlmOTEwLCAweDA0MDIwMjA2LCAweGZlN2Y3ZjgxLCAweGEwNTA1MGYwLCAweDc4M2MzYzQ0LCAweDI1OWY5ZmJhLCAweDRiYThhOGUzLCAweGEyNTE1MWYzLCAweDVkYTNhM2ZlLCAweDgwNDA0MGMwLCAweDA1OGY4ZjhhLCAweDNmOTI5MmFkLCAweDIxOWQ5ZGJjLCAweDcwMzgzODQ4LCAweGYxZjVmNTA0LCAweDYzYmNiY2RmLCAweDc3YjZiNmMxLCAweGFmZGFkYTc1LCAweDQyMjEyMTYzLCAweDIwMTAxMDMwLCAweGU1ZmZmZjFhLCAweGZkZjNmMzBlLCAweGJmZDJkMjZkLCAweDgxY2RjZDRjLCAweDE4MGMwYzE0LCAweDI2MTMxMzM1LCAweGMzZWNlYzJmLCAweGJlNWY1ZmUxLCAweDM1OTc5N2EyLCAweDg4NDQ0NGNjLCAweDJlMTcxNzM5LCAweDkzYzRjNDU3LCAweDU1YTdhN2YyLCAweGZjN2U3ZTgyLCAweDdhM2QzZDQ3LCAweGM4NjQ2NGFjLCAweGJhNWQ1ZGU3LCAweDMyMTkxOTJiLCAweGU2NzM3Mzk1LCAweGMwNjA2MGEwLCAweDE5ODE4MTk4LCAweDllNGY0ZmQxLCAweGEzZGNkYzdmLCAweDQ0MjIyMjY2LCAweDU0MmEyYTdlLCAweDNiOTA5MGFiLCAweDBiODg4ODgzLCAweDhjNDY0NmNhLCAweGM3ZWVlZTI5LCAweDZiYjhiOGQzLCAweDI4MTQxNDNjLCAweGE3ZGVkZTc5LCAweGJjNWU1ZWUyLCAweDE2MGIwYjFkLCAweGFkZGJkYjc2LCAweGRiZTBlMDNiLCAweDY0MzIzMjU2LCAweDc0M2EzYTRlLCAweDE0MGEwYTFlLCAweDkyNDk0OWRiLCAweDBjMDYwNjBhLCAweDQ4MjQyNDZjLCAweGI4NWM1Y2U0LCAweDlmYzJjMjVkLCAweGJkZDNkMzZlLCAweDQzYWNhY2VmLCAweGM0NjI2MmE2LCAweDM5OTE5MWE4LCAweDMxOTU5NWE0LCAweGQzZTRlNDM3LCAweGYyNzk3OThiLCAweGQ1ZTdlNzMyLCAweDhiYzhjODQzLCAweDZlMzczNzU5LCAweGRhNmQ2ZGI3LCAweDAxOGQ4ZDhjLCAweGIxZDVkNTY0LCAweDljNGU0ZWQyLCAweDQ5YTlhOWUwLCAweGQ4NmM2Y2I0LCAweGFjNTY1NmZhLCAweGYzZjRmNDA3LCAweGNmZWFlYTI1LCAweGNhNjU2NWFmLCAweGY0N2E3YThlLCAweDQ3YWVhZWU5LCAweDEwMDgwODE4LCAweDZmYmFiYWQ1LCAweGYwNzg3ODg4LCAweDRhMjUyNTZmLCAweDVjMmUyZTcyLCAweDM4MWMxYzI0LCAweDU3YTZhNmYxLCAweDczYjRiNGM3LCAweDk3YzZjNjUxLCAweGNiZThlODIzLCAweGExZGRkZDdjLCAweGU4NzQ3NDljLCAweDNlMWYxZjIxLCAweDk2NGI0YmRkLCAweDYxYmRiZGRjLCAweDBkOGI4Yjg2LCAweDBmOGE4YTg1LCAweGUwNzA3MDkwLCAweDdjM2UzZTQyLCAweDcxYjViNWM0LCAweGNjNjY2NmFhLCAweDkwNDg0OGQ4LCAweDA2MDMwMzA1LCAweGY3ZjZmNjAxLCAweDFjMGUwZTEyLCAweGMyNjE2MWEzLCAweDZhMzUzNTVmLCAweGFlNTc1N2Y5LCAweDY5YjliOWQwLCAweDE3ODY4NjkxLCAweDk5YzFjMTU4LCAweDNhMWQxZDI3LCAweDI3OWU5ZWI5LCAweGQ5ZTFlMTM4LCAweGViZjhmODEzLCAweDJiOTg5OGIzLCAweDIyMTExMTMzLCAweGQyNjk2OWJiLCAweGE5ZDlkOTcwLCAweDA3OGU4ZTg5LCAweDMzOTQ5NGE3LCAweDJkOWI5YmI2LCAweDNjMWUxZTIyLCAweDE1ODc4NzkyLCAweGM5ZTllOTIwLCAweDg3Y2VjZTQ5LCAweGFhNTU1NWZmLCAweDUwMjgyODc4LCAweGE1ZGZkZjdhLCAweDAzOGM4YzhmLCAweDU5YTFhMWY4LCAweDA5ODk4OTgwLCAweDFhMGQwZDE3LCAweDY1YmZiZmRhLCAweGQ3ZTZlNjMxLCAweDg0NDI0MmM2LCAweGQwNjg2OGI4LCAweDgyNDE0MWMzLCAweDI5OTk5OWIwLCAweDVhMmQyZDc3LCAweDFlMGYwZjExLCAweDdiYjBiMGNiLCAweGE4NTQ1NGZjLCAweDZkYmJiYmQ2LCAweDJjMTYxNjNhXTtcbmNvbnN0IFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xuY29uc3QgVDMgPSBbMHg2M2E1YzY2MywgMHg3Yzg0Zjg3YywgMHg3Nzk5ZWU3NywgMHg3YjhkZjY3YiwgMHhmMjBkZmZmMiwgMHg2YmJkZDY2YiwgMHg2ZmIxZGU2ZiwgMHhjNTU0OTFjNSwgMHgzMDUwNjAzMCwgMHgwMTAzMDIwMSwgMHg2N2E5Y2U2NywgMHgyYjdkNTYyYiwgMHhmZTE5ZTdmZSwgMHhkNzYyYjVkNywgMHhhYmU2NGRhYiwgMHg3NjlhZWM3NiwgMHhjYTQ1OGZjYSwgMHg4MjlkMWY4MiwgMHhjOTQwODljOSwgMHg3ZDg3ZmE3ZCwgMHhmYTE1ZWZmYSwgMHg1OWViYjI1OSwgMHg0N2M5OGU0NywgMHhmMDBiZmJmMCwgMHhhZGVjNDFhZCwgMHhkNDY3YjNkNCwgMHhhMmZkNWZhMiwgMHhhZmVhNDVhZiwgMHg5Y2JmMjM5YywgMHhhNGY3NTNhNCwgMHg3Mjk2ZTQ3MiwgMHhjMDViOWJjMCwgMHhiN2MyNzViNywgMHhmZDFjZTFmZCwgMHg5M2FlM2Q5MywgMHgyNjZhNGMyNiwgMHgzNjVhNmMzNiwgMHgzZjQxN2UzZiwgMHhmNzAyZjVmNywgMHhjYzRmODNjYywgMHgzNDVjNjgzNCwgMHhhNWY0NTFhNSwgMHhlNTM0ZDFlNSwgMHhmMTA4ZjlmMSwgMHg3MTkzZTI3MSwgMHhkODczYWJkOCwgMHgzMTUzNjIzMSwgMHgxNTNmMmExNSwgMHgwNDBjMDgwNCwgMHhjNzUyOTVjNywgMHgyMzY1NDYyMywgMHhjMzVlOWRjMywgMHgxODI4MzAxOCwgMHg5NmExMzc5NiwgMHgwNTBmMGEwNSwgMHg5YWI1MmY5YSwgMHgwNzA5MGUwNywgMHgxMjM2MjQxMiwgMHg4MDliMWI4MCwgMHhlMjNkZGZlMiwgMHhlYjI2Y2RlYiwgMHgyNzY5NGUyNywgMHhiMmNkN2ZiMiwgMHg3NTlmZWE3NSwgMHgwOTFiMTIwOSwgMHg4MzllMWQ4MywgMHgyYzc0NTgyYywgMHgxYTJlMzQxYSwgMHgxYjJkMzYxYiwgMHg2ZWIyZGM2ZSwgMHg1YWVlYjQ1YSwgMHhhMGZiNWJhMCwgMHg1MmY2YTQ1MiwgMHgzYjRkNzYzYiwgMHhkNjYxYjdkNiwgMHhiM2NlN2RiMywgMHgyOTdiNTIyOSwgMHhlMzNlZGRlMywgMHgyZjcxNWUyZiwgMHg4NDk3MTM4NCwgMHg1M2Y1YTY1MywgMHhkMTY4YjlkMSwgMHgwMDAwMDAwMCwgMHhlZDJjYzFlZCwgMHgyMDYwNDAyMCwgMHhmYzFmZTNmYywgMHhiMWM4NzliMSwgMHg1YmVkYjY1YiwgMHg2YWJlZDQ2YSwgMHhjYjQ2OGRjYiwgMHhiZWQ5NjdiZSwgMHgzOTRiNzIzOSwgMHg0YWRlOTQ0YSwgMHg0Y2Q0OTg0YywgMHg1OGU4YjA1OCwgMHhjZjRhODVjZiwgMHhkMDZiYmJkMCwgMHhlZjJhYzVlZiwgMHhhYWU1NGZhYSwgMHhmYjE2ZWRmYiwgMHg0M2M1ODY0MywgMHg0ZGQ3OWE0ZCwgMHgzMzU1NjYzMywgMHg4NTk0MTE4NSwgMHg0NWNmOGE0NSwgMHhmOTEwZTlmOSwgMHgwMjA2MDQwMiwgMHg3ZjgxZmU3ZiwgMHg1MGYwYTA1MCwgMHgzYzQ0NzgzYywgMHg5ZmJhMjU5ZiwgMHhhOGUzNGJhOCwgMHg1MWYzYTI1MSwgMHhhM2ZlNWRhMywgMHg0MGMwODA0MCwgMHg4ZjhhMDU4ZiwgMHg5MmFkM2Y5MiwgMHg5ZGJjMjE5ZCwgMHgzODQ4NzAzOCwgMHhmNTA0ZjFmNSwgMHhiY2RmNjNiYywgMHhiNmMxNzdiNiwgMHhkYTc1YWZkYSwgMHgyMTYzNDIyMSwgMHgxMDMwMjAxMCwgMHhmZjFhZTVmZiwgMHhmMzBlZmRmMywgMHhkMjZkYmZkMiwgMHhjZDRjODFjZCwgMHgwYzE0MTgwYywgMHgxMzM1MjYxMywgMHhlYzJmYzNlYywgMHg1ZmUxYmU1ZiwgMHg5N2EyMzU5NywgMHg0NGNjODg0NCwgMHgxNzM5MmUxNywgMHhjNDU3OTNjNCwgMHhhN2YyNTVhNywgMHg3ZTgyZmM3ZSwgMHgzZDQ3N2EzZCwgMHg2NGFjYzg2NCwgMHg1ZGU3YmE1ZCwgMHgxOTJiMzIxOSwgMHg3Mzk1ZTY3MywgMHg2MGEwYzA2MCwgMHg4MTk4MTk4MSwgMHg0ZmQxOWU0ZiwgMHhkYzdmYTNkYywgMHgyMjY2NDQyMiwgMHgyYTdlNTQyYSwgMHg5MGFiM2I5MCwgMHg4ODgzMGI4OCwgMHg0NmNhOGM0NiwgMHhlZTI5YzdlZSwgMHhiOGQzNmJiOCwgMHgxNDNjMjgxNCwgMHhkZTc5YTdkZSwgMHg1ZWUyYmM1ZSwgMHgwYjFkMTYwYiwgMHhkYjc2YWRkYiwgMHhlMDNiZGJlMCwgMHgzMjU2NjQzMiwgMHgzYTRlNzQzYSwgMHgwYTFlMTQwYSwgMHg0OWRiOTI0OSwgMHgwNjBhMGMwNiwgMHgyNDZjNDgyNCwgMHg1Y2U0Yjg1YywgMHhjMjVkOWZjMiwgMHhkMzZlYmRkMywgMHhhY2VmNDNhYywgMHg2MmE2YzQ2MiwgMHg5MWE4Mzk5MSwgMHg5NWE0MzE5NSwgMHhlNDM3ZDNlNCwgMHg3OThiZjI3OSwgMHhlNzMyZDVlNywgMHhjODQzOGJjOCwgMHgzNzU5NmUzNywgMHg2ZGI3ZGE2ZCwgMHg4ZDhjMDE4ZCwgMHhkNTY0YjFkNSwgMHg0ZWQyOWM0ZSwgMHhhOWUwNDlhOSwgMHg2Y2I0ZDg2YywgMHg1NmZhYWM1NiwgMHhmNDA3ZjNmNCwgMHhlYTI1Y2ZlYSwgMHg2NWFmY2E2NSwgMHg3YThlZjQ3YSwgMHhhZWU5NDdhZSwgMHgwODE4MTAwOCwgMHhiYWQ1NmZiYSwgMHg3ODg4ZjA3OCwgMHgyNTZmNGEyNSwgMHgyZTcyNWMyZSwgMHgxYzI0MzgxYywgMHhhNmYxNTdhNiwgMHhiNGM3NzNiNCwgMHhjNjUxOTdjNiwgMHhlODIzY2JlOCwgMHhkZDdjYTFkZCwgMHg3NDljZTg3NCwgMHgxZjIxM2UxZiwgMHg0YmRkOTY0YiwgMHhiZGRjNjFiZCwgMHg4Yjg2MGQ4YiwgMHg4YTg1MGY4YSwgMHg3MDkwZTA3MCwgMHgzZTQyN2MzZSwgMHhiNWM0NzFiNSwgMHg2NmFhY2M2NiwgMHg0OGQ4OTA0OCwgMHgwMzA1MDYwMywgMHhmNjAxZjdmNiwgMHgwZTEyMWMwZSwgMHg2MWEzYzI2MSwgMHgzNTVmNmEzNSwgMHg1N2Y5YWU1NywgMHhiOWQwNjliOSwgMHg4NjkxMTc4NiwgMHhjMTU4OTljMSwgMHgxZDI3M2ExZCwgMHg5ZWI5Mjc5ZSwgMHhlMTM4ZDllMSwgMHhmODEzZWJmOCwgMHg5OGIzMmI5OCwgMHgxMTMzMjIxMSwgMHg2OWJiZDI2OSwgMHhkOTcwYTlkOSwgMHg4ZTg5MDc4ZSwgMHg5NGE3MzM5NCwgMHg5YmI2MmQ5YiwgMHgxZTIyM2MxZSwgMHg4NzkyMTU4NywgMHhlOTIwYzllOSwgMHhjZTQ5ODdjZSwgMHg1NWZmYWE1NSwgMHgyODc4NTAyOCwgMHhkZjdhYTVkZiwgMHg4YzhmMDM4YywgMHhhMWY4NTlhMSwgMHg4OTgwMDk4OSwgMHgwZDE3MWEwZCwgMHhiZmRhNjViZiwgMHhlNjMxZDdlNiwgMHg0MmM2ODQ0MiwgMHg2OGI4ZDA2OCwgMHg0MWMzODI0MSwgMHg5OWIwMjk5OSwgMHgyZDc3NWEyZCwgMHgwZjExMWUwZiwgMHhiMGNiN2JiMCwgMHg1NGZjYTg1NCwgMHhiYmQ2NmRiYiwgMHgxNjNhMmMxNl07XG5jb25zdCBUNCA9IFsweDYzNjNhNWM2LCAweDdjN2M4NGY4LCAweDc3Nzc5OWVlLCAweDdiN2I4ZGY2LCAweGYyZjIwZGZmLCAweDZiNmJiZGQ2LCAweDZmNmZiMWRlLCAweGM1YzU1NDkxLCAweDMwMzA1MDYwLCAweDAxMDEwMzAyLCAweDY3NjdhOWNlLCAweDJiMmI3ZDU2LCAweGZlZmUxOWU3LCAweGQ3ZDc2MmI1LCAweGFiYWJlNjRkLCAweDc2NzY5YWVjLCAweGNhY2E0NThmLCAweDgyODI5ZDFmLCAweGM5Yzk0MDg5LCAweDdkN2Q4N2ZhLCAweGZhZmExNWVmLCAweDU5NTllYmIyLCAweDQ3NDdjOThlLCAweGYwZjAwYmZiLCAweGFkYWRlYzQxLCAweGQ0ZDQ2N2IzLCAweGEyYTJmZDVmLCAweGFmYWZlYTQ1LCAweDljOWNiZjIzLCAweGE0YTRmNzUzLCAweDcyNzI5NmU0LCAweGMwYzA1YjliLCAweGI3YjdjMjc1LCAweGZkZmQxY2UxLCAweDkzOTNhZTNkLCAweDI2MjY2YTRjLCAweDM2MzY1YTZjLCAweDNmM2Y0MTdlLCAweGY3ZjcwMmY1LCAweGNjY2M0ZjgzLCAweDM0MzQ1YzY4LCAweGE1YTVmNDUxLCAweGU1ZTUzNGQxLCAweGYxZjEwOGY5LCAweDcxNzE5M2UyLCAweGQ4ZDg3M2FiLCAweDMxMzE1MzYyLCAweDE1MTUzZjJhLCAweDA0MDQwYzA4LCAweGM3Yzc1Mjk1LCAweDIzMjM2NTQ2LCAweGMzYzM1ZTlkLCAweDE4MTgyODMwLCAweDk2OTZhMTM3LCAweDA1MDUwZjBhLCAweDlhOWFiNTJmLCAweDA3MDcwOTBlLCAweDEyMTIzNjI0LCAweDgwODA5YjFiLCAweGUyZTIzZGRmLCAweGViZWIyNmNkLCAweDI3Mjc2OTRlLCAweGIyYjJjZDdmLCAweDc1NzU5ZmVhLCAweDA5MDkxYjEyLCAweDgzODM5ZTFkLCAweDJjMmM3NDU4LCAweDFhMWEyZTM0LCAweDFiMWIyZDM2LCAweDZlNmViMmRjLCAweDVhNWFlZWI0LCAweGEwYTBmYjViLCAweDUyNTJmNmE0LCAweDNiM2I0ZDc2LCAweGQ2ZDY2MWI3LCAweGIzYjNjZTdkLCAweDI5Mjk3YjUyLCAweGUzZTMzZWRkLCAweDJmMmY3MTVlLCAweDg0ODQ5NzEzLCAweDUzNTNmNWE2LCAweGQxZDE2OGI5LCAweDAwMDAwMDAwLCAweGVkZWQyY2MxLCAweDIwMjA2MDQwLCAweGZjZmMxZmUzLCAweGIxYjFjODc5LCAweDViNWJlZGI2LCAweDZhNmFiZWQ0LCAweGNiY2I0NjhkLCAweGJlYmVkOTY3LCAweDM5Mzk0YjcyLCAweDRhNGFkZTk0LCAweDRjNGNkNDk4LCAweDU4NThlOGIwLCAweGNmY2Y0YTg1LCAweGQwZDA2YmJiLCAweGVmZWYyYWM1LCAweGFhYWFlNTRmLCAweGZiZmIxNmVkLCAweDQzNDNjNTg2LCAweDRkNGRkNzlhLCAweDMzMzM1NTY2LCAweDg1ODU5NDExLCAweDQ1NDVjZjhhLCAweGY5ZjkxMGU5LCAweDAyMDIwNjA0LCAweDdmN2Y4MWZlLCAweDUwNTBmMGEwLCAweDNjM2M0NDc4LCAweDlmOWZiYTI1LCAweGE4YThlMzRiLCAweDUxNTFmM2EyLCAweGEzYTNmZTVkLCAweDQwNDBjMDgwLCAweDhmOGY4YTA1LCAweDkyOTJhZDNmLCAweDlkOWRiYzIxLCAweDM4Mzg0ODcwLCAweGY1ZjUwNGYxLCAweGJjYmNkZjYzLCAweGI2YjZjMTc3LCAweGRhZGE3NWFmLCAweDIxMjE2MzQyLCAweDEwMTAzMDIwLCAweGZmZmYxYWU1LCAweGYzZjMwZWZkLCAweGQyZDI2ZGJmLCAweGNkY2Q0YzgxLCAweDBjMGMxNDE4LCAweDEzMTMzNTI2LCAweGVjZWMyZmMzLCAweDVmNWZlMWJlLCAweDk3OTdhMjM1LCAweDQ0NDRjYzg4LCAweDE3MTczOTJlLCAweGM0YzQ1NzkzLCAweGE3YTdmMjU1LCAweDdlN2U4MmZjLCAweDNkM2Q0NzdhLCAweDY0NjRhY2M4LCAweDVkNWRlN2JhLCAweDE5MTkyYjMyLCAweDczNzM5NWU2LCAweDYwNjBhMGMwLCAweDgxODE5ODE5LCAweDRmNGZkMTllLCAweGRjZGM3ZmEzLCAweDIyMjI2NjQ0LCAweDJhMmE3ZTU0LCAweDkwOTBhYjNiLCAweDg4ODg4MzBiLCAweDQ2NDZjYThjLCAweGVlZWUyOWM3LCAweGI4YjhkMzZiLCAweDE0MTQzYzI4LCAweGRlZGU3OWE3LCAweDVlNWVlMmJjLCAweDBiMGIxZDE2LCAweGRiZGI3NmFkLCAweGUwZTAzYmRiLCAweDMyMzI1NjY0LCAweDNhM2E0ZTc0LCAweDBhMGExZTE0LCAweDQ5NDlkYjkyLCAweDA2MDYwYTBjLCAweDI0MjQ2YzQ4LCAweDVjNWNlNGI4LCAweGMyYzI1ZDlmLCAweGQzZDM2ZWJkLCAweGFjYWNlZjQzLCAweDYyNjJhNmM0LCAweDkxOTFhODM5LCAweDk1OTVhNDMxLCAweGU0ZTQzN2QzLCAweDc5Nzk4YmYyLCAweGU3ZTczMmQ1LCAweGM4Yzg0MzhiLCAweDM3Mzc1OTZlLCAweDZkNmRiN2RhLCAweDhkOGQ4YzAxLCAweGQ1ZDU2NGIxLCAweDRlNGVkMjljLCAweGE5YTllMDQ5LCAweDZjNmNiNGQ4LCAweDU2NTZmYWFjLCAweGY0ZjQwN2YzLCAweGVhZWEyNWNmLCAweDY1NjVhZmNhLCAweDdhN2E4ZWY0LCAweGFlYWVlOTQ3LCAweDA4MDgxODEwLCAweGJhYmFkNTZmLCAweDc4Nzg4OGYwLCAweDI1MjU2ZjRhLCAweDJlMmU3MjVjLCAweDFjMWMyNDM4LCAweGE2YTZmMTU3LCAweGI0YjRjNzczLCAweGM2YzY1MTk3LCAweGU4ZTgyM2NiLCAweGRkZGQ3Y2ExLCAweDc0NzQ5Y2U4LCAweDFmMWYyMTNlLCAweDRiNGJkZDk2LCAweGJkYmRkYzYxLCAweDhiOGI4NjBkLCAweDhhOGE4NTBmLCAweDcwNzA5MGUwLCAweDNlM2U0MjdjLCAweGI1YjVjNDcxLCAweDY2NjZhYWNjLCAweDQ4NDhkODkwLCAweDAzMDMwNTA2LCAweGY2ZjYwMWY3LCAweDBlMGUxMjFjLCAweDYxNjFhM2MyLCAweDM1MzU1ZjZhLCAweDU3NTdmOWFlLCAweGI5YjlkMDY5LCAweDg2ODY5MTE3LCAweGMxYzE1ODk5LCAweDFkMWQyNzNhLCAweDllOWViOTI3LCAweGUxZTEzOGQ5LCAweGY4ZjgxM2ViLCAweDk4OThiMzJiLCAweDExMTEzMzIyLCAweDY5NjliYmQyLCAweGQ5ZDk3MGE5LCAweDhlOGU4OTA3LCAweDk0OTRhNzMzLCAweDliOWJiNjJkLCAweDFlMWUyMjNjLCAweDg3ODc5MjE1LCAweGU5ZTkyMGM5LCAweGNlY2U0OTg3LCAweDU1NTVmZmFhLCAweDI4Mjg3ODUwLCAweGRmZGY3YWE1LCAweDhjOGM4ZjAzLCAweGExYTFmODU5LCAweDg5ODk4MDA5LCAweDBkMGQxNzFhLCAweGJmYmZkYTY1LCAweGU2ZTYzMWQ3LCAweDQyNDJjNjg0LCAweDY4NjhiOGQwLCAweDQxNDFjMzgyLCAweDk5OTliMDI5LCAweDJkMmQ3NzVhLCAweDBmMGYxMTFlLCAweGIwYjBjYjdiLCAweDU0NTRmY2E4LCAweGJiYmJkNjZkLCAweDE2MTYzYTJjXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxuY29uc3QgVDUgPSBbMHg1MWY0YTc1MCwgMHg3ZTQxNjU1MywgMHgxYTE3YTRjMywgMHgzYTI3NWU5NiwgMHgzYmFiNmJjYiwgMHgxZjlkNDVmMSwgMHhhY2ZhNThhYiwgMHg0YmUzMDM5MywgMHgyMDMwZmE1NSwgMHhhZDc2NmRmNiwgMHg4OGNjNzY5MSwgMHhmNTAyNGMyNSwgMHg0ZmU1ZDdmYywgMHhjNTJhY2JkNywgMHgyNjM1NDQ4MCwgMHhiNTYyYTM4ZiwgMHhkZWIxNWE0OSwgMHgyNWJhMWI2NywgMHg0NWVhMGU5OCwgMHg1ZGZlYzBlMSwgMHhjMzJmNzUwMiwgMHg4MTRjZjAxMiwgMHg4ZDQ2OTdhMywgMHg2YmQzZjljNiwgMHgwMzhmNWZlNywgMHgxNTkyOWM5NSwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHhkNGJlODMyZCwgMHg1ODc0MjFkMywgMHg0OWUwNjkyOSwgMHg4ZWM5Yzg0NCwgMHg3NWMyODk2YSwgMHhmNDhlNzk3OCwgMHg5OTU4M2U2YiwgMHgyN2I5NzFkZCwgMHhiZWUxNGZiNiwgMHhmMDg4YWQxNywgMHhjOTIwYWM2NiwgMHg3ZGNlM2FiNCwgMHg2M2RmNGExOCwgMHhlNTFhMzE4MiwgMHg5NzUxMzM2MCwgMHg2MjUzN2Y0NSwgMHhiMTY0NzdlMCwgMHhiYjZiYWU4NCwgMHhmZTgxYTAxYywgMHhmOTA4MmI5NCwgMHg3MDQ4Njg1OCwgMHg4ZjQ1ZmQxOSwgMHg5NGRlNmM4NywgMHg1MjdiZjhiNywgMHhhYjczZDMyMywgMHg3MjRiMDJlMiwgMHhlMzFmOGY1NywgMHg2NjU1YWIyYSwgMHhiMmViMjgwNywgMHgyZmI1YzIwMywgMHg4NmM1N2I5YSwgMHhkMzM3MDhhNSwgMHgzMDI4ODdmMiwgMHgyM2JmYTViMiwgMHgwMjAzNmFiYSwgMHhlZDE2ODI1YywgMHg4YWNmMWMyYiwgMHhhNzc5YjQ5MiwgMHhmMzA3ZjJmMCwgMHg0ZTY5ZTJhMSwgMHg2NWRhZjRjZCwgMHgwNjA1YmVkNSwgMHhkMTM0NjIxZiwgMHhjNGE2ZmU4YSwgMHgzNDJlNTM5ZCwgMHhhMmYzNTVhMCwgMHgwNThhZTEzMiwgMHhhNGY2ZWI3NSwgMHgwYjgzZWMzOSwgMHg0MDYwZWZhYSwgMHg1ZTcxOWYwNiwgMHhiZDZlMTA1MSwgMHgzZTIxOGFmOSwgMHg5NmRkMDYzZCwgMHhkZDNlMDVhZSwgMHg0ZGU2YmQ0NiwgMHg5MTU0OGRiNSwgMHg3MWM0NWQwNSwgMHgwNDA2ZDQ2ZiwgMHg2MDUwMTVmZiwgMHgxOTk4ZmIyNCwgMHhkNmJkZTk5NywgMHg4OTQwNDNjYywgMHg2N2Q5OWU3NywgMHhiMGU4NDJiZCwgMHgwNzg5OGI4OCwgMHhlNzE5NWIzOCwgMHg3OWM4ZWVkYiwgMHhhMTdjMGE0NywgMHg3YzQyMGZlOSwgMHhmODg0MWVjOSwgMHgwMDAwMDAwMCwgMHgwOTgwODY4MywgMHgzMjJiZWQ0OCwgMHgxZTExNzBhYywgMHg2YzVhNzI0ZSwgMHhmZDBlZmZmYiwgMHgwZjg1Mzg1NiwgMHgzZGFlZDUxZSwgMHgzNjJkMzkyNywgMHgwYTBmZDk2NCwgMHg2ODVjYTYyMSwgMHg5YjViNTRkMSwgMHgyNDM2MmUzYSwgMHgwYzBhNjdiMSwgMHg5MzU3ZTcwZiwgMHhiNGVlOTZkMiwgMHgxYjliOTE5ZSwgMHg4MGMwYzU0ZiwgMHg2MWRjMjBhMiwgMHg1YTc3NGI2OSwgMHgxYzEyMWExNiwgMHhlMjkzYmEwYSwgMHhjMGEwMmFlNSwgMHgzYzIyZTA0MywgMHgxMjFiMTcxZCwgMHgwZTA5MGQwYiwgMHhmMjhiYzdhZCwgMHgyZGI2YThiOSwgMHgxNDFlYTljOCwgMHg1N2YxMTk4NSwgMHhhZjc1MDc0YywgMHhlZTk5ZGRiYiwgMHhhMzdmNjBmZCwgMHhmNzAxMjY5ZiwgMHg1YzcyZjViYywgMHg0NDY2M2JjNSwgMHg1YmZiN2UzNCwgMHg4YjQzMjk3NiwgMHhjYjIzYzZkYywgMHhiNmVkZmM2OCwgMHhiOGU0ZjE2MywgMHhkNzMxZGNjYSwgMHg0MjYzODUxMCwgMHgxMzk3MjI0MCwgMHg4NGM2MTEyMCwgMHg4NTRhMjQ3ZCwgMHhkMmJiM2RmOCwgMHhhZWY5MzIxMSwgMHhjNzI5YTE2ZCwgMHgxZDllMmY0YiwgMHhkY2IyMzBmMywgMHgwZDg2NTJlYywgMHg3N2MxZTNkMCwgMHgyYmIzMTY2YywgMHhhOTcwYjk5OSwgMHgxMTk0NDhmYSwgMHg0N2U5NjQyMiwgMHhhOGZjOGNjNCwgMHhhMGYwM2YxYSwgMHg1NjdkMmNkOCwgMHgyMjMzOTBlZiwgMHg4NzQ5NGVjNywgMHhkOTM4ZDFjMSwgMHg4Y2NhYTJmZSwgMHg5OGQ0MGIzNiwgMHhhNmY1ODFjZiwgMHhhNTdhZGUyOCwgMHhkYWI3OGUyNiwgMHgzZmFkYmZhNCwgMHgyYzNhOWRlNCwgMHg1MDc4OTIwZCwgMHg2YTVmY2M5YiwgMHg1NDdlNDY2MiwgMHhmNjhkMTNjMiwgMHg5MGQ4YjhlOCwgMHgyZTM5Zjc1ZSwgMHg4MmMzYWZmNSwgMHg5ZjVkODBiZSwgMHg2OWQwOTM3YywgMHg2ZmQ1MmRhOSwgMHhjZjI1MTJiMywgMHhjOGFjOTkzYiwgMHgxMDE4N2RhNywgMHhlODljNjM2ZSwgMHhkYjNiYmI3YiwgMHhjZDI2NzgwOSwgMHg2ZTU5MThmNCwgMHhlYzlhYjcwMSwgMHg4MzRmOWFhOCwgMHhlNjk1NmU2NSwgMHhhYWZmZTY3ZSwgMHgyMWJjY2YwOCwgMHhlZjE1ZThlNiwgMHhiYWU3OWJkOSwgMHg0YTZmMzZjZSwgMHhlYTlmMDlkNCwgMHgyOWIwN2NkNiwgMHgzMWE0YjJhZiwgMHgyYTNmMjMzMSwgMHhjNmE1OTQzMCwgMHgzNWEyNjZjMCwgMHg3NDRlYmMzNywgMHhmYzgyY2FhNiwgMHhlMDkwZDBiMCwgMHgzM2E3ZDgxNSwgMHhmMTA0OTg0YSwgMHg0MWVjZGFmNywgMHg3ZmNkNTAwZSwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg0M2VmYjA0ZCwgMHhjY2FhNGQ1NCwgMHhlNDk2MDRkZiwgMHg5ZWQxYjVlMywgMHg0YzZhODgxYiwgMHhjMTJjMWZiOCwgMHg0NjY1NTE3ZiwgMHg5ZDVlZWEwNCwgMHgwMThjMzU1ZCwgMHhmYTg3NzQ3MywgMHhmYjBiNDEyZSwgMHhiMzY3MWQ1YSwgMHg5MmRiZDI1MiwgMHhlOTEwNTYzMywgMHg2ZGQ2NDcxMywgMHg5YWQ3NjE4YywgMHgzN2ExMGM3YSwgMHg1OWY4MTQ4ZSwgMHhlYjEzM2M4OSwgMHhjZWE5MjdlZSwgMHhiNzYxYzkzNSwgMHhlMTFjZTVlZCwgMHg3YTQ3YjEzYywgMHg5Y2QyZGY1OSwgMHg1NWYyNzMzZiwgMHgxODE0Y2U3OSwgMHg3M2M3MzdiZiwgMHg1M2Y3Y2RlYSwgMHg1ZmZkYWE1YiwgMHhkZjNkNmYxNCwgMHg3ODQ0ZGI4NiwgMHhjYWFmZjM4MSwgMHhiOTY4YzQzZSwgMHgzODI0MzQyYywgMHhjMmEzNDA1ZiwgMHgxNjFkYzM3MiwgMHhiY2UyMjUwYywgMHgyODNjNDk4YiwgMHhmZjBkOTU0MSwgMHgzOWE4MDE3MSwgMHgwODBjYjNkZSwgMHhkOGI0ZTQ5YywgMHg2NDU2YzE5MCwgMHg3YmNiODQ2MSwgMHhkNTMyYjY3MCwgMHg0ODZjNWM3NCwgMHhkMGI4NTc0Ml07XG5jb25zdCBUNiA9IFsweDUwNTFmNGE3LCAweDUzN2U0MTY1LCAweGMzMWExN2E0LCAweDk2M2EyNzVlLCAweGNiM2JhYjZiLCAweGYxMWY5ZDQ1LCAweGFiYWNmYTU4LCAweDkzNGJlMzAzLCAweDU1MjAzMGZhLCAweGY2YWQ3NjZkLCAweDkxODhjYzc2LCAweDI1ZjUwMjRjLCAweGZjNGZlNWQ3LCAweGQ3YzUyYWNiLCAweDgwMjYzNTQ0LCAweDhmYjU2MmEzLCAweDQ5ZGViMTVhLCAweDY3MjViYTFiLCAweDk4NDVlYTBlLCAweGUxNWRmZWMwLCAweDAyYzMyZjc1LCAweDEyODE0Y2YwLCAweGEzOGQ0Njk3LCAweGM2NmJkM2Y5LCAweGU3MDM4ZjVmLCAweDk1MTU5MjljLCAweGViYmY2ZDdhLCAweGRhOTU1MjU5LCAweDJkZDRiZTgzLCAweGQzNTg3NDIxLCAweDI5NDllMDY5LCAweDQ0OGVjOWM4LCAweDZhNzVjMjg5LCAweDc4ZjQ4ZTc5LCAweDZiOTk1ODNlLCAweGRkMjdiOTcxLCAweGI2YmVlMTRmLCAweDE3ZjA4OGFkLCAweDY2YzkyMGFjLCAweGI0N2RjZTNhLCAweDE4NjNkZjRhLCAweDgyZTUxYTMxLCAweDYwOTc1MTMzLCAweDQ1NjI1MzdmLCAweGUwYjE2NDc3LCAweDg0YmI2YmFlLCAweDFjZmU4MWEwLCAweDk0ZjkwODJiLCAweDU4NzA0ODY4LCAweDE5OGY0NWZkLCAweDg3OTRkZTZjLCAweGI3NTI3YmY4LCAweDIzYWI3M2QzLCAweGUyNzI0YjAyLCAweDU3ZTMxZjhmLCAweDJhNjY1NWFiLCAweDA3YjJlYjI4LCAweDAzMmZiNWMyLCAweDlhODZjNTdiLCAweGE1ZDMzNzA4LCAweGYyMzAyODg3LCAweGIyMjNiZmE1LCAweGJhMDIwMzZhLCAweDVjZWQxNjgyLCAweDJiOGFjZjFjLCAweDkyYTc3OWI0LCAweGYwZjMwN2YyLCAweGExNGU2OWUyLCAweGNkNjVkYWY0LCAweGQ1MDYwNWJlLCAweDFmZDEzNDYyLCAweDhhYzRhNmZlLCAweDlkMzQyZTUzLCAweGEwYTJmMzU1LCAweDMyMDU4YWUxLCAweDc1YTRmNmViLCAweDM5MGI4M2VjLCAweGFhNDA2MGVmLCAweDA2NWU3MTlmLCAweDUxYmQ2ZTEwLCAweGY5M2UyMThhLCAweDNkOTZkZDA2LCAweGFlZGQzZTA1LCAweDQ2NGRlNmJkLCAweGI1OTE1NDhkLCAweDA1NzFjNDVkLCAweDZmMDQwNmQ0LCAweGZmNjA1MDE1LCAweDI0MTk5OGZiLCAweDk3ZDZiZGU5LCAweGNjODk0MDQzLCAweDc3NjdkOTllLCAweGJkYjBlODQyLCAweDg4MDc4OThiLCAweDM4ZTcxOTViLCAweGRiNzljOGVlLCAweDQ3YTE3YzBhLCAweGU5N2M0MjBmLCAweGM5Zjg4NDFlLCAweDAwMDAwMDAwLCAweDgzMDk4MDg2LCAweDQ4MzIyYmVkLCAweGFjMWUxMTcwLCAweDRlNmM1YTcyLCAweGZiZmQwZWZmLCAweDU2MGY4NTM4LCAweDFlM2RhZWQ1LCAweDI3MzYyZDM5LCAweDY0MGEwZmQ5LCAweDIxNjg1Y2E2LCAweGQxOWI1YjU0LCAweDNhMjQzNjJlLCAweGIxMGMwYTY3LCAweDBmOTM1N2U3LCAweGQyYjRlZTk2LCAweDllMWI5YjkxLCAweDRmODBjMGM1LCAweGEyNjFkYzIwLCAweDY5NWE3NzRiLCAweDE2MWMxMjFhLCAweDBhZTI5M2JhLCAweGU1YzBhMDJhLCAweDQzM2MyMmUwLCAweDFkMTIxYjE3LCAweDBiMGUwOTBkLCAweGFkZjI4YmM3LCAweGI5MmRiNmE4LCAweGM4MTQxZWE5LCAweDg1NTdmMTE5LCAweDRjYWY3NTA3LCAweGJiZWU5OWRkLCAweGZkYTM3ZjYwLCAweDlmZjcwMTI2LCAweGJjNWM3MmY1LCAweGM1NDQ2NjNiLCAweDM0NWJmYjdlLCAweDc2OGI0MzI5LCAweGRjY2IyM2M2LCAweDY4YjZlZGZjLCAweDYzYjhlNGYxLCAweGNhZDczMWRjLCAweDEwNDI2Mzg1LCAweDQwMTM5NzIyLCAweDIwODRjNjExLCAweDdkODU0YTI0LCAweGY4ZDJiYjNkLCAweDExYWVmOTMyLCAweDZkYzcyOWExLCAweDRiMWQ5ZTJmLCAweGYzZGNiMjMwLCAweGVjMGQ4NjUyLCAweGQwNzdjMWUzLCAweDZjMmJiMzE2LCAweDk5YTk3MGI5LCAweGZhMTE5NDQ4LCAweDIyNDdlOTY0LCAweGM0YThmYzhjLCAweDFhYTBmMDNmLCAweGQ4NTY3ZDJjLCAweGVmMjIzMzkwLCAweGM3ODc0OTRlLCAweGMxZDkzOGQxLCAweGZlOGNjYWEyLCAweDM2OThkNDBiLCAweGNmYTZmNTgxLCAweDI4YTU3YWRlLCAweDI2ZGFiNzhlLCAweGE0M2ZhZGJmLCAweGU0MmMzYTlkLCAweDBkNTA3ODkyLCAweDliNmE1ZmNjLCAweDYyNTQ3ZTQ2LCAweGMyZjY4ZDEzLCAweGU4OTBkOGI4LCAweDVlMmUzOWY3LCAweGY1ODJjM2FmLCAweGJlOWY1ZDgwLCAweDdjNjlkMDkzLCAweGE5NmZkNTJkLCAweGIzY2YyNTEyLCAweDNiYzhhYzk5LCAweGE3MTAxODdkLCAweDZlZTg5YzYzLCAweDdiZGIzYmJiLCAweDA5Y2QyNjc4LCAweGY0NmU1OTE4LCAweDAxZWM5YWI3LCAweGE4ODM0ZjlhLCAweDY1ZTY5NTZlLCAweDdlYWFmZmU2LCAweDA4MjFiY2NmLCAweGU2ZWYxNWU4LCAweGQ5YmFlNzliLCAweGNlNGE2ZjM2LCAweGQ0ZWE5ZjA5LCAweGQ2MjliMDdjLCAweGFmMzFhNGIyLCAweDMxMmEzZjIzLCAweDMwYzZhNTk0LCAweGMwMzVhMjY2LCAweDM3NzQ0ZWJjLCAweGE2ZmM4MmNhLCAweGIwZTA5MGQwLCAweDE1MzNhN2Q4LCAweDRhZjEwNDk4LCAweGY3NDFlY2RhLCAweDBlN2ZjZDUwLCAweDJmMTc5MWY2LCAweDhkNzY0ZGQ2LCAweDRkNDNlZmIwLCAweDU0Y2NhYTRkLCAweGRmZTQ5NjA0LCAweGUzOWVkMWI1LCAweDFiNGM2YTg4LCAweGI4YzEyYzFmLCAweDdmNDY2NTUxLCAweDA0OWQ1ZWVhLCAweDVkMDE4YzM1LCAweDczZmE4Nzc0LCAweDJlZmIwYjQxLCAweDVhYjM2NzFkLCAweDUyOTJkYmQyLCAweDMzZTkxMDU2LCAweDEzNmRkNjQ3LCAweDhjOWFkNzYxLCAweDdhMzdhMTBjLCAweDhlNTlmODE0LCAweDg5ZWIxMzNjLCAweGVlY2VhOTI3LCAweDM1Yjc2MWM5LCAweGVkZTExY2U1LCAweDNjN2E0N2IxLCAweDU5OWNkMmRmLCAweDNmNTVmMjczLCAweDc5MTgxNGNlLCAweGJmNzNjNzM3LCAweGVhNTNmN2NkLCAweDViNWZmZGFhLCAweDE0ZGYzZDZmLCAweDg2Nzg0NGRiLCAweDgxY2FhZmYzLCAweDNlYjk2OGM0LCAweDJjMzgyNDM0LCAweDVmYzJhMzQwLCAweDcyMTYxZGMzLCAweDBjYmNlMjI1LCAweDhiMjgzYzQ5LCAweDQxZmYwZDk1LCAweDcxMzlhODAxLCAweGRlMDgwY2IzLCAweDljZDhiNGU0LCAweDkwNjQ1NmMxLCAweDYxN2JjYjg0LCAweDcwZDUzMmI2LCAweDc0NDg2YzVjLCAweDQyZDBiODU3XTtcbmNvbnN0IFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xuY29uc3QgVDggPSBbMHhmNGE3NTA1MSwgMHg0MTY1NTM3ZSwgMHgxN2E0YzMxYSwgMHgyNzVlOTYzYSwgMHhhYjZiY2IzYiwgMHg5ZDQ1ZjExZiwgMHhmYTU4YWJhYywgMHhlMzAzOTM0YiwgMHgzMGZhNTUyMCwgMHg3NjZkZjZhZCwgMHhjYzc2OTE4OCwgMHgwMjRjMjVmNSwgMHhlNWQ3ZmM0ZiwgMHgyYWNiZDdjNSwgMHgzNTQ0ODAyNiwgMHg2MmEzOGZiNSwgMHhiMTVhNDlkZSwgMHhiYTFiNjcyNSwgMHhlYTBlOTg0NSwgMHhmZWMwZTE1ZCwgMHgyZjc1MDJjMywgMHg0Y2YwMTI4MSwgMHg0Njk3YTM4ZCwgMHhkM2Y5YzY2YiwgMHg4ZjVmZTcwMywgMHg5MjljOTUxNSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHhiZTgzMmRkNCwgMHg3NDIxZDM1OCwgMHhlMDY5Mjk0OSwgMHhjOWM4NDQ4ZSwgMHhjMjg5NmE3NSwgMHg4ZTc5NzhmNCwgMHg1ODNlNmI5OSwgMHhiOTcxZGQyNywgMHhlMTRmYjZiZSwgMHg4OGFkMTdmMCwgMHgyMGFjNjZjOSwgMHhjZTNhYjQ3ZCwgMHhkZjRhMTg2MywgMHgxYTMxODJlNSwgMHg1MTMzNjA5NywgMHg1MzdmNDU2MiwgMHg2NDc3ZTBiMSwgMHg2YmFlODRiYiwgMHg4MWEwMWNmZSwgMHgwODJiOTRmOSwgMHg0ODY4NTg3MCwgMHg0NWZkMTk4ZiwgMHhkZTZjODc5NCwgMHg3YmY4Yjc1MiwgMHg3M2QzMjNhYiwgMHg0YjAyZTI3MiwgMHgxZjhmNTdlMywgMHg1NWFiMmE2NiwgMHhlYjI4MDdiMiwgMHhiNWMyMDMyZiwgMHhjNTdiOWE4NiwgMHgzNzA4YTVkMywgMHgyODg3ZjIzMCwgMHhiZmE1YjIyMywgMHgwMzZhYmEwMiwgMHgxNjgyNWNlZCwgMHhjZjFjMmI4YSwgMHg3OWI0OTJhNywgMHgwN2YyZjBmMywgMHg2OWUyYTE0ZSwgMHhkYWY0Y2Q2NSwgMHgwNWJlZDUwNiwgMHgzNDYyMWZkMSwgMHhhNmZlOGFjNCwgMHgyZTUzOWQzNCwgMHhmMzU1YTBhMiwgMHg4YWUxMzIwNSwgMHhmNmViNzVhNCwgMHg4M2VjMzkwYiwgMHg2MGVmYWE0MCwgMHg3MTlmMDY1ZSwgMHg2ZTEwNTFiZCwgMHgyMThhZjkzZSwgMHhkZDA2M2Q5NiwgMHgzZTA1YWVkZCwgMHhlNmJkNDY0ZCwgMHg1NDhkYjU5MSwgMHhjNDVkMDU3MSwgMHgwNmQ0NmYwNCwgMHg1MDE1ZmY2MCwgMHg5OGZiMjQxOSwgMHhiZGU5OTdkNiwgMHg0MDQzY2M4OSwgMHhkOTllNzc2NywgMHhlODQyYmRiMCwgMHg4OThiODgwNywgMHgxOTViMzhlNywgMHhjOGVlZGI3OSwgMHg3YzBhNDdhMSwgMHg0MjBmZTk3YywgMHg4NDFlYzlmOCwgMHgwMDAwMDAwMCwgMHg4MDg2ODMwOSwgMHgyYmVkNDgzMiwgMHgxMTcwYWMxZSwgMHg1YTcyNGU2YywgMHgwZWZmZmJmZCwgMHg4NTM4NTYwZiwgMHhhZWQ1MWUzZCwgMHgyZDM5MjczNiwgMHgwZmQ5NjQwYSwgMHg1Y2E2MjE2OCwgMHg1YjU0ZDE5YiwgMHgzNjJlM2EyNCwgMHgwYTY3YjEwYywgMHg1N2U3MGY5MywgMHhlZTk2ZDJiNCwgMHg5YjkxOWUxYiwgMHhjMGM1NGY4MCwgMHhkYzIwYTI2MSwgMHg3NzRiNjk1YSwgMHgxMjFhMTYxYywgMHg5M2JhMGFlMiwgMHhhMDJhZTVjMCwgMHgyMmUwNDMzYywgMHgxYjE3MWQxMiwgMHgwOTBkMGIwZSwgMHg4YmM3YWRmMiwgMHhiNmE4YjkyZCwgMHgxZWE5YzgxNCwgMHhmMTE5ODU1NywgMHg3NTA3NGNhZiwgMHg5OWRkYmJlZSwgMHg3ZjYwZmRhMywgMHgwMTI2OWZmNywgMHg3MmY1YmM1YywgMHg2NjNiYzU0NCwgMHhmYjdlMzQ1YiwgMHg0MzI5NzY4YiwgMHgyM2M2ZGNjYiwgMHhlZGZjNjhiNiwgMHhlNGYxNjNiOCwgMHgzMWRjY2FkNywgMHg2Mzg1MTA0MiwgMHg5NzIyNDAxMywgMHhjNjExMjA4NCwgMHg0YTI0N2Q4NSwgMHhiYjNkZjhkMiwgMHhmOTMyMTFhZSwgMHgyOWExNmRjNywgMHg5ZTJmNGIxZCwgMHhiMjMwZjNkYywgMHg4NjUyZWMwZCwgMHhjMWUzZDA3NywgMHhiMzE2NmMyYiwgMHg3MGI5OTlhOSwgMHg5NDQ4ZmExMSwgMHhlOTY0MjI0NywgMHhmYzhjYzRhOCwgMHhmMDNmMWFhMCwgMHg3ZDJjZDg1NiwgMHgzMzkwZWYyMiwgMHg0OTRlYzc4NywgMHgzOGQxYzFkOSwgMHhjYWEyZmU4YywgMHhkNDBiMzY5OCwgMHhmNTgxY2ZhNiwgMHg3YWRlMjhhNSwgMHhiNzhlMjZkYSwgMHhhZGJmYTQzZiwgMHgzYTlkZTQyYywgMHg3ODkyMGQ1MCwgMHg1ZmNjOWI2YSwgMHg3ZTQ2NjI1NCwgMHg4ZDEzYzJmNiwgMHhkOGI4ZTg5MCwgMHgzOWY3NWUyZSwgMHhjM2FmZjU4MiwgMHg1ZDgwYmU5ZiwgMHhkMDkzN2M2OSwgMHhkNTJkYTk2ZiwgMHgyNTEyYjNjZiwgMHhhYzk5M2JjOCwgMHgxODdkYTcxMCwgMHg5YzYzNmVlOCwgMHgzYmJiN2JkYiwgMHgyNjc4MDljZCwgMHg1OTE4ZjQ2ZSwgMHg5YWI3MDFlYywgMHg0ZjlhYTg4MywgMHg5NTZlNjVlNiwgMHhmZmU2N2VhYSwgMHhiY2NmMDgyMSwgMHgxNWU4ZTZlZiwgMHhlNzliZDliYSwgMHg2ZjM2Y2U0YSwgMHg5ZjA5ZDRlYSwgMHhiMDdjZDYyOSwgMHhhNGIyYWYzMSwgMHgzZjIzMzEyYSwgMHhhNTk0MzBjNiwgMHhhMjY2YzAzNSwgMHg0ZWJjMzc3NCwgMHg4MmNhYTZmYywgMHg5MGQwYjBlMCwgMHhhN2Q4MTUzMywgMHgwNDk4NGFmMSwgMHhlY2RhZjc0MSwgMHhjZDUwMGU3ZiwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHhlZmIwNGQ0MywgMHhhYTRkNTRjYywgMHg5NjA0ZGZlNCwgMHhkMWI1ZTM5ZSwgMHg2YTg4MWI0YywgMHgyYzFmYjhjMSwgMHg2NTUxN2Y0NiwgMHg1ZWVhMDQ5ZCwgMHg4YzM1NWQwMSwgMHg4Nzc0NzNmYSwgMHgwYjQxMmVmYiwgMHg2NzFkNWFiMywgMHhkYmQyNTI5MiwgMHgxMDU2MzNlOSwgMHhkNjQ3MTM2ZCwgMHhkNzYxOGM5YSwgMHhhMTBjN2EzNywgMHhmODE0OGU1OSwgMHgxMzNjODllYiwgMHhhOTI3ZWVjZSwgMHg2MWM5MzViNywgMHgxY2U1ZWRlMSwgMHg0N2IxM2M3YSwgMHhkMmRmNTk5YywgMHhmMjczM2Y1NSwgMHgxNGNlNzkxOCwgMHhjNzM3YmY3MywgMHhmN2NkZWE1MywgMHhmZGFhNWI1ZiwgMHgzZDZmMTRkZiwgMHg0NGRiODY3OCwgMHhhZmYzODFjYSwgMHg2OGM0M2ViOSwgMHgyNDM0MmMzOCwgMHhhMzQwNWZjMiwgMHgxZGMzNzIxNiwgMHhlMjI1MGNiYywgMHgzYzQ5OGIyOCwgMHgwZDk1NDFmZiwgMHhhODAxNzEzOSwgMHgwY2IzZGUwOCwgMHhiNGU0OWNkOCwgMHg1NmMxOTA2NCwgMHhjYjg0NjE3YiwgMHgzMmI2NzBkNSwgMHg2YzVjNzQ0OCwgMHhiODU3NDJkMF07XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuY29uc3QgVTEgPSBbMHgwMDAwMDAwMCwgMHgwZTA5MGQwYiwgMHgxYzEyMWExNiwgMHgxMjFiMTcxZCwgMHgzODI0MzQyYywgMHgzNjJkMzkyNywgMHgyNDM2MmUzYSwgMHgyYTNmMjMzMSwgMHg3MDQ4Njg1OCwgMHg3ZTQxNjU1MywgMHg2YzVhNzI0ZSwgMHg2MjUzN2Y0NSwgMHg0ODZjNWM3NCwgMHg0NjY1NTE3ZiwgMHg1NDdlNDY2MiwgMHg1YTc3NGI2OSwgMHhlMDkwZDBiMCwgMHhlZTk5ZGRiYiwgMHhmYzgyY2FhNiwgMHhmMjhiYzdhZCwgMHhkOGI0ZTQ5YywgMHhkNmJkZTk5NywgMHhjNGE2ZmU4YSwgMHhjYWFmZjM4MSwgMHg5MGQ4YjhlOCwgMHg5ZWQxYjVlMywgMHg4Y2NhYTJmZSwgMHg4MmMzYWZmNSwgMHhhOGZjOGNjNCwgMHhhNmY1ODFjZiwgMHhiNGVlOTZkMiwgMHhiYWU3OWJkOSwgMHhkYjNiYmI3YiwgMHhkNTMyYjY3MCwgMHhjNzI5YTE2ZCwgMHhjOTIwYWM2NiwgMHhlMzFmOGY1NywgMHhlZDE2ODI1YywgMHhmZjBkOTU0MSwgMHhmMTA0OTg0YSwgMHhhYjczZDMyMywgMHhhNTdhZGUyOCwgMHhiNzYxYzkzNSwgMHhiOTY4YzQzZSwgMHg5MzU3ZTcwZiwgMHg5ZDVlZWEwNCwgMHg4ZjQ1ZmQxOSwgMHg4MTRjZjAxMiwgMHgzYmFiNmJjYiwgMHgzNWEyNjZjMCwgMHgyN2I5NzFkZCwgMHgyOWIwN2NkNiwgMHgwMzhmNWZlNywgMHgwZDg2NTJlYywgMHgxZjlkNDVmMSwgMHgxMTk0NDhmYSwgMHg0YmUzMDM5MywgMHg0NWVhMGU5OCwgMHg1N2YxMTk4NSwgMHg1OWY4MTQ4ZSwgMHg3M2M3MzdiZiwgMHg3ZGNlM2FiNCwgMHg2ZmQ1MmRhOSwgMHg2MWRjMjBhMiwgMHhhZDc2NmRmNiwgMHhhMzdmNjBmZCwgMHhiMTY0NzdlMCwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHg5YjViNTRkMSwgMHg4OTQwNDNjYywgMHg4NzQ5NGVjNywgMHhkZDNlMDVhZSwgMHhkMzM3MDhhNSwgMHhjMTJjMWZiOCwgMHhjZjI1MTJiMywgMHhlNTFhMzE4MiwgMHhlYjEzM2M4OSwgMHhmOTA4MmI5NCwgMHhmNzAxMjY5ZiwgMHg0ZGU2YmQ0NiwgMHg0M2VmYjA0ZCwgMHg1MWY0YTc1MCwgMHg1ZmZkYWE1YiwgMHg3NWMyODk2YSwgMHg3YmNiODQ2MSwgMHg2OWQwOTM3YywgMHg2N2Q5OWU3NywgMHgzZGFlZDUxZSwgMHgzM2E3ZDgxNSwgMHgyMWJjY2YwOCwgMHgyZmI1YzIwMywgMHgwNThhZTEzMiwgMHgwYjgzZWMzOSwgMHgxOTk4ZmIyNCwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg3ODQ0ZGI4NiwgMHg2YTVmY2M5YiwgMHg2NDU2YzE5MCwgMHg0ZTY5ZTJhMSwgMHg0MDYwZWZhYSwgMHg1MjdiZjhiNywgMHg1YzcyZjViYywgMHgwNjA1YmVkNSwgMHgwODBjYjNkZSwgMHgxYTE3YTRjMywgMHgxNDFlYTljOCwgMHgzZTIxOGFmOSwgMHgzMDI4ODdmMiwgMHgyMjMzOTBlZiwgMHgyYzNhOWRlNCwgMHg5NmRkMDYzZCwgMHg5OGQ0MGIzNiwgMHg4YWNmMWMyYiwgMHg4NGM2MTEyMCwgMHhhZWY5MzIxMSwgMHhhMGYwM2YxYSwgMHhiMmViMjgwNywgMHhiY2UyMjUwYywgMHhlNjk1NmU2NSwgMHhlODljNjM2ZSwgMHhmYTg3NzQ3MywgMHhmNDhlNzk3OCwgMHhkZWIxNWE0OSwgMHhkMGI4NTc0MiwgMHhjMmEzNDA1ZiwgMHhjY2FhNGQ1NCwgMHg0MWVjZGFmNywgMHg0ZmU1ZDdmYywgMHg1ZGZlYzBlMSwgMHg1M2Y3Y2RlYSwgMHg3OWM4ZWVkYiwgMHg3N2MxZTNkMCwgMHg2NWRhZjRjZCwgMHg2YmQzZjljNiwgMHgzMWE0YjJhZiwgMHgzZmFkYmZhNCwgMHgyZGI2YThiOSwgMHgyM2JmYTViMiwgMHgwOTgwODY4MywgMHgwNzg5OGI4OCwgMHgxNTkyOWM5NSwgMHgxYjliOTE5ZSwgMHhhMTdjMGE0NywgMHhhZjc1MDc0YywgMHhiZDZlMTA1MSwgMHhiMzY3MWQ1YSwgMHg5OTU4M2U2YiwgMHg5NzUxMzM2MCwgMHg4NTRhMjQ3ZCwgMHg4YjQzMjk3NiwgMHhkMTM0NjIxZiwgMHhkZjNkNmYxNCwgMHhjZDI2NzgwOSwgMHhjMzJmNzUwMiwgMHhlOTEwNTYzMywgMHhlNzE5NWIzOCwgMHhmNTAyNGMyNSwgMHhmYjBiNDEyZSwgMHg5YWQ3NjE4YywgMHg5NGRlNmM4NywgMHg4NmM1N2I5YSwgMHg4OGNjNzY5MSwgMHhhMmYzNTVhMCwgMHhhY2ZhNThhYiwgMHhiZWUxNGZiNiwgMHhiMGU4NDJiZCwgMHhlYTlmMDlkNCwgMHhlNDk2MDRkZiwgMHhmNjhkMTNjMiwgMHhmODg0MWVjOSwgMHhkMmJiM2RmOCwgMHhkY2IyMzBmMywgMHhjZWE5MjdlZSwgMHhjMGEwMmFlNSwgMHg3YTQ3YjEzYywgMHg3NDRlYmMzNywgMHg2NjU1YWIyYSwgMHg2ODVjYTYyMSwgMHg0MjYzODUxMCwgMHg0YzZhODgxYiwgMHg1ZTcxOWYwNiwgMHg1MDc4OTIwZCwgMHgwYTBmZDk2NCwgMHgwNDA2ZDQ2ZiwgMHgxNjFkYzM3MiwgMHgxODE0Y2U3OSwgMHgzMjJiZWQ0OCwgMHgzYzIyZTA0MywgMHgyZTM5Zjc1ZSwgMHgyMDMwZmE1NSwgMHhlYzlhYjcwMSwgMHhlMjkzYmEwYSwgMHhmMDg4YWQxNywgMHhmZTgxYTAxYywgMHhkNGJlODMyZCwgMHhkYWI3OGUyNiwgMHhjOGFjOTkzYiwgMHhjNmE1OTQzMCwgMHg5Y2QyZGY1OSwgMHg5MmRiZDI1MiwgMHg4MGMwYzU0ZiwgMHg4ZWM5Yzg0NCwgMHhhNGY2ZWI3NSwgMHhhYWZmZTY3ZSwgMHhiOGU0ZjE2MywgMHhiNmVkZmM2OCwgMHgwYzBhNjdiMSwgMHgwMjAzNmFiYSwgMHgxMDE4N2RhNywgMHgxZTExNzBhYywgMHgzNDJlNTM5ZCwgMHgzYTI3NWU5NiwgMHgyODNjNDk4YiwgMHgyNjM1NDQ4MCwgMHg3YzQyMGZlOSwgMHg3MjRiMDJlMiwgMHg2MDUwMTVmZiwgMHg2ZTU5MThmNCwgMHg0NDY2M2JjNSwgMHg0YTZmMzZjZSwgMHg1ODc0MjFkMywgMHg1NjdkMmNkOCwgMHgzN2ExMGM3YSwgMHgzOWE4MDE3MSwgMHgyYmIzMTY2YywgMHgyNWJhMWI2NywgMHgwZjg1Mzg1NiwgMHgwMThjMzU1ZCwgMHgxMzk3MjI0MCwgMHgxZDllMmY0YiwgMHg0N2U5NjQyMiwgMHg0OWUwNjkyOSwgMHg1YmZiN2UzNCwgMHg1NWYyNzMzZiwgMHg3ZmNkNTAwZSwgMHg3MWM0NWQwNSwgMHg2M2RmNGExOCwgMHg2ZGQ2NDcxMywgMHhkNzMxZGNjYSwgMHhkOTM4ZDFjMSwgMHhjYjIzYzZkYywgMHhjNTJhY2JkNywgMHhlZjE1ZThlNiwgMHhlMTFjZTVlZCwgMHhmMzA3ZjJmMCwgMHhmZDBlZmZmYiwgMHhhNzc5YjQ5MiwgMHhhOTcwYjk5OSwgMHhiYjZiYWU4NCwgMHhiNTYyYTM4ZiwgMHg5ZjVkODBiZSwgMHg5MTU0OGRiNSwgMHg4MzRmOWFhOCwgMHg4ZDQ2OTdhM107XG5jb25zdCBVMiA9IFsweDAwMDAwMDAwLCAweDBiMGUwOTBkLCAweDE2MWMxMjFhLCAweDFkMTIxYjE3LCAweDJjMzgyNDM0LCAweDI3MzYyZDM5LCAweDNhMjQzNjJlLCAweDMxMmEzZjIzLCAweDU4NzA0ODY4LCAweDUzN2U0MTY1LCAweDRlNmM1YTcyLCAweDQ1NjI1MzdmLCAweDc0NDg2YzVjLCAweDdmNDY2NTUxLCAweDYyNTQ3ZTQ2LCAweDY5NWE3NzRiLCAweGIwZTA5MGQwLCAweGJiZWU5OWRkLCAweGE2ZmM4MmNhLCAweGFkZjI4YmM3LCAweDljZDhiNGU0LCAweDk3ZDZiZGU5LCAweDhhYzRhNmZlLCAweDgxY2FhZmYzLCAweGU4OTBkOGI4LCAweGUzOWVkMWI1LCAweGZlOGNjYWEyLCAweGY1ODJjM2FmLCAweGM0YThmYzhjLCAweGNmYTZmNTgxLCAweGQyYjRlZTk2LCAweGQ5YmFlNzliLCAweDdiZGIzYmJiLCAweDcwZDUzMmI2LCAweDZkYzcyOWExLCAweDY2YzkyMGFjLCAweDU3ZTMxZjhmLCAweDVjZWQxNjgyLCAweDQxZmYwZDk1LCAweDRhZjEwNDk4LCAweDIzYWI3M2QzLCAweDI4YTU3YWRlLCAweDM1Yjc2MWM5LCAweDNlYjk2OGM0LCAweDBmOTM1N2U3LCAweDA0OWQ1ZWVhLCAweDE5OGY0NWZkLCAweDEyODE0Y2YwLCAweGNiM2JhYjZiLCAweGMwMzVhMjY2LCAweGRkMjdiOTcxLCAweGQ2MjliMDdjLCAweGU3MDM4ZjVmLCAweGVjMGQ4NjUyLCAweGYxMWY5ZDQ1LCAweGZhMTE5NDQ4LCAweDkzNGJlMzAzLCAweDk4NDVlYTBlLCAweDg1NTdmMTE5LCAweDhlNTlmODE0LCAweGJmNzNjNzM3LCAweGI0N2RjZTNhLCAweGE5NmZkNTJkLCAweGEyNjFkYzIwLCAweGY2YWQ3NjZkLCAweGZkYTM3ZjYwLCAweGUwYjE2NDc3LCAweGViYmY2ZDdhLCAweGRhOTU1MjU5LCAweGQxOWI1YjU0LCAweGNjODk0MDQzLCAweGM3ODc0OTRlLCAweGFlZGQzZTA1LCAweGE1ZDMzNzA4LCAweGI4YzEyYzFmLCAweGIzY2YyNTEyLCAweDgyZTUxYTMxLCAweDg5ZWIxMzNjLCAweDk0ZjkwODJiLCAweDlmZjcwMTI2LCAweDQ2NGRlNmJkLCAweDRkNDNlZmIwLCAweDUwNTFmNGE3LCAweDViNWZmZGFhLCAweDZhNzVjMjg5LCAweDYxN2JjYjg0LCAweDdjNjlkMDkzLCAweDc3NjdkOTllLCAweDFlM2RhZWQ1LCAweDE1MzNhN2Q4LCAweDA4MjFiY2NmLCAweDAzMmZiNWMyLCAweDMyMDU4YWUxLCAweDM5MGI4M2VjLCAweDI0MTk5OGZiLCAweDJmMTc5MWY2LCAweDhkNzY0ZGQ2LCAweDg2Nzg0NGRiLCAweDliNmE1ZmNjLCAweDkwNjQ1NmMxLCAweGExNGU2OWUyLCAweGFhNDA2MGVmLCAweGI3NTI3YmY4LCAweGJjNWM3MmY1LCAweGQ1MDYwNWJlLCAweGRlMDgwY2IzLCAweGMzMWExN2E0LCAweGM4MTQxZWE5LCAweGY5M2UyMThhLCAweGYyMzAyODg3LCAweGVmMjIzMzkwLCAweGU0MmMzYTlkLCAweDNkOTZkZDA2LCAweDM2OThkNDBiLCAweDJiOGFjZjFjLCAweDIwODRjNjExLCAweDExYWVmOTMyLCAweDFhYTBmMDNmLCAweDA3YjJlYjI4LCAweDBjYmNlMjI1LCAweDY1ZTY5NTZlLCAweDZlZTg5YzYzLCAweDczZmE4Nzc0LCAweDc4ZjQ4ZTc5LCAweDQ5ZGViMTVhLCAweDQyZDBiODU3LCAweDVmYzJhMzQwLCAweDU0Y2NhYTRkLCAweGY3NDFlY2RhLCAweGZjNGZlNWQ3LCAweGUxNWRmZWMwLCAweGVhNTNmN2NkLCAweGRiNzljOGVlLCAweGQwNzdjMWUzLCAweGNkNjVkYWY0LCAweGM2NmJkM2Y5LCAweGFmMzFhNGIyLCAweGE0M2ZhZGJmLCAweGI5MmRiNmE4LCAweGIyMjNiZmE1LCAweDgzMDk4MDg2LCAweDg4MDc4OThiLCAweDk1MTU5MjljLCAweDllMWI5YjkxLCAweDQ3YTE3YzBhLCAweDRjYWY3NTA3LCAweDUxYmQ2ZTEwLCAweDVhYjM2NzFkLCAweDZiOTk1ODNlLCAweDYwOTc1MTMzLCAweDdkODU0YTI0LCAweDc2OGI0MzI5LCAweDFmZDEzNDYyLCAweDE0ZGYzZDZmLCAweDA5Y2QyNjc4LCAweDAyYzMyZjc1LCAweDMzZTkxMDU2LCAweDM4ZTcxOTViLCAweDI1ZjUwMjRjLCAweDJlZmIwYjQxLCAweDhjOWFkNzYxLCAweDg3OTRkZTZjLCAweDlhODZjNTdiLCAweDkxODhjYzc2LCAweGEwYTJmMzU1LCAweGFiYWNmYTU4LCAweGI2YmVlMTRmLCAweGJkYjBlODQyLCAweGQ0ZWE5ZjA5LCAweGRmZTQ5NjA0LCAweGMyZjY4ZDEzLCAweGM5Zjg4NDFlLCAweGY4ZDJiYjNkLCAweGYzZGNiMjMwLCAweGVlY2VhOTI3LCAweGU1YzBhMDJhLCAweDNjN2E0N2IxLCAweDM3NzQ0ZWJjLCAweDJhNjY1NWFiLCAweDIxNjg1Y2E2LCAweDEwNDI2Mzg1LCAweDFiNGM2YTg4LCAweDA2NWU3MTlmLCAweDBkNTA3ODkyLCAweDY0MGEwZmQ5LCAweDZmMDQwNmQ0LCAweDcyMTYxZGMzLCAweDc5MTgxNGNlLCAweDQ4MzIyYmVkLCAweDQzM2MyMmUwLCAweDVlMmUzOWY3LCAweDU1MjAzMGZhLCAweDAxZWM5YWI3LCAweDBhZTI5M2JhLCAweDE3ZjA4OGFkLCAweDFjZmU4MWEwLCAweDJkZDRiZTgzLCAweDI2ZGFiNzhlLCAweDNiYzhhYzk5LCAweDMwYzZhNTk0LCAweDU5OWNkMmRmLCAweDUyOTJkYmQyLCAweDRmODBjMGM1LCAweDQ0OGVjOWM4LCAweDc1YTRmNmViLCAweDdlYWFmZmU2LCAweDYzYjhlNGYxLCAweDY4YjZlZGZjLCAweGIxMGMwYTY3LCAweGJhMDIwMzZhLCAweGE3MTAxODdkLCAweGFjMWUxMTcwLCAweDlkMzQyZTUzLCAweDk2M2EyNzVlLCAweDhiMjgzYzQ5LCAweDgwMjYzNTQ0LCAweGU5N2M0MjBmLCAweGUyNzI0YjAyLCAweGZmNjA1MDE1LCAweGY0NmU1OTE4LCAweGM1NDQ2NjNiLCAweGNlNGE2ZjM2LCAweGQzNTg3NDIxLCAweGQ4NTY3ZDJjLCAweDdhMzdhMTBjLCAweDcxMzlhODAxLCAweDZjMmJiMzE2LCAweDY3MjViYTFiLCAweDU2MGY4NTM4LCAweDVkMDE4YzM1LCAweDQwMTM5NzIyLCAweDRiMWQ5ZTJmLCAweDIyNDdlOTY0LCAweDI5NDllMDY5LCAweDM0NWJmYjdlLCAweDNmNTVmMjczLCAweDBlN2ZjZDUwLCAweDA1NzFjNDVkLCAweDE4NjNkZjRhLCAweDEzNmRkNjQ3LCAweGNhZDczMWRjLCAweGMxZDkzOGQxLCAweGRjY2IyM2M2LCAweGQ3YzUyYWNiLCAweGU2ZWYxNWU4LCAweGVkZTExY2U1LCAweGYwZjMwN2YyLCAweGZiZmQwZWZmLCAweDkyYTc3OWI0LCAweDk5YTk3MGI5LCAweDg0YmI2YmFlLCAweDhmYjU2MmEzLCAweGJlOWY1ZDgwLCAweGI1OTE1NDhkLCAweGE4ODM0ZjlhLCAweGEzOGQ0Njk3XTtcbmNvbnN0IFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuY29uc3QgVTQgPSBbMHgwMDAwMDAwMCwgMHgwOTBkMGIwZSwgMHgxMjFhMTYxYywgMHgxYjE3MWQxMiwgMHgyNDM0MmMzOCwgMHgyZDM5MjczNiwgMHgzNjJlM2EyNCwgMHgzZjIzMzEyYSwgMHg0ODY4NTg3MCwgMHg0MTY1NTM3ZSwgMHg1YTcyNGU2YywgMHg1MzdmNDU2MiwgMHg2YzVjNzQ0OCwgMHg2NTUxN2Y0NiwgMHg3ZTQ2NjI1NCwgMHg3NzRiNjk1YSwgMHg5MGQwYjBlMCwgMHg5OWRkYmJlZSwgMHg4MmNhYTZmYywgMHg4YmM3YWRmMiwgMHhiNGU0OWNkOCwgMHhiZGU5OTdkNiwgMHhhNmZlOGFjNCwgMHhhZmYzODFjYSwgMHhkOGI4ZTg5MCwgMHhkMWI1ZTM5ZSwgMHhjYWEyZmU4YywgMHhjM2FmZjU4MiwgMHhmYzhjYzRhOCwgMHhmNTgxY2ZhNiwgMHhlZTk2ZDJiNCwgMHhlNzliZDliYSwgMHgzYmJiN2JkYiwgMHgzMmI2NzBkNSwgMHgyOWExNmRjNywgMHgyMGFjNjZjOSwgMHgxZjhmNTdlMywgMHgxNjgyNWNlZCwgMHgwZDk1NDFmZiwgMHgwNDk4NGFmMSwgMHg3M2QzMjNhYiwgMHg3YWRlMjhhNSwgMHg2MWM5MzViNywgMHg2OGM0M2ViOSwgMHg1N2U3MGY5MywgMHg1ZWVhMDQ5ZCwgMHg0NWZkMTk4ZiwgMHg0Y2YwMTI4MSwgMHhhYjZiY2IzYiwgMHhhMjY2YzAzNSwgMHhiOTcxZGQyNywgMHhiMDdjZDYyOSwgMHg4ZjVmZTcwMywgMHg4NjUyZWMwZCwgMHg5ZDQ1ZjExZiwgMHg5NDQ4ZmExMSwgMHhlMzAzOTM0YiwgMHhlYTBlOTg0NSwgMHhmMTE5ODU1NywgMHhmODE0OGU1OSwgMHhjNzM3YmY3MywgMHhjZTNhYjQ3ZCwgMHhkNTJkYTk2ZiwgMHhkYzIwYTI2MSwgMHg3NjZkZjZhZCwgMHg3ZjYwZmRhMywgMHg2NDc3ZTBiMSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHg1YjU0ZDE5YiwgMHg0MDQzY2M4OSwgMHg0OTRlYzc4NywgMHgzZTA1YWVkZCwgMHgzNzA4YTVkMywgMHgyYzFmYjhjMSwgMHgyNTEyYjNjZiwgMHgxYTMxODJlNSwgMHgxMzNjODllYiwgMHgwODJiOTRmOSwgMHgwMTI2OWZmNywgMHhlNmJkNDY0ZCwgMHhlZmIwNGQ0MywgMHhmNGE3NTA1MSwgMHhmZGFhNWI1ZiwgMHhjMjg5NmE3NSwgMHhjYjg0NjE3YiwgMHhkMDkzN2M2OSwgMHhkOTllNzc2NywgMHhhZWQ1MWUzZCwgMHhhN2Q4MTUzMywgMHhiY2NmMDgyMSwgMHhiNWMyMDMyZiwgMHg4YWUxMzIwNSwgMHg4M2VjMzkwYiwgMHg5OGZiMjQxOSwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHg0NGRiODY3OCwgMHg1ZmNjOWI2YSwgMHg1NmMxOTA2NCwgMHg2OWUyYTE0ZSwgMHg2MGVmYWE0MCwgMHg3YmY4Yjc1MiwgMHg3MmY1YmM1YywgMHgwNWJlZDUwNiwgMHgwY2IzZGUwOCwgMHgxN2E0YzMxYSwgMHgxZWE5YzgxNCwgMHgyMThhZjkzZSwgMHgyODg3ZjIzMCwgMHgzMzkwZWYyMiwgMHgzYTlkZTQyYywgMHhkZDA2M2Q5NiwgMHhkNDBiMzY5OCwgMHhjZjFjMmI4YSwgMHhjNjExMjA4NCwgMHhmOTMyMTFhZSwgMHhmMDNmMWFhMCwgMHhlYjI4MDdiMiwgMHhlMjI1MGNiYywgMHg5NTZlNjVlNiwgMHg5YzYzNmVlOCwgMHg4Nzc0NzNmYSwgMHg4ZTc5NzhmNCwgMHhiMTVhNDlkZSwgMHhiODU3NDJkMCwgMHhhMzQwNWZjMiwgMHhhYTRkNTRjYywgMHhlY2RhZjc0MSwgMHhlNWQ3ZmM0ZiwgMHhmZWMwZTE1ZCwgMHhmN2NkZWE1MywgMHhjOGVlZGI3OSwgMHhjMWUzZDA3NywgMHhkYWY0Y2Q2NSwgMHhkM2Y5YzY2YiwgMHhhNGIyYWYzMSwgMHhhZGJmYTQzZiwgMHhiNmE4YjkyZCwgMHhiZmE1YjIyMywgMHg4MDg2ODMwOSwgMHg4OThiODgwNywgMHg5MjljOTUxNSwgMHg5YjkxOWUxYiwgMHg3YzBhNDdhMSwgMHg3NTA3NGNhZiwgMHg2ZTEwNTFiZCwgMHg2NzFkNWFiMywgMHg1ODNlNmI5OSwgMHg1MTMzNjA5NywgMHg0YTI0N2Q4NSwgMHg0MzI5NzY4YiwgMHgzNDYyMWZkMSwgMHgzZDZmMTRkZiwgMHgyNjc4MDljZCwgMHgyZjc1MDJjMywgMHgxMDU2MzNlOSwgMHgxOTViMzhlNywgMHgwMjRjMjVmNSwgMHgwYjQxMmVmYiwgMHhkNzYxOGM5YSwgMHhkZTZjODc5NCwgMHhjNTdiOWE4NiwgMHhjYzc2OTE4OCwgMHhmMzU1YTBhMiwgMHhmYTU4YWJhYywgMHhlMTRmYjZiZSwgMHhlODQyYmRiMCwgMHg5ZjA5ZDRlYSwgMHg5NjA0ZGZlNCwgMHg4ZDEzYzJmNiwgMHg4NDFlYzlmOCwgMHhiYjNkZjhkMiwgMHhiMjMwZjNkYywgMHhhOTI3ZWVjZSwgMHhhMDJhZTVjMCwgMHg0N2IxM2M3YSwgMHg0ZWJjMzc3NCwgMHg1NWFiMmE2NiwgMHg1Y2E2MjE2OCwgMHg2Mzg1MTA0MiwgMHg2YTg4MWI0YywgMHg3MTlmMDY1ZSwgMHg3ODkyMGQ1MCwgMHgwZmQ5NjQwYSwgMHgwNmQ0NmYwNCwgMHgxZGMzNzIxNiwgMHgxNGNlNzkxOCwgMHgyYmVkNDgzMiwgMHgyMmUwNDMzYywgMHgzOWY3NWUyZSwgMHgzMGZhNTUyMCwgMHg5YWI3MDFlYywgMHg5M2JhMGFlMiwgMHg4OGFkMTdmMCwgMHg4MWEwMWNmZSwgMHhiZTgzMmRkNCwgMHhiNzhlMjZkYSwgMHhhYzk5M2JjOCwgMHhhNTk0MzBjNiwgMHhkMmRmNTk5YywgMHhkYmQyNTI5MiwgMHhjMGM1NGY4MCwgMHhjOWM4NDQ4ZSwgMHhmNmViNzVhNCwgMHhmZmU2N2VhYSwgMHhlNGYxNjNiOCwgMHhlZGZjNjhiNiwgMHgwYTY3YjEwYywgMHgwMzZhYmEwMiwgMHgxODdkYTcxMCwgMHgxMTcwYWMxZSwgMHgyZTUzOWQzNCwgMHgyNzVlOTYzYSwgMHgzYzQ5OGIyOCwgMHgzNTQ0ODAyNiwgMHg0MjBmZTk3YywgMHg0YjAyZTI3MiwgMHg1MDE1ZmY2MCwgMHg1OTE4ZjQ2ZSwgMHg2NjNiYzU0NCwgMHg2ZjM2Y2U0YSwgMHg3NDIxZDM1OCwgMHg3ZDJjZDg1NiwgMHhhMTBjN2EzNywgMHhhODAxNzEzOSwgMHhiMzE2NmMyYiwgMHhiYTFiNjcyNSwgMHg4NTM4NTYwZiwgMHg4YzM1NWQwMSwgMHg5NzIyNDAxMywgMHg5ZTJmNGIxZCwgMHhlOTY0MjI0NywgMHhlMDY5Mjk0OSwgMHhmYjdlMzQ1YiwgMHhmMjczM2Y1NSwgMHhjZDUwMGU3ZiwgMHhjNDVkMDU3MSwgMHhkZjRhMTg2MywgMHhkNjQ3MTM2ZCwgMHgzMWRjY2FkNywgMHgzOGQxYzFkOSwgMHgyM2M2ZGNjYiwgMHgyYWNiZDdjNSwgMHgxNWU4ZTZlZiwgMHgxY2U1ZWRlMSwgMHgwN2YyZjBmMywgMHgwZWZmZmJmZCwgMHg3OWI0OTJhNywgMHg3MGI5OTlhOSwgMHg2YmFlODRiYiwgMHg2MmEzOGZiNSwgMHg1ZDgwYmU5ZiwgMHg1NDhkYjU5MSwgMHg0ZjlhYTg4MywgMHg0Njk3YTM4ZF07XG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQzMihieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goKGJ5dGVzW2ldIDw8IDI0KSB8IChieXRlc1tpICsgMV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAyXSA8PCA4KSB8IGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgQUVTIHtcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0FFU19rZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBRVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfa2V5LCBuZXcgVWludDhBcnJheShrZXkpLCBcImZcIik7XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZSwgW10sIFwiZlwiKTtcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZCwgW10sIFwiZlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcbiAgICAgICAgY29uc3QgS0MgPSB0aGlzLmtleS5sZW5ndGggLyA0O1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cbiAgICAgICAgICAgICAgICBTWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZm9yIG5vbi0yNTYgYml0KVxuICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG4gICAgICAgICAgICAgICAgdGtbS0MgLyAyXSBePSAoU1t0dCAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChLQyAvIDIpICsgMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICAgICAgbGV0IGkgPSAwLCByLCBjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG4gICAgICAgICAgICAgICAgYyA9IHQgJSA0O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2NdID0gdGtbaV07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuICAgICAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUzWyh0dCA+PiA4KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTRbdHQgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAoVDFbKHRbaV0gPj4gMjQpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ0W3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBsZXQgdHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF4gKHR0ID4+IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuICAgICAgICBsZXQgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNpWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpW3RbKGkgKyAxKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuX0FFU19rZXkgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tkID0gbmV3IFdlYWtNYXAoKSwgX0FFU19LZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZXMuanMubWFwIl0sIm5hbWVzIjpbIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJjYWxsIiwidmFsdWUiLCJnZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0Iiwic2V0IiwiX0FFU19rZXkiLCJfQUVTX0tkIiwiX0FFU19LZSIsIm51bWJlck9mUm91bmRzIiwicmNvbiIsIlMiLCJTaSIsIlQxIiwiVDIiLCJUMyIsIlQ0IiwiVDUiLCJUNiIsIlQ3IiwiVDgiLCJVMSIsIlUyIiwiVTMiLCJVNCIsImNvbnZlcnRUb0ludDMyIiwiYnl0ZXMiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwicHVzaCIsIkFFUyIsImtleSIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJFcnJvciIsIlVpbnQ4QXJyYXkiLCJyb3VuZHMiLCJyb3VuZEtleUNvdW50IiwiS0MiLCJ0ayIsImluZGV4IiwicmNvbnBvaW50ZXIiLCJ0IiwidHQiLCJyIiwiYyIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJhIiwiZGVjcnlwdCIsImNpcGhlcnRleHQiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/aes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/index.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: () => (/* reexport safe */ _aes_js__WEBPACK_IMPORTED_MODULE_0__.AES),\n/* harmony export */   CBC: () => (/* reexport safe */ _mode_cbc_js__WEBPACK_IMPORTED_MODULE_2__.CBC),\n/* harmony export */   CFB: () => (/* reexport safe */ _mode_cfb_js__WEBPACK_IMPORTED_MODULE_3__.CFB),\n/* harmony export */   CTR: () => (/* reexport safe */ _mode_ctr_js__WEBPACK_IMPORTED_MODULE_4__.CTR),\n/* harmony export */   ECB: () => (/* reexport safe */ _mode_ecb_js__WEBPACK_IMPORTED_MODULE_5__.ECB),\n/* harmony export */   ModeOfOperation: () => (/* reexport safe */ _mode_js__WEBPACK_IMPORTED_MODULE_1__.ModeOfOperation),\n/* harmony export */   OFB: () => (/* reexport safe */ _mode_ofb_js__WEBPACK_IMPORTED_MODULE_6__.OFB),\n/* harmony export */   pkcs7Pad: () => (/* reexport safe */ _padding_js__WEBPACK_IMPORTED_MODULE_7__.pkcs7Pad),\n/* harmony export */   pkcs7Strip: () => (/* reexport safe */ _padding_js__WEBPACK_IMPORTED_MODULE_7__.pkcs7Strip)\n/* harmony export */ });\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/aes.js\");\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mode.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\");\n/* harmony import */ var _mode_cbc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mode-cbc.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cbc.js\");\n/* harmony import */ var _mode_cfb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mode-cfb.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cfb.js\");\n/* harmony import */ var _mode_ctr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mode-ctr.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ctr.js\");\n/* harmony import */ var _mode_ecb_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mode-ecb.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ecb.js\");\n/* harmony import */ var _mode_ofb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mode-ofb.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ofb.js\");\n/* harmony import */ var _padding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./padding.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/padding.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDYTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0IsQ0FDcEQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL2luZGV4LmpzP2YxODMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQUVTIH0gZnJvbSBcIi4vYWVzLmpzXCI7XG5leHBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5leHBvcnQgeyBDQkMgfSBmcm9tIFwiLi9tb2RlLWNiYy5qc1wiO1xuZXhwb3J0IHsgQ0ZCIH0gZnJvbSBcIi4vbW9kZS1jZmIuanNcIjtcbmV4cG9ydCB7IENUUiB9IGZyb20gXCIuL21vZGUtY3RyLmpzXCI7XG5leHBvcnQgeyBFQ0IgfSBmcm9tIFwiLi9tb2RlLWVjYi5qc1wiO1xuZXhwb3J0IHsgT0ZCIH0gZnJvbSBcIi4vbW9kZS1vZmIuanNcIjtcbmV4cG9ydCB7IHBrY3M3UGFkLCBwa2NzN1N0cmlwIH0gZnJvbSBcIi4vcGFkZGluZy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkFFUyIsIk1vZGVPZk9wZXJhdGlvbiIsIkNCQyIsIkNGQiIsIkNUUiIsIkVDQiIsIk9GQiIsInBrY3M3UGFkIiwicGtjczdTdHJpcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cbc.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cbc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBC: () => (/* binding */ CBC)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\");\n// Cipher Block Chaining\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CBC_iv, _CBC_lastBlock;\n\nclass CBC extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, iv){\n        super(\"ECC\", key, CBC);\n        _CBC_iv.set(this, void 0);\n        _CBC_lastBlock.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \"f\");\n        } else {\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \"f\");\n    }\n    get iv() {\n        return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \"f\"));\n    }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext.length);\n        for(let i = 0; i < plaintext.length; i += 16){\n            for(let j = 0; j < 16; j++){\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] ^= plaintext[i + j];\n            }\n            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\")), \"f\");\n            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\"), i);\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(ciphertext.length);\n        for(let i = 0; i < ciphertext.length; i += 16){\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\n            for(let j = 0; j < 16; j++){\n                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j];\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] = ciphertext[i + j];\n            }\n        }\n        return plaintext;\n    }\n}\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap(); //# sourceMappingURL=mode-cbc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jYmMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3QkFBd0I7QUFDeEIsSUFBSUEseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxTQUFTQztBQUMrQjtBQUNyQyxNQUFNRSxZQUFZRCxxREFBZUE7SUFDcENFLFlBQVlDLEdBQUcsRUFBRUMsRUFBRSxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxPQUFPRCxLQUFLRjtRQUNsQkgsUUFBUUgsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLO1FBQ3ZCSSxlQUFlSixHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUs7UUFDOUIsSUFBSVMsSUFBSTtZQUNKLElBQUlBLEdBQUdDLE1BQU0sR0FBRyxJQUFJO2dCQUNoQixNQUFNLElBQUliLFVBQVU7WUFDeEI7WUFDQU4sdUJBQXVCLElBQUksRUFBRVksU0FBUyxJQUFJUSxXQUFXRixLQUFLO1FBQzlELE9BQ0s7WUFDRGxCLHVCQUF1QixJQUFJLEVBQUVZLFNBQVMsSUFBSVEsV0FBVyxLQUFLO1FBQzlEO1FBQ0FwQix1QkFBdUIsSUFBSSxFQUFFYSxnQkFBZ0IsSUFBSSxDQUFDSyxFQUFFLEVBQUU7SUFDMUQ7SUFDQSxJQUFJQSxLQUFLO1FBQUUsT0FBTyxJQUFJRSxXQUFXVix1QkFBdUIsSUFBSSxFQUFFRSxTQUFTO0lBQU87SUFDOUVTLFFBQVFDLFNBQVMsRUFBRTtRQUNmLElBQUlBLFVBQVVILE1BQU0sR0FBRyxJQUFJO1lBQ3ZCLE1BQU0sSUFBSWIsVUFBVTtRQUN4QjtRQUNBLE1BQU1pQixhQUFhLElBQUlILFdBQVdFLFVBQVVILE1BQU07UUFDbEQsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlGLFVBQVVILE1BQU0sRUFBRUssS0FBSyxHQUFJO1lBQzNDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQ3pCZix1QkFBdUIsSUFBSSxFQUFFRyxnQkFBZ0IsSUFBSSxDQUFDWSxFQUFFLElBQUlILFNBQVMsQ0FBQ0UsSUFBSUMsRUFBRTtZQUM1RTtZQUNBekIsdUJBQXVCLElBQUksRUFBRWEsZ0JBQWdCLElBQUksQ0FBQ2EsR0FBRyxDQUFDTCxPQUFPLENBQUNYLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixPQUFPO1lBQ2xIVSxXQUFXZCxHQUFHLENBQUNDLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixNQUFNVztRQUN0RTtRQUNBLE9BQU9EO0lBQ1g7SUFDQUksUUFBUUosVUFBVSxFQUFFO1FBQ2hCLElBQUlBLFdBQVdKLE1BQU0sR0FBRyxJQUFJO1lBQ3hCLE1BQU0sSUFBSWIsVUFBVTtRQUN4QjtRQUNBLE1BQU1nQixZQUFZLElBQUlGLFdBQVdHLFdBQVdKLE1BQU07UUFDbEQsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlELFdBQVdKLE1BQU0sRUFBRUssS0FBSyxHQUFJO1lBQzVDLE1BQU1JLFFBQVEsSUFBSSxDQUFDRixHQUFHLENBQUNDLE9BQU8sQ0FBQ0osV0FBV00sUUFBUSxDQUFDTCxHQUFHQSxJQUFJO1lBQzFELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQ3pCSCxTQUFTLENBQUNFLElBQUlDLEVBQUUsR0FBR0csS0FBSyxDQUFDSCxFQUFFLEdBQUdmLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixJQUFJLENBQUNZLEVBQUU7Z0JBQ2xGZix1QkFBdUIsSUFBSSxFQUFFRyxnQkFBZ0IsSUFBSSxDQUFDWSxFQUFFLEdBQUdGLFVBQVUsQ0FBQ0MsSUFBSUMsRUFBRTtZQUM1RTtRQUNKO1FBQ0EsT0FBT0g7SUFDWDtBQUNKO0FBQ0FWLFVBQVUsSUFBSWtCLFdBQVdqQixpQkFBaUIsSUFBSWlCLFdBQzlDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNiYy5qcz9mODdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENpcGhlciBCbG9jayBDaGFpbmluZ1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9DQkNfaXYsIF9DQkNfbGFzdEJsb2NrO1xuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IGNsYXNzIENCQyBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdikge1xuICAgICAgICBzdXBlcihcIkVDQ1wiLCBrZXksIENCQyk7XG4gICAgICAgIF9DQkNfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DQkNfbGFzdEJsb2NrLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGl2IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgdGhpcy5pdiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXSBePSBwbGFpbnRleHRbaSArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0LnNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIiksIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuYWVzLmRlY3J5cHQoY2lwaGVydGV4dC5zdWJhcnJheShpLCBpICsgMTYpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gPSBibG9ja1tqXSBeIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal0gPSBjaXBoZXJ0ZXh0W2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbl9DQkNfaXYgPSBuZXcgV2Vha01hcCgpLCBfQ0JDX2xhc3RCbG9jayA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWNiYy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfQ0JDX2l2IiwiX0NCQ19sYXN0QmxvY2siLCJNb2RlT2ZPcGVyYXRpb24iLCJDQkMiLCJjb25zdHJ1Y3RvciIsImtleSIsIml2IiwibGVuZ3RoIiwiVWludDhBcnJheSIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJjaXBoZXJ0ZXh0IiwiaSIsImoiLCJhZXMiLCJkZWNyeXB0IiwiYmxvY2siLCJzdWJhcnJheSIsIldlYWtNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cbc.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cfb.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cfb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CFB: () => (/* binding */ CFB)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\");\n// Cipher Feedback\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\n\nclass CFB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, iv, segmentSize = 8){\n        super(\"CFB\", key, CFB);\n        _CFB_instances.add(this);\n        _CFB_iv.set(this, void 0);\n        _CFB_shiftRegister.set(this, void 0);\n        // This library currently only handles byte-aligned segmentSize\n        if (!Number.isInteger(segmentSize) || segmentSize % 8) {\n            throw new TypeError(\"invalid segmentSize\");\n        }\n        Object.defineProperties(this, {\n            segmentSize: {\n                enumerable: true,\n                value: segmentSize\n            }\n        });\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\n        } else {\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\n    }\n    get iv() {\n        return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\"));\n    }\n    encrypt(plaintext) {\n        if (8 * plaintext.length % this.segmentSize) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const ciphertext = new Uint8Array(plaintext);\n        for(let i = 0; i < ciphertext.length; i += segmentSize){\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for(let j = 0; j < segmentSize; j++){\n                ciphertext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (8 * ciphertext.length % this.segmentSize) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const plaintext = new Uint8Array(ciphertext);\n        for(let i = 0; i < plaintext.length; i += segmentSize){\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for(let j = 0; j < segmentSize; j++){\n                plaintext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return plaintext;\n    }\n}\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n    const segmentSize = this.segmentSize / 8;\n    // Shift the register\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n}; //# sourceMappingURL=mode-cfb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jZmIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrQkFBa0I7QUFDbEIsSUFBSUEseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxnQkFBZ0JDLFNBQVNDLG9CQUFvQkM7QUFDTDtBQUNyQyxNQUFNRSxZQUFZRCxxREFBZUE7SUFDcENFLFlBQVlDLEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxjQUFjLENBQUMsQ0FBRTtRQUNsQyxLQUFLLENBQUMsT0FBT0YsS0FBS0Y7UUFDbEJMLGVBQWVVLEdBQUcsQ0FBQyxJQUFJO1FBQ3ZCVCxRQUFRSixHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUs7UUFDdkJLLG1CQUFtQkwsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLO1FBQ2xDLCtEQUErRDtRQUMvRCxJQUFJLENBQUNjLE9BQU9DLFNBQVMsQ0FBQ0gsZ0JBQWlCQSxjQUFjLEdBQUk7WUFDckQsTUFBTSxJQUFJZixVQUFVO1FBQ3hCO1FBQ0FtQixPQUFPQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7WUFDMUJMLGFBQWE7Z0JBQUVNLFlBQVk7Z0JBQU14QixPQUFPa0I7WUFBWTtRQUN4RDtRQUNBLElBQUlELElBQUk7WUFDSixJQUFJQSxHQUFHUSxNQUFNLEdBQUcsSUFBSTtnQkFDaEIsTUFBTSxJQUFJdEIsVUFBVTtZQUN4QjtZQUNBTix1QkFBdUIsSUFBSSxFQUFFYSxTQUFTLElBQUlnQixXQUFXVCxLQUFLO1FBQzlELE9BQ0s7WUFDRHBCLHVCQUF1QixJQUFJLEVBQUVhLFNBQVMsSUFBSWdCLFdBQVcsS0FBSztRQUM5RDtRQUNBN0IsdUJBQXVCLElBQUksRUFBRWMsb0JBQW9CLElBQUksQ0FBQ00sRUFBRSxFQUFFO0lBQzlEO0lBQ0EsSUFBSUEsS0FBSztRQUFFLE9BQU8sSUFBSVMsV0FBV25CLHVCQUF1QixJQUFJLEVBQUVHLFNBQVM7SUFBTztJQUM5RWlCLFFBQVFDLFNBQVMsRUFBRTtRQUNmLElBQUksSUFBSUEsVUFBVUgsTUFBTSxHQUFHLElBQUksQ0FBQ1AsV0FBVyxFQUFFO1lBQ3pDLE1BQU0sSUFBSWYsVUFBVTtRQUN4QjtRQUNBLE1BQU1lLGNBQWMsSUFBSSxDQUFDQSxXQUFXLEdBQUc7UUFDdkMsTUFBTVcsYUFBYSxJQUFJSCxXQUFXRTtRQUNsQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUQsV0FBV0osTUFBTSxFQUFFSyxLQUFLWixZQUFhO1lBQ3JELE1BQU1hLGFBQWEsSUFBSSxDQUFDQyxHQUFHLENBQUNMLE9BQU8sQ0FBQ3BCLHVCQUF1QixJQUFJLEVBQUVJLG9CQUFvQjtZQUNyRixJQUFLLElBQUlzQixJQUFJLEdBQUdBLElBQUlmLGFBQWFlLElBQUs7Z0JBQ2xDSixVQUFVLENBQUNDLElBQUlHLEVBQUUsSUFBSUYsVUFBVSxDQUFDRSxFQUFFO1lBQ3RDO1lBQ0ExQix1QkFBdUIsSUFBSSxFQUFFRSxnQkFBZ0IsS0FBS0csWUFBWVAsSUFBSSxDQUFDLElBQUksRUFBRXdCLFdBQVdLLFFBQVEsQ0FBQ0o7UUFDakc7UUFDQSxPQUFPRDtJQUNYO0lBQ0FNLFFBQVFOLFVBQVUsRUFBRTtRQUNoQixJQUFJLElBQUlBLFdBQVdKLE1BQU0sR0FBRyxJQUFJLENBQUNQLFdBQVcsRUFBRTtZQUMxQyxNQUFNLElBQUlmLFVBQVU7UUFDeEI7UUFDQSxNQUFNZSxjQUFjLElBQUksQ0FBQ0EsV0FBVyxHQUFHO1FBQ3ZDLE1BQU1VLFlBQVksSUFBSUYsV0FBV0c7UUFDakMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVILE1BQU0sRUFBRUssS0FBS1osWUFBYTtZQUNwRCxNQUFNYSxhQUFhLElBQUksQ0FBQ0MsR0FBRyxDQUFDTCxPQUFPLENBQUNwQix1QkFBdUIsSUFBSSxFQUFFSSxvQkFBb0I7WUFDckYsSUFBSyxJQUFJc0IsSUFBSSxHQUFHQSxJQUFJZixhQUFhZSxJQUFLO2dCQUNsQ0wsU0FBUyxDQUFDRSxJQUFJRyxFQUFFLElBQUlGLFVBQVUsQ0FBQ0UsRUFBRTtZQUNyQztZQUNBMUIsdUJBQXVCLElBQUksRUFBRUUsZ0JBQWdCLEtBQUtHLFlBQVlQLElBQUksQ0FBQyxJQUFJLEVBQUV3QixXQUFXSyxRQUFRLENBQUNKO1FBQ2pHO1FBQ0EsT0FBT0Y7SUFDWDtBQUNKO0FBQ0FsQixVQUFVLElBQUkwQixXQUFXekIscUJBQXFCLElBQUl5QixXQUFXM0IsaUJBQWlCLElBQUk0QixXQUFXekIsYUFBYSxTQUFTQSxXQUFXMEIsSUFBSTtJQUM5SCxNQUFNcEIsY0FBYyxJQUFJLENBQUNBLFdBQVcsR0FBRztJQUN2QyxxQkFBcUI7SUFDckJYLHVCQUF1QixJQUFJLEVBQUVJLG9CQUFvQixLQUFLTCxHQUFHLENBQUNDLHVCQUF1QixJQUFJLEVBQUVJLG9CQUFvQixLQUFLdUIsUUFBUSxDQUFDaEI7SUFDekhYLHVCQUF1QixJQUFJLEVBQUVJLG9CQUFvQixLQUFLTCxHQUFHLENBQUNnQyxLQUFLSixRQUFRLENBQUMsR0FBR2hCLGNBQWMsS0FBS0E7QUFDbEcsR0FDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jZmIuanM/M2U1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDaXBoZXIgRmVlZGJhY2tcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ0ZCX2luc3RhbmNlcywgX0NGQl9pdiwgX0NGQl9zaGlmdFJlZ2lzdGVyLCBfQ0ZCX3NoaWZ0O1xuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IGNsYXNzIENGQiBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdiwgc2VnbWVudFNpemUgPSA4KSB7XG4gICAgICAgIHN1cGVyKFwiQ0ZCXCIsIGtleSwgQ0ZCKTtcbiAgICAgICAgX0NGQl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfQ0ZCX2l2LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ0ZCX3NoaWZ0UmVnaXN0ZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFRoaXMgbGlicmFyeSBjdXJyZW50bHkgb25seSBoYW5kbGVzIGJ5dGUtYWxpZ25lZCBzZWdtZW50U2l6ZVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VnbWVudFNpemUpIHx8IChzZWdtZW50U2l6ZSAlIDgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBzZWdtZW50U2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBzZWdtZW50U2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogc2VnbWVudFNpemUgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9pdiwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DRkJfaXYsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCB0aGlzLml2LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pdiwgXCJmXCIpKTsgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmICg4ICogcGxhaW50ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIHNlZ21lbnRTaXplIGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50U2l6ZSA9IHRoaXMuc2VnbWVudFNpemUgLyA4O1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSBzZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgeG9yU2VnbWVudCA9IHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX2luc3RhbmNlcywgXCJtXCIsIF9DRkJfc2hpZnQpLmNhbGwodGhpcywgY2lwaGVydGV4dC5zdWJhcnJheShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoOCAqIGNpcGhlcnRleHQubGVuZ3RoICUgdGhpcy5zZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIHNlZ21lbnRTaXplIGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50U2l6ZSA9IHRoaXMuc2VnbWVudFNpemUgLyA4O1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IHNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICBjb25zdCB4b3JTZWdtZW50ID0gdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VnbWVudFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pbnN0YW5jZXMsIFwibVwiLCBfQ0ZCX3NoaWZ0KS5jYWxsKHRoaXMsIGNpcGhlcnRleHQuc3ViYXJyYXkoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxufVxuX0NGQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9DRkJfc2hpZnRSZWdpc3RlciA9IG5ldyBXZWFrTWFwKCksIF9DRkJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0NGQl9zaGlmdCA9IGZ1bmN0aW9uIF9DRkJfc2hpZnQoZGF0YSkge1xuICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XG4gICAgLy8gU2hpZnQgdGhlIHJlZ2lzdGVyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zdWJhcnJheShzZWdtZW50U2l6ZSkpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikuc2V0KGRhdGEuc3ViYXJyYXkoMCwgc2VnbWVudFNpemUpLCAxNiAtIHNlZ21lbnRTaXplKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWNmYi5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfQ0ZCX2luc3RhbmNlcyIsIl9DRkJfaXYiLCJfQ0ZCX3NoaWZ0UmVnaXN0ZXIiLCJfQ0ZCX3NoaWZ0IiwiTW9kZU9mT3BlcmF0aW9uIiwiQ0ZCIiwiY29uc3RydWN0b3IiLCJrZXkiLCJpdiIsInNlZ21lbnRTaXplIiwiYWRkIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwiZW5jcnlwdCIsInBsYWludGV4dCIsImNpcGhlcnRleHQiLCJpIiwieG9yU2VnbWVudCIsImFlcyIsImoiLCJzdWJhcnJheSIsImRlY3J5cHQiLCJXZWFrTWFwIiwiV2Vha1NldCIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-cfb.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ctr.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ctr.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CTR: () => (/* binding */ CTR)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\");\n// Counter Mode\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter;\n\nclass CTR extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, initialValue){\n        super(\"CTR\", key, CTR);\n        // Remaining bytes for the one-time pad\n        _CTR_remaining.set(this, void 0);\n        _CTR_remainingIndex.set(this, void 0);\n        // The current counter\n        _CTR_counter.set(this, void 0);\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \"f\");\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").fill(0);\n        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, \"f\"), \"f\"); // This will be discarded immediately\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \"f\");\n        if (initialValue == null) {\n            initialValue = 1;\n        }\n        if (typeof initialValue === \"number\") {\n            this.setCounterValue(initialValue);\n        } else {\n            this.setCounterBytes(initialValue);\n        }\n    }\n    get counter() {\n        return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \"f\"));\n    }\n    setCounterValue(value) {\n        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError(\"invalid counter initial integer value\");\n        }\n        for(let index = 15; index >= 0; --index){\n            __classPrivateFieldGet(this, _CTR_counter, \"f\")[index] = value % 256;\n            value = Math.floor(value / 256);\n        }\n    }\n    setCounterBytes(value) {\n        if (value.length !== 16) {\n            throw new TypeError(\"invalid counter initial Uint8Array value length\");\n        }\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").set(value);\n    }\n    increment() {\n        for(let i = 15; i >= 0; i--){\n            if (__classPrivateFieldGet(this, _CTR_counter, \"f\")[i] === 255) {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i] = 0;\n            } else {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i]++;\n                break;\n            }\n        }\n    }\n    encrypt(plaintext) {\n        var _a, _b;\n        const crypttext = new Uint8Array(plaintext);\n        for(let i = 0; i < crypttext.length; i++){\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \"f\");\n                this.increment();\n            }\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \"f\")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return crypttext;\n    }\n    decrypt(ciphertext) {\n        return this.encrypt(ciphertext);\n    }\n}\n_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap(); //# sourceMappingURL=mode-ctr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jdHIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxlQUFlO0FBQ2YsSUFBSUEseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxnQkFBZ0JDLHFCQUFxQkM7QUFD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dUIsS0FBS0MsTUFBTUEsRUFBQyxHQUFJLE1BQU1ELEdBQUc7UUFDL007UUFDQSxPQUFPRTtJQUNYO0lBQ0FFLFFBQVFDLFVBQVUsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDTztJQUN4QjtBQUNKO0FBQ0E3QixpQkFBaUIsSUFBSThCLFdBQVc3QixzQkFBc0IsSUFBSTZCLFdBQVc1QixlQUFlLElBQUk0QixXQUN4RixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jdHIuanM/YWZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3VudGVyIE1vZGVcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ1RSX3JlbWFpbmluZywgX0NUUl9yZW1haW5pbmdJbmRleCwgX0NUUl9jb3VudGVyO1xuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IGNsYXNzIENUUiBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgc3VwZXIoXCJDVFJcIiwga2V5LCBDVFIpO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXMgZm9yIHRoZSBvbmUtdGltZSBwYWRcbiAgICAgICAgX0NUUl9yZW1haW5pbmcuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DVFJfcmVtYWluaW5nSW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgX0NUUl9jb3VudGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfY291bnRlciwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikuZmlsbCgwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSwgXCJmXCIpOyAvLyBUaGlzIHdpbGwgYmUgZGlzY2FyZGVkIGltbWVkaWF0ZWx5XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgMTYsIFwiZlwiKTtcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGluaXRpYWxWYWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q291bnRlclZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJCeXRlcyhpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb3VudGVyKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSk7IH1cbiAgICBzZXRDb3VudGVyVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIGludGVnZXIgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpbmRleF0gPSB2YWx1ZSAlIDI1NjtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDI1Nik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q291bnRlckJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjb3VudGVyIGluaXRpYWwgVWludDhBcnJheSB2YWx1ZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBpbmNyZW1lbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0rKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjcnlwdHRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyeXB0dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpID09PSAxNikge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIDAsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3J5cHR0ZXh0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpLCBfYSA9IF9iKyssIF9iKSwgXCJmXCIpLCBfYV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgfVxufVxuX0NUUl9yZW1haW5pbmcgPSBuZXcgV2Vha01hcCgpLCBfQ1RSX3JlbWFpbmluZ0luZGV4ID0gbmV3IFdlYWtNYXAoKSwgX0NUUl9jb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY3RyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsInZhbHVlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJjYWxsIiwic2V0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsImdldCIsIl9DVFJfcmVtYWluaW5nIiwiX0NUUl9yZW1haW5pbmdJbmRleCIsIl9DVFJfY291bnRlciIsIk1vZGVPZk9wZXJhdGlvbiIsIkNUUiIsImNvbnN0cnVjdG9yIiwia2V5IiwiaW5pdGlhbFZhbHVlIiwiVWludDhBcnJheSIsImZpbGwiLCJzZXRDb3VudGVyVmFsdWUiLCJzZXRDb3VudGVyQnl0ZXMiLCJjb3VudGVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsImluZGV4IiwiTWF0aCIsImZsb29yIiwibGVuZ3RoIiwiaW5jcmVtZW50IiwiaSIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJfYSIsIl9iIiwiY3J5cHR0ZXh0IiwiYWVzIiwiZGVjcnlwdCIsImNpcGhlcnRleHQiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ctr.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ecb.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ecb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ECB: () => (/* binding */ ECB)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\");\n// Electronic Code Book\n\nclass ECB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key){\n        super(\"ECB\", key, ECB);\n    }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const crypttext = new Uint8Array(plaintext.length);\n        for(let i = 0; i < plaintext.length; i += 16){\n            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);\n        }\n        return crypttext;\n    }\n    decrypt(crypttext) {\n        if (crypttext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(crypttext.length);\n        for(let i = 0; i < crypttext.length; i += 16){\n            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);\n        }\n        return plaintext;\n    }\n} //# sourceMappingURL=mode-ecb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1lY2IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx1QkFBdUI7QUFDcUI7QUFDckMsTUFBTUMsWUFBWUQscURBQWVBO0lBQ3BDRSxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLLENBQUMsT0FBT0EsS0FBS0Y7SUFDdEI7SUFDQUcsUUFBUUMsU0FBUyxFQUFFO1FBQ2YsSUFBSUEsVUFBVUMsTUFBTSxHQUFHLElBQUk7WUFDdkIsTUFBTSxJQUFJQyxVQUFVO1FBQ3hCO1FBQ0EsTUFBTUMsWUFBWSxJQUFJQyxXQUFXSixVQUFVQyxNQUFNO1FBQ2pELElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJTCxVQUFVQyxNQUFNLEVBQUVJLEtBQUssR0FBSTtZQUMzQ0YsVUFBVUcsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxDQUFDUixPQUFPLENBQUNDLFVBQVVRLFFBQVEsQ0FBQ0gsR0FBR0EsSUFBSSxNQUFNQTtRQUNuRTtRQUNBLE9BQU9GO0lBQ1g7SUFDQU0sUUFBUU4sU0FBUyxFQUFFO1FBQ2YsSUFBSUEsVUFBVUYsTUFBTSxHQUFHLElBQUk7WUFDdkIsTUFBTSxJQUFJQyxVQUFVO1FBQ3hCO1FBQ0EsTUFBTUYsWUFBWSxJQUFJSSxXQUFXRCxVQUFVRixNQUFNO1FBQ2pELElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJRixVQUFVRixNQUFNLEVBQUVJLEtBQUssR0FBSTtZQUMzQ0wsVUFBVU0sR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxDQUFDRSxPQUFPLENBQUNOLFVBQVVLLFFBQVEsQ0FBQ0gsR0FBR0EsSUFBSSxNQUFNQTtRQUNuRTtRQUNBLE9BQU9MO0lBQ1g7QUFDSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWVjYi5qcz82NTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVsZWN0cm9uaWMgQ29kZSBCb29rXG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5leHBvcnQgY2xhc3MgRUNCIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0JcIiwga2V5LCBFQ0IpO1xuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY3J5cHR0ZXh0LnNldCh0aGlzLmFlcy5lbmNyeXB0KHBsYWludGV4dC5zdWJhcnJheShpLCBpICsgMTYpKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjcnlwdHRleHQpIHtcbiAgICAgICAgaWYgKGNyeXB0dGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjcnlwdHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBwbGFpbnRleHQuc2V0KHRoaXMuYWVzLmRlY3J5cHQoY3J5cHR0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtZWNiLmpzLm1hcCJdLCJuYW1lcyI6WyJNb2RlT2ZPcGVyYXRpb24iLCJFQ0IiLCJjb25zdHJ1Y3RvciIsImtleSIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJjcnlwdHRleHQiLCJVaW50OEFycmF5IiwiaSIsInNldCIsImFlcyIsInN1YmFycmF5IiwiZGVjcnlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ecb.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ofb.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ofb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OFB: () => (/* binding */ OFB)\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\");\n// Output Feedback\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;\n\nclass OFB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, iv){\n        super(\"OFB\", key, OFB);\n        _OFB_iv.set(this, void 0);\n        _OFB_lastPrecipher.set(this, void 0);\n        _OFB_lastPrecipherIndex.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), \"f\");\n        } else {\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, \"f\");\n        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, \"f\");\n    }\n    get iv() {\n        return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, \"f\"));\n    }\n    encrypt(plaintext) {\n        var _a, _b;\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext);\n        for(let i = 0; i < ciphertext.length; i++){\n            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, \"f\");\n            }\n            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        return this.encrypt(ciphertext);\n    }\n}\n_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap(); //# sourceMappingURL=mode-ofb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1vZmIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrQkFBa0I7QUFDbEIsSUFBSUEseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxTQUFTQyxvQkFBb0JDO0FBQ1c7QUFDckMsTUFBTUUsWUFBWUQscURBQWVBO0lBQ3BDRSxZQUFZQyxHQUFHLEVBQUVDLEVBQUUsQ0FBRTtRQUNqQixLQUFLLENBQUMsT0FBT0QsS0FBS0Y7UUFDbEJKLFFBQVFILEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSztRQUN2QkksbUJBQW1CSixHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUs7UUFDbENLLHdCQUF3QkwsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLO1FBQ3ZDLElBQUlVLElBQUk7WUFDSixJQUFJQSxHQUFHQyxNQUFNLEdBQUcsSUFBSTtnQkFDaEIsTUFBTSxJQUFJZCxVQUFVO1lBQ3hCO1lBQ0FOLHVCQUF1QixJQUFJLEVBQUVZLFNBQVMsSUFBSVMsV0FBV0YsS0FBSztRQUM5RCxPQUNLO1lBQ0RuQix1QkFBdUIsSUFBSSxFQUFFWSxTQUFTLElBQUlTLFdBQVcsS0FBSztRQUM5RDtRQUNBckIsdUJBQXVCLElBQUksRUFBRWEsb0JBQW9CLElBQUksQ0FBQ00sRUFBRSxFQUFFO1FBQzFEbkIsdUJBQXVCLElBQUksRUFBRWMseUJBQXlCLElBQUk7SUFDOUQ7SUFDQSxJQUFJSyxLQUFLO1FBQUUsT0FBTyxJQUFJRSxXQUFXWCx1QkFBdUIsSUFBSSxFQUFFRSxTQUFTO0lBQU87SUFDOUVVLFFBQVFDLFNBQVMsRUFBRTtRQUNmLElBQUlDLElBQUlDO1FBQ1IsSUFBSUYsVUFBVUgsTUFBTSxHQUFHLElBQUk7WUFDdkIsTUFBTSxJQUFJZCxVQUFVO1FBQ3hCO1FBQ0EsTUFBTW9CLGFBQWEsSUFBSUwsV0FBV0U7UUFDbEMsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlELFdBQVdOLE1BQU0sRUFBRU8sSUFBSztZQUN4QyxJQUFJakIsdUJBQXVCLElBQUksRUFBRUkseUJBQXlCLFNBQVMsSUFBSTtnQkFDbkVkLHVCQUF1QixJQUFJLEVBQUVhLG9CQUFvQixJQUFJLENBQUNlLEdBQUcsQ0FBQ04sT0FBTyxDQUFDWix1QkFBdUIsSUFBSSxFQUFFRyxvQkFBb0IsT0FBTztnQkFDMUhiLHVCQUF1QixJQUFJLEVBQUVjLHlCQUF5QixHQUFHO1lBQzdEO1lBQ0FZLFVBQVUsQ0FBQ0MsRUFBRSxJQUFJakIsdUJBQXVCLElBQUksRUFBRUcsb0JBQW9CLElBQUksQ0FBQ2IsdUJBQXVCLElBQUksRUFBRWMseUJBQTBCVyxDQUFBQSxLQUFLZix1QkFBdUIsSUFBSSxFQUFFSSx5QkFBeUIsTUFBTVUsS0FBS0MsTUFBTUEsRUFBQyxHQUFJLE1BQU1ELEdBQUc7UUFDNU47UUFDQSxPQUFPRTtJQUNYO0lBQ0FHLFFBQVFILFVBQVUsRUFBRTtRQUNoQixJQUFJQSxXQUFXTixNQUFNLEdBQUcsSUFBSTtZQUN4QixNQUFNLElBQUlkLFVBQVU7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ0k7SUFDeEI7QUFDSjtBQUNBZCxVQUFVLElBQUlrQixXQUFXakIscUJBQXFCLElBQUlpQixXQUFXaEIsMEJBQTBCLElBQUlnQixXQUMzRixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1vZmIuanM/MDk2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPdXRwdXQgRmVlZGJhY2tcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfT0ZCX2l2LCBfT0ZCX2xhc3RQcmVjaXBoZXIsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4O1xuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IGNsYXNzIE9GQiBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdikge1xuICAgICAgICBzdXBlcihcIk9GQlwiLCBrZXksIE9GQik7XG4gICAgICAgIF9PRkJfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9PRkJfbGFzdFByZWNpcGhlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX09GQl9sYXN0UHJlY2lwaGVySW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgdGhpcy5pdiwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAxNiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIFwiZlwiKSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIDAsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNpcGhlcnRleHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXIsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCBcImZcIiksIF9hID0gX2IrKywgX2IpLCBcImZcIiksIF9hXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgfVxufVxuX09GQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlciA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlckluZGV4ID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtb2ZiLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsInZhbHVlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJjYWxsIiwic2V0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsImdldCIsIl9PRkJfaXYiLCJfT0ZCX2xhc3RQcmVjaXBoZXIiLCJfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCIsIk1vZGVPZk9wZXJhdGlvbiIsIk9GQiIsImNvbnN0cnVjdG9yIiwia2V5IiwiaXYiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwiZW5jcnlwdCIsInBsYWludGV4dCIsIl9hIiwiX2IiLCJjaXBoZXJ0ZXh0IiwiaSIsImFlcyIsImRlY3J5cHQiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode-ofb.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModeOfOperation: () => (/* binding */ ModeOfOperation)\n/* harmony export */ });\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes.js */ \"(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/aes.js\");\n\nclass ModeOfOperation {\n    constructor(name, key, cls){\n        if (cls && !(this instanceof cls)) {\n            throw new Error(`${name} must be instantiated with \"new\"`);\n        }\n        Object.defineProperties(this, {\n            aes: {\n                enumerable: true,\n                value: new _aes_js__WEBPACK_IMPORTED_MODULE_0__.AES(key)\n            },\n            name: {\n                enumerable: true,\n                value: name\n            }\n        });\n    }\n} //# sourceMappingURL=mode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUN4QixNQUFNQztJQUNUQyxZQUFZQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxDQUFFO1FBQ3hCLElBQUlBLE9BQU8sQ0FBRSxLQUFJLFlBQVlBLEdBQUUsR0FBSTtZQUMvQixNQUFNLElBQUlDLE1BQU0sQ0FBQyxFQUFFSCxLQUFLLGdDQUFnQyxDQUFDO1FBQzdEO1FBQ0FJLE9BQU9DLGdCQUFnQixDQUFDLElBQUksRUFBRTtZQUMxQkMsS0FBSztnQkFBRUMsWUFBWTtnQkFBTUMsT0FBTyxJQUFJWCx3Q0FBR0EsQ0FBQ0k7WUFBSztZQUM3Q0QsTUFBTTtnQkFBRU8sWUFBWTtnQkFBTUMsT0FBT1I7WUFBSztRQUMxQztJQUNKO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS5qcz9jMTVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFFUyB9IGZyb20gXCIuL2Flcy5qc1wiO1xuZXhwb3J0IGNsYXNzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwga2V5LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBjbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiYCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWVzOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuZXcgQUVTKGtleSkgfSxcbiAgICAgICAgICAgIG5hbWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG5hbWUgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJBRVMiLCJNb2RlT2ZPcGVyYXRpb24iLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJrZXkiLCJjbHMiLCJFcnJvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJhZXMiLCJlbnVtZXJhYmxlIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/mode.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/padding.js":
/*!************************************************************************!*\
  !*** ../../node_modules/ethers/node_modules/aes-js/lib.esm/padding.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pkcs7Pad: () => (/* binding */ pkcs7Pad),\n/* harmony export */   pkcs7Strip: () => (/* binding */ pkcs7Strip)\n/* harmony export */ });\nfunction pkcs7Pad(data) {\n    const padder = 16 - data.length % 16;\n    const result = new Uint8Array(data.length + padder);\n    result.set(data);\n    for(let i = data.length; i < result.length; i++){\n        result[i] = padder;\n    }\n    return result;\n}\nfunction pkcs7Strip(data) {\n    if (data.length < 16) {\n        throw new TypeError(\"PKCS#7 invalid length\");\n    }\n    const padder = data[data.length - 1];\n    if (padder > 16) {\n        throw new TypeError(\"PKCS#7 padding byte out of range\");\n    }\n    const length = data.length - padder;\n    for(let i = 0; i < padder; i++){\n        if (data[length + i] !== padder) {\n            throw new TypeError(\"PKCS#7 invalid padding byte\");\n        }\n    }\n    return new Uint8Array(data.subarray(0, length));\n} //# sourceMappingURL=padding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vcGFkZGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLFNBQVNDLElBQUk7SUFDekIsTUFBTUMsU0FBUyxLQUFNRCxLQUFLRSxNQUFNLEdBQUc7SUFDbkMsTUFBTUMsU0FBUyxJQUFJQyxXQUFXSixLQUFLRSxNQUFNLEdBQUdEO0lBQzVDRSxPQUFPRSxHQUFHLENBQUNMO0lBQ1gsSUFBSyxJQUFJTSxJQUFJTixLQUFLRSxNQUFNLEVBQUVJLElBQUlILE9BQU9ELE1BQU0sRUFBRUksSUFBSztRQUM5Q0gsTUFBTSxDQUFDRyxFQUFFLEdBQUdMO0lBQ2hCO0lBQ0EsT0FBT0U7QUFDWDtBQUNPLFNBQVNJLFdBQVdQLElBQUk7SUFDM0IsSUFBSUEsS0FBS0UsTUFBTSxHQUFHLElBQUk7UUFDbEIsTUFBTSxJQUFJTSxVQUFVO0lBQ3hCO0lBQ0EsTUFBTVAsU0FBU0QsSUFBSSxDQUFDQSxLQUFLRSxNQUFNLEdBQUcsRUFBRTtJQUNwQyxJQUFJRCxTQUFTLElBQUk7UUFDYixNQUFNLElBQUlPLFVBQVU7SUFDeEI7SUFDQSxNQUFNTixTQUFTRixLQUFLRSxNQUFNLEdBQUdEO0lBQzdCLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJTCxRQUFRSyxJQUFLO1FBQzdCLElBQUlOLElBQUksQ0FBQ0UsU0FBU0ksRUFBRSxLQUFLTCxRQUFRO1lBQzdCLE1BQU0sSUFBSU8sVUFBVTtRQUN4QjtJQUNKO0lBQ0EsT0FBTyxJQUFJSixXQUFXSixLQUFLUyxRQUFRLENBQUMsR0FBR1A7QUFDM0MsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vcGFkZGluZy5qcz8xZTk5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwa2NzN1BhZChkYXRhKSB7XG4gICAgY29uc3QgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBwYWRkZXIpO1xuICAgIHJlc3VsdC5zZXQoZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhZGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwa2NzN1N0cmlwKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVyID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgIGlmIChwYWRkZXIgPiAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIHBhZGRlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlcjsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLnN1YmFycmF5KDAsIGxlbmd0aCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkZGluZy5qcy5tYXAiXSwibmFtZXMiOlsicGtjczdQYWQiLCJkYXRhIiwicGFkZGVyIiwibGVuZ3RoIiwicmVzdWx0IiwiVWludDhBcnJheSIsInNldCIsImkiLCJwa2NzN1N0cmlwIiwiVHlwZUVycm9yIiwic3ViYXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ethers/node_modules/aes-js/lib.esm/padding.js\n");

/***/ })

};
;