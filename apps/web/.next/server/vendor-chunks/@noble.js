"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/_assert.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/_assert.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFPLFNBQVNBLE9BQU9DLENBQUM7SUFDcEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLENBQUMsd0JBQXdCLEVBQUVILEVBQUUsQ0FBQztBQUN0RDtBQUNPLFNBQVNJLEtBQUtDLENBQUM7SUFDbEIsSUFBSSxPQUFPQSxNQUFNLFdBQ2IsTUFBTSxJQUFJRixNQUFNLENBQUMsc0JBQXNCLEVBQUVFLEVBQUUsQ0FBQztBQUNwRDtBQUNPLFNBQVNDLE1BQU1ELENBQUMsRUFBRSxHQUFHRSxPQUFPO0lBQy9CLElBQUksQ0FBRUYsQ0FBQUEsYUFBYUcsVUFBUyxHQUN4QixNQUFNLElBQUlDLFVBQVU7SUFDeEIsSUFBSUYsUUFBUUcsTUFBTSxHQUFHLEtBQUssQ0FBQ0gsUUFBUUksUUFBUSxDQUFDTixFQUFFSyxNQUFNLEdBQ2hELE1BQU0sSUFBSUQsVUFBVSxDQUFDLDhCQUE4QixFQUFFRixRQUFRLGdCQUFnQixFQUFFRixFQUFFSyxNQUFNLENBQUMsQ0FBQztBQUNqRztBQUNPLFNBQVNFLEtBQUtBLElBQUk7SUFDckIsSUFBSSxPQUFPQSxTQUFTLGNBQWMsT0FBT0EsS0FBS0MsTUFBTSxLQUFLLFlBQ3JELE1BQU0sSUFBSVYsTUFBTTtJQUNwQkosT0FBT2EsS0FBS0UsU0FBUztJQUNyQmYsT0FBT2EsS0FBS0csUUFBUTtBQUN4QjtBQUNPLFNBQVNDLE9BQU9DLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDakQsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUloQixNQUFNO0lBQ3BCLElBQUllLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUlqQixNQUFNO0FBQ3hCO0FBQ08sU0FBU2tCLE9BQU9DLEdBQUcsRUFBRUwsUUFBUTtJQUNoQ1gsTUFBTWdCO0lBQ04sTUFBTUMsTUFBTU4sU0FBU0gsU0FBUztJQUM5QixJQUFJUSxJQUFJWixNQUFNLEdBQUdhLEtBQUs7UUFDbEIsTUFBTSxJQUFJcEIsTUFBTSxDQUFDLHNEQUFzRCxFQUFFb0IsSUFBSSxDQUFDO0lBQ2xGO0FBQ0o7QUFDQSxNQUFNQyxTQUFTO0lBQ1h6QjtJQUNBSztJQUNBRTtJQUNBTTtJQUNBSTtJQUNBSztBQUNKO0FBQ0EsaUVBQWVHLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MDlmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4iXSwibmFtZXMiOlsibnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImJvb2wiLCJiIiwiYnl0ZXMiLCJsZW5ndGhzIiwiVWludDhBcnJheSIsIlR5cGVFcnJvciIsImxlbmd0aCIsImluY2x1ZGVzIiwiaGFzaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiZXhpc3RzIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJvdXRwdXQiLCJvdXQiLCJtaW4iLCJhc3NlcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/_sha2.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/_sha2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        this.get().forEach((v, i)=>oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNxQjtBQUN2RCx5QkFBeUI7QUFDekIsU0FBU0ksYUFBYUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUMvQyxJQUFJLE9BQU9ILEtBQUtELFlBQVksS0FBSyxZQUM3QixPQUFPQyxLQUFLRCxZQUFZLENBQUNFLFlBQVlDLE9BQU9DO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9OLFFBQVFJO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVMsR0FBR0gsSUFBSUo7SUFDbkNILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVUsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSw2QkFBNkI7QUFDdEIsTUFBTVUsYUFBYWpCLDJDQUFJQTtJQUMxQmtCLFlBQVlDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVkLElBQUksQ0FBRTtRQUM5QyxLQUFLO1FBQ0wsSUFBSSxDQUFDWSxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDZCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDZSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlDLFdBQVdSO1FBQzdCLElBQUksQ0FBQ2YsSUFBSSxHQUFHSCxxREFBVUEs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QUNwQyxXQUFXLEVBQUM7UUFDakNvQyxHQUFHakIsR0FBRyxJQUFJLElBQUksQ0FBQ1MsR0FBRztRQUNsQixNQUFNLEVBQUUzQixRQUFRLEVBQUVPLE1BQU0sRUFBRUgsTUFBTSxFQUFFRCxRQUFRLEVBQUVHLFNBQVMsRUFBRUQsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNuRThCLEdBQUcvQixNQUFNLEdBQUdBO1FBQ1orQixHQUFHOUIsR0FBRyxHQUFHQTtRQUNUOEIsR0FBR2hDLFFBQVEsR0FBR0E7UUFDZGdDLEdBQUc3QixTQUFTLEdBQUdBO1FBQ2YsSUFBSUYsU0FBU0osVUFDVG1DLEdBQUc1QixNQUFNLENBQUNXLEdBQUcsQ0FBQ1g7UUFDbEIsT0FBTzRCO0lBQ1g7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/NGM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiBvdmlldy5zZXRVaW50MzIoNCAqIGksIHYsIGlzTEUpKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJIYXNoIiwiY3JlYXRlVmlldyIsInRvQnl0ZXMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsInZhbHVlIiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIlNIQTIiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwidXBkYXRlIiwiZGF0YSIsImV4aXN0cyIsImxlbiIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsIm91dHB1dCIsImZpbGwiLCJpIiwib3ZpZXciLCJnZXQiLCJmb3JFYWNoIiwidiIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/_u64.js":
/*!****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/_u64.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l)=>l;\nconst rotr32L = (h, l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxNQUFNQSxhQUFhQyxPQUFPLEtBQUssS0FBSztBQUNwQyxNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLCtFQUErRTtBQUN4RSxTQUFTRSxRQUFRQyxDQUFDLEVBQUVDLEtBQUssS0FBSztJQUNqQyxJQUFJQSxJQUNBLE9BQU87UUFBRUMsR0FBR0MsT0FBT0gsSUFBSUo7UUFBYVEsR0FBR0QsT0FBTyxLQUFNTCxPQUFRRjtJQUFZO0lBQzVFLE9BQU87UUFBRU0sR0FBR0MsT0FBTyxLQUFNTCxPQUFRRixjQUFjO1FBQUdRLEdBQUdELE9BQU9ILElBQUlKLGNBQWM7SUFBRTtBQUNwRjtBQUNPLFNBQVNTLE1BQU1DLEdBQUcsRUFBRUwsS0FBSyxLQUFLO0lBQ2pDLElBQUlNLEtBQUssSUFBSUMsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFJQyxLQUFLLElBQUlGLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFBSztRQUNqQyxNQUFNLEVBQUVULENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdMLFFBQVFPLEdBQUcsQ0FBQ0ssRUFBRSxFQUFFVjtRQUNqQyxDQUFDTSxFQUFFLENBQUNJLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDVDtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDRztRQUFJRztLQUFHO0FBQ25CO0FBQ08sTUFBTUUsUUFBUSxDQUFDVixHQUFHRSxJQUFNLE9BQVFGLE1BQU0sTUFBTUosT0FBUUQsT0FBT08sTUFBTSxHQUFHO0FBQzNFLHVCQUF1QjtBQUN2QixNQUFNUyxRQUFRLENBQUNYLEdBQUdFLEdBQUdVLElBQU1aLE1BQU1ZO0FBQ2pDLE1BQU1DLFFBQVEsQ0FBQ2IsR0FBR0UsR0FBR1UsSUFBTSxL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ZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz8xMjViIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydCBjb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIGwsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKGgsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIGwpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG4vLyBSZW1vdmluZyBcImV4cG9ydFwiIGhhcyA1JSBwZXJmIHBlbmFsdHkgLV8tXG5leHBvcnQgZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbiJdLCJuYW1lcyI6WyJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsImZyb21CaWciLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsInNwbGl0IiwibHN0IiwiQWgiLCJVaW50MzJBcnJheSIsImxlbmd0aCIsIkFsIiwiaSIsInRvQmlnIiwic2hyU0giLCJzIiwic2hyU0wiLCJyb3RyU0giLCJyb3RyU0wiLCJyb3RyQkgiLCJyb3RyQkwiLCJyb3RyMzJIIiwicm90cjMyTCIsInJvdGxTSCIsInJvdGxTTCIsInJvdGxCSCIsInJvdGxCTCIsImFkZCIsIkJoIiwiQmwiLCJhZGQzTCIsIkNsIiwiYWRkM0giLCJsb3ciLCJDaCIsImFkZDRMIiwiRGwiLCJhZGQ0SCIsIkRoIiwiYWRkNUwiLCJFbCIsImFkZDVIIiwiRWgiLCJ1NjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/crypto.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/crypto.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: undefined\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFDOUIsTUFBTUMsU0FBUztJQUNsQkMsTUFBTUYsNExBQVVBO0lBQ2hCRyxLQUFLQztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz9mMjcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSB7XG4gICAgbm9kZTogbm9kZUNyeXB0byxcbiAgICB3ZWI6IHVuZGVmaW5lZCxcbn07XG4iXSwibmFtZXMiOlsibm9kZUNyeXB0byIsImNyeXB0byIsIm5vZGUiLCJ3ZWIiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/crypto.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/hmac.js":
/*!****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/hmac.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (!(this.iHash instanceof _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash)) throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n        const blockLen = this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQ1M7QUFDM0Msa0JBQWtCO0FBQ2xCLE1BQU1HLGFBQWFGLDJDQUFJQTtJQUNuQkcsWUFBWUMsSUFBSSxFQUFFQyxJQUFJLENBQUU7UUFDcEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCUix1REFBVyxDQUFDSztRQUNaLE1BQU1JLE1BQU1QLGtEQUFPQSxDQUFDSTtRQUNwQixJQUFJLENBQUNJLEtBQUssR0FBR0wsS0FBS00sTUFBTTtRQUN4QixJQUFJLENBQUUsS0FBSSxDQUFDRCxLQUFLLFlBQVlULDJDQUFHLEdBQzNCLE1BQU0sSUFBSVcsVUFBVTtRQUN4QixNQUFNQyxXQUFZLElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUksQ0FBQ0gsS0FBSyxDQUFDRyxRQUFRO1FBQ3JELElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxTQUFTO1FBQ3JDLE1BQU1DLE1BQU0sSUFBSUMsV0FBV0g7UUFDM0Isd0NBQXdDO1FBQ3hDRSxJQUFJRSxHQUFHLENBQUNSLElBQUlTLE1BQU0sR0FBRyxJQUFJLENBQUNSLEtBQUssQ0FBQ0csUUFBUSxHQUFHUixLQUFLTSxNQUFNLEdBQUdRLE1BQU0sQ0FBQ1YsS0FBS1csTUFBTSxLQUFLWDtRQUNoRixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSU4sSUFBSUcsTUFBTSxFQUFFRyxJQUM1Qk4sR0FBRyxDQUFDTSxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ1MsTUFBTSxDQUFDSjtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTyxLQUFLLEdBQUdqQixLQUFLTSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSU4sSUFBSUcsTUFBTSxFQUFFRyxJQUM1Qk4sR0FBRyxDQUFDTSxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ0gsTUFBTSxDQUFDSjtRQUNsQkEsSUFBSVEsSUFBSSxDQUFDO0lBQ2I7SUFDQUosT0FBT0ssR0FBRyxFQUFFO1FBQ1J4Qix5REFBYSxDQUFDLElBQUk7UUFDbEIsSUFBSSxDQUFDVSxLQUFLLENBQUNTLE1BQU0sQ0FBQ0s7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUUsV0FBV0MsR0FBRyxFQUFFO1FBQ1ozQix5REFBYSxDQUFDLElBQUk7UUFDbEJBLHdEQUFZLENBQUMyQixLQUFLLElBQUksQ0FBQ2IsU0FBUztRQUNoQyxJQUFJLENBQUNQLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLEtBQUssQ0FBQ2dCLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDTCxLQUFLLENBQUNILE1BQU0sQ0FBQ1E7UUFDbEIsSUFBSSxDQUFDTCxLQUFLLENBQUNJLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDRSxPQUFPO0lBQ2hCO0lBQ0FULFNBQVM7UUFDTCxNQUFNTyxNQUFNLElBQUlYLFdBQVcsSUFBSSxDQUFDTSxLQUFLLENBQUNSLFNBQVM7UUFDL0MsSUFBSSxDQUFDWSxVQUFVLENBQUNDO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsbUdBQW1HO1FBQ25HQSxNQUFPQSxDQUFBQSxLQUFLQyxPQUFPckIsTUFBTSxDQUFDcUIsT0FBT0MsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFWCxLQUFLLEVBQUVaLEtBQUssRUFBRUgsUUFBUSxFQUFFQyxTQUFTLEVBQUVLLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RWlCLEtBQUtBO1FBQ0xBLEdBQUd4QixRQUFRLEdBQUdBO1FBQ2R3QixHQUFHdkIsU0FBUyxHQUFHQTtRQUNmdUIsR0FBR2xCLFFBQVEsR0FBR0E7UUFDZGtCLEdBQUdqQixTQUFTLEdBQUdBO1FBQ2ZpQixHQUFHVCxLQUFLLEdBQUdBLE1BQU1RLFVBQVUsQ0FBQ0MsR0FBR1QsS0FBSztRQUNwQ1MsR0FBR3JCLEtBQUssR0FBR0EsTUFBTW9CLFVBQVUsQ0FBQ0MsR0FBR3JCLEtBQUs7UUFDcEMsT0FBT3FCO0lBQ1g7SUFDQUYsVUFBVTtRQUNOLElBQUksQ0FBQ3JCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNjLEtBQUssQ0FBQ08sT0FBTztRQUNsQixJQUFJLENBQUNuQixLQUFLLENBQUNtQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1LLE9BQU8sQ0FBQzdCLE1BQU1JLEtBQUswQixVQUFZLElBQUloQyxLQUFLRSxNQUFNSSxLQUFLVSxNQUFNLENBQUNnQixTQUFTZixNQUFNLEdBQUc7QUFDekZjLEtBQUt2QixNQUFNLEdBQUcsQ0FBQ04sTUFBTUksTUFBUSxJQUFJTixLQUFLRSxNQUFNSSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcz9hY2JhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICghKHRoaXMuaUhhc2ggaW5zdGFuY2VvZiBIYXNoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9ICh0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbik7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiB0aGlzLmlIYXNoLmJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5ieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJIYXNoIiwidG9CeXRlcyIsIkhNQUMiLCJjb25zdHJ1Y3RvciIsImhhc2giLCJfa2V5IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJrZXkiLCJpSGFzaCIsImNyZWF0ZSIsIlR5cGVFcnJvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkIiwiVWludDhBcnJheSIsInNldCIsImxlbmd0aCIsInVwZGF0ZSIsImRpZ2VzdCIsImkiLCJvSGFzaCIsImZpbGwiLCJidWYiLCJleGlzdHMiLCJkaWdlc3RJbnRvIiwib3V0IiwiYnl0ZXMiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJobWFjIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/pbkdf2.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hmac.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10\n    }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(c);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(dkLen);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(asyncTick);\n    if (c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return {\n        c,\n        dkLen,\n        asyncTick,\n        DK,\n        PRF,\n        PRFSalt\n    };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW) prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */ function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for(let ui = 1; ui < c; ui++){\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.asyncLoop)(c - 1, asyncTick, (i)=>{\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUNEO0FBQ3NDO0FBQ3ZFLHdEQUF3RDtBQUN4RCxTQUFTTSxXQUFXQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsS0FBSyxFQUFFQyxLQUFLO0lBQzdDVix1REFBVyxDQUFDTztJQUNaLE1BQU1JLE9BQU9QLG9EQUFTQSxDQUFDO1FBQUVRLE9BQU87UUFBSUMsV0FBVztJQUFHLEdBQUdIO0lBQ3JELE1BQU0sRUFBRUksQ0FBQyxFQUFFRixLQUFLLEVBQUVDLFNBQVMsRUFBRSxHQUFHRjtJQUNoQ1gseURBQWEsQ0FBQ2M7SUFDZGQseURBQWEsQ0FBQ1k7SUFDZFoseURBQWEsQ0FBQ2E7SUFDZCxJQUFJQyxJQUFJLEdBQ0osTUFBTSxJQUFJRSxNQUFNO0lBQ3BCLE1BQU1DLFdBQVdkLGtEQUFPQSxDQUFDSztJQUN6QixNQUFNVSxPQUFPZixrREFBT0EsQ0FBQ007SUFDckIsOENBQThDO0lBQzlDLE1BQU1VLEtBQUssSUFBSUMsV0FBV1I7SUFDMUIsMENBQTBDO0lBQzFDLE1BQU1TLE1BQU1wQiwwQ0FBSUEsQ0FBQ3FCLE1BQU0sQ0FBQ2YsTUFBTVU7SUFDOUIsTUFBTU0sVUFBVUYsSUFBSUcsVUFBVSxHQUFHQyxNQUFNLENBQUNQO0lBQ3hDLE9BQU87UUFBRUo7UUFBR0Y7UUFBT0M7UUFBV007UUFBSUU7UUFBS0U7SUFBUTtBQUNuRDtBQUNBLFNBQVNHLGFBQWFMLEdBQUcsRUFBRUUsT0FBTyxFQUFFSixFQUFFLEVBQUVRLElBQUksRUFBRUMsQ0FBQztJQUMzQ1AsSUFBSVEsT0FBTztJQUNYTixRQUFRTSxPQUFPO0lBQ2YsSUFBSUYsTUFDQUEsS0FBS0UsT0FBTztJQUNoQkQsRUFBRUUsSUFBSSxDQUFDO0lBQ1AsT0FBT1g7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNZLE9BQU94QixJQUFJLEVBQUVVLFFBQVEsRUFB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LE1BQU1DO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanM/MzRhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbmltcG9ydCB7IGNyZWF0ZVZpZXcsIHRvQnl0ZXMsIGNoZWNrT3B0cywgYXN5bmNMb29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgIGFzc2VydC5oYXNoKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICBhc3NlcnQubnVtYmVyKGMpO1xuICAgIGFzc2VydC5udW1iZXIoZGtMZW4pO1xuICAgIGFzc2VydC5udW1iZXIoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gdG9CeXRlcyhfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHNhbHQgPSB0b0J5dGVzKF9zYWx0KTtcbiAgICAvLyBESyA9IFBCS0RGMihQUkYsIFBhc3N3b3JkLCBTYWx0LCBjLCBka0xlbik7XG4gICAgY29uc3QgREsgPSBuZXcgVWludDhBcnJheShka0xlbik7XG4gICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgY29uc3QgUFJGID0gaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgICByZXR1cm4geyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH07XG59XG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSkge1xuICAgIFBSRi5kZXN0cm95KCk7XG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XG4gICAgaWYgKHByZlcpXG4gICAgICAgIHByZlcuZGVzdHJveSgpO1xuICAgIHUuZmlsbCgwKTtcbiAgICByZXR1cm4gREs7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHNhbHQgLSBjcnlwdG9ncmFwaGljIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0ge2MsIGRrTGVufSB3aGVyZSBjIGlzIHdvcmsgZmFjdG9yIGFuZCBka0xlbiBpcyBvdXRwdXQgbWVzc2FnZSBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBmb3IgKGxldCB1aSA9IDE7IHVpIDwgYzsgdWkrKykge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGJrZGYyQXN5bmMoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChjIC0gMSwgYXN5bmNUaWNrLCAoaSkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJobWFjIiwiY3JlYXRlVmlldyIsInRvQnl0ZXMiLCJjaGVja09wdHMiLCJhc3luY0xvb3AiLCJwYmtkZjJJbml0IiwiaGFzaCIsIl9wYXNzd29yZCIsIl9zYWx0IiwiX29wdHMiLCJvcHRzIiwiZGtMZW4iLCJhc3luY1RpY2siLCJjIiwibnVtYmVyIiwiRXJyb3IiLCJwYXNzd29yZCIsInNhbHQiLCJESyIsIlVpbnQ4QXJyYXkiLCJQUkYiLCJjcmVhdGUiLCJQUkZTYWx0IiwiX2Nsb25lSW50byIsInVwZGF0ZSIsInBia2RmMk91dHB1dCIsInByZlciLCJ1IiwiZGVzdHJveSIsImZpbGwiLCJwYmtkZjIiLCJhcnIiLCJ2aWV3Iiwib3V0cHV0TGVuIiwidGkiLCJwb3MiLCJUaSIsInN1YmFycmF5Iiwic2V0SW50MzIiLCJkaWdlc3RJbnRvIiwic2V0IiwibGVuZ3RoIiwidWkiLCJpIiwicGJrZGYyQXN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/ripemd160.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([\n    7,\n    4,\n    13,\n    1,\n    10,\n    6,\n    15,\n    3,\n    12,\n    0,\n    9,\n    5,\n    2,\n    14,\n    11,\n    8\n]);\nconst Id = Uint8Array.from({\n    length: 16\n}, (_, i)=>i);\nconst Pi = Id.map((i)=>(9 * i + 5) % 16);\nlet idxL = [\n    Id\n];\nlet idxR = [\n    Pi\n];\nfor(let i = 0; i < 4; i++)for (let j of [\n    idxL,\n    idxR\n])j.push(j[i].map((k)=>Rho[k]));\nconst shifts = [\n    [\n        11,\n        14,\n        15,\n        12,\n        5,\n        8,\n        7,\n        9,\n        11,\n        13,\n        14,\n        15,\n        6,\n        7,\n        9,\n        8\n    ],\n    [\n        12,\n        13,\n        11,\n        15,\n        6,\n        9,\n        9,\n        7,\n        12,\n        15,\n        11,\n        13,\n        7,\n        8,\n        7,\n        7\n    ],\n    [\n        13,\n        15,\n        14,\n        11,\n        7,\n        7,\n        6,\n        8,\n        13,\n        14,\n        13,\n        12,\n        5,\n        5,\n        6,\n        9\n    ],\n    [\n        14,\n        11,\n        12,\n        14,\n        8,\n        6,\n        5,\n        5,\n        15,\n        12,\n        15,\n        14,\n        9,\n        9,\n        8,\n        6\n    ],\n    [\n        15,\n        12,\n        13,\n        13,\n        9,\n        5,\n        8,\n        6,\n        14,\n        11,\n        12,\n        11,\n        8,\n        6,\n        5,\n        5\n    ]\n].map((i)=>new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i)=>idx.map((j)=>shifts[i][j]));\nconst shiftsR = idxR.map((idx, i)=>idx.map((j)=>shifts[i][j]));\nconst Kl = new Uint32Array([\n    0x00000000,\n    0x5a827999,\n    0x6ed9eba1,\n    0x8f1bbcdc,\n    0xa953fd4e\n]);\nconst Kr = new Uint32Array([\n    0x50a28be6,\n    0x5c4dd124,\n    0x6d703ef3,\n    0x7a6d76e9,\n    0x00000000\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift;\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0) return x ^ y ^ z;\n    else if (group === 1) return x & y | ~x & z;\n    else if (group === 2) return (x | ~y) ^ z;\n    else if (group === 3) return x & z | y & ~z;\n    else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor(){\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [\n            h0,\n            h1,\n            h2,\n            h3,\n            h4\n        ];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for(let group = 0; group < 5; group++){\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for(let i = 0; i < 16; i++){\n                const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for(let i = 0; i < 16; i++){\n                const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */ const ripemd160 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new RIPEMD160());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1c7QUFDN0MsMERBQTBEO0FBQzFELDZFQUE2RTtBQUM3RSxNQUFNRSxNQUFNLElBQUlDLFdBQVc7SUFBQztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtDQUFFO0FBQ2pGLE1BQU1DLEtBQUtELFdBQVdFLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUcsR0FBRyxDQUFDQyxHQUFHQyxJQUFNQTtBQUNyRCxNQUFNQyxLQUFLTCxHQUFHTSxHQUFHLENBQUMsQ0FBQ0YsSUFBTSxDQUFDLElBQUlBLElBQUksS0FBSztBQUN2QyxJQUFJRyxPQUFPO0lBQUNQO0NBQUc7QUFDZixJQUFJUSxPQUFPO0lBQUNIO0NBQUc7QUFDZixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUNuQixLQUFLLElBQUlLLEtBQUs7SUFBQ0Y7SUFBTUM7Q0FBSyxDQUN0QkMsRUFBRUMsSUFBSSxDQUFDRCxDQUFDLENBQUNMLEVBQUUsQ0FBQ0UsR0FBRyxDQUFDLENBQUNLLElBQU1iLEdBQUcsQ0FBQ2EsRUFBRTtBQUNyQyxNQUFNQyxTQUFTO0lBQ1g7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztLQUFFO0lBQ3hEO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7S0FBRTtJQUN4RDtRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO0tBQUU7SUFDeEQ7UUFB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RyxDQUFDNEIsRUFBRSxDQUFDbkQsRUFBRSxDQUFDLEdBQUdpRCxLQUFLSSxFQUFFLENBQUNyRCxFQUFFLElBQUk4QyxLQUFNO2dCQUMvRVIsS0FBS1EsSUFBSUEsS0FBS0YsSUFBSUEsS0FBSzdCLEtBQUsyQixJQUFJLE1BQU0sR0FBR0EsS0FBS0YsSUFBSUEsS0FBS2UsSUFBSSxrQkFBa0I7WUFDakY7UUFDSjtRQUNBLHFEQUFxRDtRQUNyRCxJQUFJLENBQUN2QixHQUFHLENBQUMsSUFBSyxDQUFDTCxFQUFFLEdBQUdjLEtBQUtHLEtBQU0sR0FBRyxJQUFLLENBQUNoQixFQUFFLEdBQUdlLEtBQUtHLEtBQU0sR0FBRyxJQUFLLENBQUNqQixFQUFFLEdBQUdnQixLQUFLUCxLQUFNLEdBQUcsSUFBSyxDQUFDUixFQUFFLEdBQUdPLEtBQUtHLEtBQU0sR0FBRyxJQUFLLENBQUNkLEVBQUUsR0FBR2EsS0FBS0csS0FBTTtJQUN2STtJQUNBYyxhQUFhO1FBQ1RqQyxJQUFJa0MsSUFBSSxDQUFDO0lBQ2I7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxDQUFDSCxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDekIsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7SUFDekI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU02QixZQUFZcEUsMERBQWVBLENBQUMsSUFBTSxJQUFJK0IsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vcmlwZW1kMTYwLmpzPzdiMmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuY29uc3QgUmhvID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XG5sZXQgaWR4TCA9IFtJZF07XG5sZXQgaWR4UiA9IFtQaV07XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcbiAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG9ba10pKTtcbmNvbnN0IHNoaWZ0cyA9IFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gaWR4Ui5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBLbCA9IG5ldyBVaW50MzJBcnJheShbMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZV0pO1xuY29uc3QgS3IgPSBuZXcgVWludDMyQXJyYXkoWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmV4cG9ydCBjbGFzcyBSSVBFTUQxNjAgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5oMCA9IDB4Njc0NTIzMDEgfCAwO1xuICAgICAgICB0aGlzLmgxID0gMHhlZmNkYWI4OSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IDB4MTAzMjU0NzYgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMCB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBoMCwgaDEsIGgyLCBoMywgaDQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbaDAsIGgxLCBoMiwgaDMsIGg0XTtcbiAgICB9XG4gICAgc2V0KGgwLCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICB0aGlzLmgwID0gaDAgfCAwO1xuICAgICAgICB0aGlzLmgxID0gaDEgfCAwO1xuICAgICAgICB0aGlzLmgyID0gaDIgfCAwO1xuICAgICAgICB0aGlzLmgzID0gaDMgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gaDQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgQlVGW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBhbCA9IHRoaXMuaDAgfCAwLCBhciA9IGFsLCBibCA9IHRoaXMuaDEgfCAwLCBiciA9IGJsLCBjbCA9IHRoaXMuaDIgfCAwLCBjciA9IGNsLCBkbCA9IHRoaXMuaDMgfCAwLCBkciA9IGRsLCBlbCA9IHRoaXMuaDQgfCAwLCBlciA9IGVsO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgPSAwOyBncm91cCA8IDU7IGdyb3VwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsW2dyb3VwXSwgaGJyID0gS3JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJsID0gaWR4TFtncm91cF0sIHJyID0gaWR4Ultncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMW2dyb3VwXSwgc3IgPSBzaGlmdHNSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bCA9IChyb3RsKGFsICsgZihncm91cCwgYmwsIGNsLCBkbCkgKyBCVUZbcmxbaV1dICsgaGJsLCBzbFtpXSkgKyBlbCkgfCAwO1xuICAgICAgICAgICAgICAgIGFsID0gZWwsIGVsID0gZGwsIGRsID0gcm90bChjbCwgMTApIHwgMCwgY2wgPSBibCwgYmwgPSB0bDsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyIGxvb3BzIGFyZSAxMCUgZmFzdGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IChyb3RsKGFyICsgZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcbiAgICAgICAgICAgICAgICBhciA9IGVyLCBlciA9IGRyLCBkciA9IHJvdGwoY3IsIDEwKSB8IDAsIGNyID0gYnIsIGJyID0gdHI7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIEJVRi5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogUklQRU1ELTE2MCAtIGEgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtc2cgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHJpcGVtZDE2MCA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuIl0sIm5hbWVzIjpbIlNIQTIiLCJ3cmFwQ29uc3RydWN0b3IiLCJSaG8iLCJVaW50OEFycmF5IiwiSWQiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJQaSIsIm1hcCIsImlkeEwiLCJpZHhSIiwiaiIsInB1c2giLCJrIiwic2hpZnRzIiwic2hpZnRzTCIsImlkeCIsInNoaWZ0c1IiLCJLbCIsIlVpbnQzMkFycmF5IiwiS3IiLCJyb3RsIiwid29yZCIsInNoaWZ0IiwiZiIsImdyb3VwIiwieCIsInkiLCJ6IiwiQlVGIiwiUklQRU1EMTYwIiwiY29uc3RydWN0b3IiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJnZXRVaW50MzIiLCJhbCIsImFyIiwiYmwiLCJiciIsImNsIiwiY3IiLCJkbCIsImRyIiwiZWwiLCJlciIsInJHcm91cCIsImhibCIsImhiciIsInJsIiwicnIiLCJzbCIsInNyIiwidGwiLCJ0ciIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImRlc3Ryb3llZCIsImJ1ZmZlciIsInJpcGVtZDE2MCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/scrypt.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/scrypt.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptAsync: () => (/* binding */ scryptAsync)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha256.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pbkdf2.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\n// RFC 7914 Scrypt KDF\n// Left rotate for uint32\nconst rotl = (a, b)=>a << b | a >>> 32 - b;\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for(let i = 0; i < 8; i += 2){\n        x04 ^= rotl(x00 + x12 | 0, 7);\n        x08 ^= rotl(x04 + x00 | 0, 9);\n        x12 ^= rotl(x08 + x04 | 0, 13);\n        x00 ^= rotl(x12 + x08 | 0, 18);\n        x09 ^= rotl(x05 + x01 | 0, 7);\n        x13 ^= rotl(x09 + x05 | 0, 9);\n        x01 ^= rotl(x13 + x09 | 0, 13);\n        x05 ^= rotl(x01 + x13 | 0, 18);\n        x14 ^= rotl(x10 + x06 | 0, 7);\n        x02 ^= rotl(x14 + x10 | 0, 9);\n        x06 ^= rotl(x02 + x14 | 0, 13);\n        x10 ^= rotl(x06 + x02 | 0, 18);\n        x03 ^= rotl(x15 + x11 | 0, 7);\n        x07 ^= rotl(x03 + x15 | 0, 9);\n        x11 ^= rotl(x07 + x03 | 0, 13);\n        x15 ^= rotl(x11 + x07 | 0, 18);\n        x01 ^= rotl(x00 + x03 | 0, 7);\n        x02 ^= rotl(x01 + x00 | 0, 9);\n        x03 ^= rotl(x02 + x01 | 0, 13);\n        x00 ^= rotl(x03 + x02 | 0, 18);\n        x06 ^= rotl(x05 + x04 | 0, 7);\n        x07 ^= rotl(x06 + x05 | 0, 9);\n        x04 ^= rotl(x07 + x06 | 0, 13);\n        x05 ^= rotl(x04 + x07 | 0, 18);\n        x11 ^= rotl(x10 + x09 | 0, 7);\n        x08 ^= rotl(x11 + x10 | 0, 9);\n        x09 ^= rotl(x08 + x11 | 0, 13);\n        x10 ^= rotl(x09 + x08 | 0, 18);\n        x12 ^= rotl(x15 + x14 | 0, 7);\n        x13 ^= rotl(x12 + x15 | 0, 9);\n        x14 ^= rotl(x13 + x12 | 0, 13);\n        x15 ^= rotl(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = y00 + x00 | 0;\n    out[oi++] = y01 + x01 | 0;\n    out[oi++] = y02 + x02 | 0;\n    out[oi++] = y03 + x03 | 0;\n    out[oi++] = y04 + x04 | 0;\n    out[oi++] = y05 + x05 | 0;\n    out[oi++] = y06 + x06 | 0;\n    out[oi++] = y07 + x07 | 0;\n    out[oi++] = y08 + x08 | 0;\n    out[oi++] = y09 + x09 | 0;\n    out[oi++] = y10 + x10 | 0;\n    out[oi++] = y11 + x11 | 0;\n    out[oi++] = y12 + x12 | 0;\n    out[oi++] = y13 + x13 | 0;\n    out[oi++] = y14 + x14 | 0;\n    out[oi++] = y15 + x15 | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for(let i = 0; i < 16; i++)out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n    for(let i = 0; i < r; i++, head += 16, ii += 16){\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0) tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, ii += 16, out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(N);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(r);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(p);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(dkLen);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(asyncTick);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== \"function\") throw new Error(\"progressCb should be function\");\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n        throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");\n    }\n    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {\n        throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_1__.sha256, password, salt, {\n        c: 1,\n        dkLen: blockSize * p\n    });\n    const B32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.u32)(new Uint8Array(blockSize));\n    let blockMixCb = ()=>{};\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = ()=>{\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return {\n        N,\n        r,\n        p,\n        dkLen,\n        blockSize32,\n        V,\n        B32,\n        B,\n        tmp,\n        blockMixCb,\n        asyncTick\n    };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_1__.sha256, password, B, {\n        c: 1,\n        dkLen\n    });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */ function scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    for(let pi = 0; pi < p; pi++){\n        const Pi = blockSize32 * pi;\n        for(let i = 0; i < blockSize32; i++)V[i] = B32[Pi + i]; // V[0] = B[i]\n        for(let i = 0, pos = 0; i < N - 1; i++){\n            BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for(let i = 0; i < N; i++){\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for(let k = 0; k < blockSize32; k++)tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n/**\n * Scrypt KDF from RFC 7914.\n */ async function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    for(let pi = 0; pi < p; pi++){\n        const Pi = blockSize32 * pi;\n        for(let i = 0; i < blockSize32; i++)V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.asyncLoop)(N - 1, asyncTick, (i)=>{\n            BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.asyncLoop)(N, asyncTick, (i)=>{\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for(let k = 0; k < blockSize32; k++)tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NjcnlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDRztBQUNBO0FBQ2tCO0FBQ3ZELHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsTUFBTU0sT0FBTyxDQUFDQyxHQUFHQyxJQUFNLEtBQU1BLElBQU1ELE1BQU8sS0FBS0M7QUFDL0MsZ0RBQWdEO0FBQ2hELG9FQUFvRTtBQUNwRSxrQkFBa0I7QUFDbEIsU0FBU0MsWUFBWUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLEtBQUssRUFBRUMsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLEVBQUU7SUFDN0MseUNBQXlDO0lBQ3pDLGFBQWE7SUFDYixJQUFJQyxNQUFNTixJQUFJLENBQUNDLEtBQUssR0FBR0MsS0FBSyxDQUFDQyxLQUFLLEVBQUVJLE1BQU1QLElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxLQUFLLENBQUNDLEtBQUs7SUFDbEUsSUFBSUssTUFBTVIsSUFBSSxDQUFDQyxLQUFLLEdBQUdDLEtBQUssQ0FBQ0MsS0FBSyxFQUFFTSxNQUFNVCxJQUFJLENBQUNDLEtBQUssR0FBR0MsS0FBSyxDQUFDQyxLQUFLO0lBQ2xFLElBQUlPLE1BQU1WLElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxLQUFLLENBQUNDLEtBQUssRUFBRVEsTUFBTVgsSUFBSSxDQUFDQyxLQUFLLEdBQUdDLEtBQUssQ0FBQ0MsS0FBSztJQUNsRSxJQUFJUyxNQUFNWixJQUFJLENBQUNDLEtBQUssR0FBR0MsS0FBSyxDQUFDQyxLQUFLLEVBQUVVLE1BQU1iLElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxLQUFLLENBQUNDLEtBQUs7SUFDbEUsSUFBSVcsTUFBTWQsSUFBSSxDQUFDQyxLQUFLLEdBQUdDLEtBQUssQ0FBQ0MsS0FBSyxFQUFFWSxNQUFNZixJQUFJLENBQUNDLEtBQUssR0FBR0MsS0FBSyxDQUFDQyxLQUFLO0lBQ2xFLElBQUlhLE1BQU1oQixJQUFJLENBQUND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cEIsYUFBY2xCLElBQUksMkJBQTJCO1lBQ3pFMEI7UUFDSjtRQUNBM0IsU0FBU3dCLEdBQUcsQ0FBQ1osSUFBSSxLQUFLTyxhQUFhSSxLQUFLZSxJQUFJckMsSUFBSSx1QkFBdUI7UUFDdkUwQjtRQUNBLE1BQU16RSxvREFBU0EsQ0FBQzBELEdBQUdGLFdBQVcsQ0FBQ1g7WUFDM0Isa0RBQWtEO1lBQ2xELE1BQU15QyxJQUFJakIsR0FBRyxDQUFDZSxLQUFLbkIsY0FBYyxHQUFHLEdBQUdQLEdBQUcsZ0NBQWdDO1lBQzFFLElBQUssSUFBSTZCLElBQUksR0FBR0EsSUFBSXRCLGFBQWFzQixJQUM3QmYsR0FBRyxDQUFDZSxFQUFFLEdBQUdsQixHQUFHLENBQUNlLEtBQUtHLEVBQUUsR0FBR2pCLENBQUMsQ0FBQ2dCLElBQUlyQixjQUFjc0IsRUFBRSxFQUFFLGlCQUFpQjtZQUNwRXpDLFNBQVMwQixLQUFLLEdBQUdILEtBQUtlLElBQUlyQyxJQUFJLHlCQUF5QjtZQUN2RDBCO1FBQ0o7SUFDSjtJQUNBLE9BQU9PLGFBQWE3QixVQUFVSSxPQUFPWSxHQUFHRyxHQUFHRTtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2NyeXB0LmpzPzg0MjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnLi9zaGEyNTYuanMnO1xuaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSAnLi9wYmtkZjIuanMnO1xuaW1wb3J0IHsgYXN5bmNMb29wLCBjaGVja09wdHMsIHUzMiB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUkZDIDc5MTQgU2NyeXB0IEtERlxuLy8gTGVmdCByb3RhdGUgZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG4vLyBUaGUgbWFpbiBTY3J5cHQgbG9vcDogdXNlcyBTYWxzYSBleHRlbnNpdmVseS5cbi8vIFNpeCB2ZXJzaW9ucyBvZiB0aGUgZnVuY3Rpb24gd2VyZSB0cmllZCwgdGhpcyBpcyB0aGUgZmFzdGVzdCBvbmUuXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIFhvckFuZFNhbHNhKHByZXYsIHBpLCBpbnB1dCwgaWksIG91dCwgb2kpIHtcbiAgICAvLyBCYXNlZCBvbiBodHRwczovL2NyLnlwLnRvL3NhbHNhMjAuaHRtbFxuICAgIC8vIFhvciBibG9ja3NcbiAgICBsZXQgeTAwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA2ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDcgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwOCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA5ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxNCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTE1ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXG4gICAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMywgeDA0ID0geTA0LCB4MDUgPSB5MDUsIHgwNiA9IHkwNiwgeDA3ID0geTA3LCB4MDggPSB5MDgsIHgwOSA9IHkwOSwgeDEwID0geTEwLCB4MTEgPSB5MTEsIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgICAvLyBNYWluIGxvb3AgKHNhbHNhKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgIHgwNCBePSByb3RsKHgwMCArIHgxMiB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MDQgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MTIgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwNSArIHgwMSB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDAxIF49IHJvdGwoeDEzICsgeDA5IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDEgKyB4MTMgfCAwLCAxOCk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MTQgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA2IF49IHJvdGwoeDAyICsgeDE0IHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwMyBePSByb3RsKHgxNSArIHgxMSB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDMgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTEgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgwMSBePSByb3RsKHgwMCArIHgwMyB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDAzIF49IHJvdGwoeDAyICsgeDAxIHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MDMgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDYgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDA0IF49IHJvdGwoeDA3ICsgeDA2IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgxMSBePSByb3RsKHgxMCArIHgwOSB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MTEgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDkgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgxMiBePSByb3RsKHgxNSArIHgxNCB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDE0IF49IHJvdGwoeDEzICsgeDEyIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTQgKyB4MTMgfCAwLCAxOCk7XG4gICAgfVxuICAgIC8vIFdyaXRlIG91dHB1dCAoc2Fsc2EpXG4gICAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAyICsgeDAyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA1ICsgeDA1KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA4ICsgeDA4KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTExICsgeDExKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE0ICsgeDE0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuZnVuY3Rpb24gQmxvY2tNaXgoaW5wdXQsIGlpLCBvdXQsIG9pLCByKSB7XG4gICAgLy8gVGhlIGJsb2NrIEIgaXMgciAxMjgtYnl0ZSBjaHVua3MgKHdoaWNoIGlzIGVxdWl2YWxlbnQgb2YgMnIgNjQtYnl0ZSBjaHVua3MpXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XG4gICAgbGV0IHRhaWwgPSBvaSArIDE2ICogcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpKyssIGhlYWQgKz0gMTYsIGlpICs9IDE2KSB7XG4gICAgICAgIC8vIFdlIHdyaXRlIG9kZCAmIGV2ZW4gWWkgYXQgc2FtZSB0aW1lLiBFdmVuOiAwYlhYWFhYMCBPZGQ6ICAwYlhYWFhYMVxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgdGFpbCArPSAxNjsgLy8gRmlyc3QgaXRlcmF0aW9uIG92ZXJ3cml0ZXMgdG1wIHZhbHVlIGluIHRhaWxcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcbiAgICB9XG59XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgX29wdHMpIHtcbiAgICAvLyBNYXhtZW0gLSAxR0IrMUtCIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHtcbiAgICAgICAgZGtMZW46IDMyLFxuICAgICAgICBhc3luY1RpY2s6IDEwLFxuICAgICAgICBtYXhtZW06IDEwMjQgKiogMyArIDEwMjQsXG4gICAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGFzeW5jVGljaywgbWF4bWVtLCBvblByb2dyZXNzIH0gPSBvcHRzO1xuICAgIGFzc2VydC5udW1iZXIoTik7XG4gICAgYXNzZXJ0Lm51bWJlcihyKTtcbiAgICBhc3NlcnQubnVtYmVyKHApO1xuICAgIGFzc2VydC5udW1iZXIoZGtMZW4pO1xuICAgIGFzc2VydC5udW1iZXIoYXN5bmNUaWNrKTtcbiAgICBhc3NlcnQubnVtYmVyKG1heG1lbSk7XG4gICAgaWYgKG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9ncmVzc0NiIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDEyOCAqIHI7XG4gICAgY29uc3QgYmxvY2tTaXplMzIgPSBibG9ja1NpemUgLyA0O1xuICAgIGlmIChOIDw9IDEgfHwgKE4gJiAoTiAtIDEpKSAhPT0gMCB8fCBOID49IDIgKiogKGJsb2NrU2l6ZSAvIDgpIHx8IE4gPiAyICoqIDMyKSB7XG4gICAgICAgIC8vIE5PVEU6IHdlIGxpbWl0IE4gdG8gYmUgbGVzcyB0aGFuIDIqKjMyIGJlY2F1c2Ugb2YgMzIgYml0IHZhcmlhbnQgb2YgSW50ZWdyaWZ5IGZ1bmN0aW9uXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIEpTIGVuZ2luZXMgdGhhdCBhbGxvd3MgYWxvY2F0ZSBtb3JlIHRoYW4gNEdCIHBlciBzaW5nbGUgVWludDhBcnJheSBmb3Igbm93LCBidXQgY2FuIGNoYW5nZSBpbiBmdXR1cmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBOIG11c3QgYmUgbGFyZ2VyIHRoYW4gMSwgYSBwb3dlciBvZiAyLCBsZXNzIHRoYW4gMl4oMTI4ICogciAvIDgpIGFuZCBsZXNzIHRoYW4gMl4zMicpO1xuICAgIH1cbiAgICBpZiAocCA8IDAgfHwgcCA+ICgoMiAqKiAzMiAtIDEpICogMzIpIC8gYmxvY2tTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBwIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoKDJeMzIgLSAxKSAqIDMyKSAvICgxMjggKiByKScpO1xuICAgIH1cbiAgICBpZiAoZGtMZW4gPCAwIHx8IGRrTGVuID4gKDIgKiogMzIgLSAxKSAqIDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBka0xlbiBzaG91bGQgYmUgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKDJeMzIgLSAxKSAqIDMyJyk7XG4gICAgfVxuICAgIGNvbnN0IG1lbVVzZWQgPSBibG9ja1NpemUgKiAoTiArIHApO1xuICAgIGlmIChtZW1Vc2VkID4gbWF4bWVtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NyeXB0OiBwYXJhbWV0ZXJzIHRvbyBsYXJnZSwgJHttZW1Vc2VkfSAoMTI4ICogciAqIChOICsgcCkpID4gJHttYXhtZW19IChtYXhtZW0pYCk7XG4gICAgfVxuICAgIC8vIFtCMC4uLkJw4oiSMV0g4oaQIFBCS0RGMkhNQUMtU0hBMjU2KFBhc3NwaHJhc2UsIFNhbHQsIDEsIGJsb2NrU2l6ZSpQYXJhbGxlbGl6YXRpb25GYWN0b3IpXG4gICAgLy8gU2luY2UgaXQgaGFzIG9ubHkgb25lIGl0ZXJhdGlvbiB0aGVyZSBpcyBubyByZWFzb24gdG8gdXNlIGFzeW5jIHZhcmlhbnRcbiAgICBjb25zdCBCID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XG4gICAgY29uc3QgQjMyID0gdTMyKEIpO1xuICAgIC8vIFJlLXVzZWQgYmV0d2VlbiBwYXJhbGxlbCBpdGVyYXRpb25zLiBBcnJheShpdGVyYXRpb25zKSBvZiBCXG4gICAgY29uc3QgViA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBOKSk7XG4gICAgY29uc3QgdG1wID0gdTMyKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSkpO1xuICAgIGxldCBibG9ja01peENiID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2tNaXggPSAyICogTiAqIHA7XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2tNaXggLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tNaXhDbnQgPSAwO1xuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xufVxuZnVuY3Rpb24gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKSB7XG4gICAgY29uc3QgcmVzID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIEIsIHsgYzogMSwgZGtMZW4gfSk7XG4gICAgQi5maWxsKDApO1xuICAgIFYuZmlsbCgwKTtcbiAgICB0bXAuZmlsbCgwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzXG4gKiBAcGFyYW0gc2FsdCAtIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0gcGFyYW1ldGVyc1xuICogLSBgTmAgaXMgY3B1L21lbSB3b3JrIGZhY3RvciAocG93ZXIgb2YgMiBlLmcuIDIqKjE4KVxuICogLSBgcmAgaXMgYmxvY2sgc2l6ZSAoOCBpcyBjb21tb24pLCBmaW5lLXR1bmVzIHNlcXVlbnRpYWwgbWVtb3J5IHJlYWQgc2l6ZSBhbmQgcGVyZm9ybWFuY2VcbiAqIC0gYHBgIGlzIHBhcmFsbGVsaXphdGlvbiBmYWN0b3IgKDEgaXMgY29tbW9uKVxuICogLSBgZGtMZW5gIGlzIG91dHB1dCBrZXkgbGVuZ3RoIGluIGJ5dGVzIGUuZy4gMzIuXG4gKiAtIGBhc3luY1RpY2tgIC0gKGRlZmF1bHQ6IDEwKSBtYXggdGltZSBpbiBtcyBmb3Igd2hpY2ggYXN5bmMgZnVuY3Rpb24gY2FuIGJsb2NrIGV4ZWN1dGlvblxuICogLSBgbWF4bWVtYCAtIChkZWZhdWx0OiBgMTAyNCAqKiAzICsgMTAyNGAgYWthIDFHQisxS0IpLiBBIGxpbWl0IHRoYXQgdGhlIGFwcCBjb3VsZCB1c2UgZm9yIHNjcnlwdFxuICogLSBgb25Qcm9ncmVzc2AgLSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIGV4ZWN1dGVkIGZvciBwcm9ncmVzcyByZXBvcnRcbiAqIEByZXR1cm5zIERlcml2ZWQga2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3J5cHQocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IFBpID0gYmxvY2tTaXplMzIgKiBwaTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IE4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfVxuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKylcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcnlwdEFzeW5jKHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiLCBhc3luY1RpY2sgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IFBpID0gYmxvY2tTaXplMzIgKiBwaTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKE4gLSAxLCBhc3luY1RpY2ssIChpKSA9PiB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOLCBhc3luY1RpY2ssIChpKSA9PiB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKylcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKTtcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJzaGEyNTYiLCJwYmtkZjIiLCJhc3luY0xvb3AiLCJjaGVja09wdHMiLCJ1MzIiLCJyb3RsIiwiYSIsImIiLCJYb3JBbmRTYWxzYSIsInByZXYiLCJwaSIsImlucHV0IiwiaWkiLCJvdXQiLCJvaSIsInkwMCIsInkwMSIsInkwMiIsInkwMyIsInkwNCIsInkwNSIsInkwNiIsInkwNyIsInkwOCIsInkwOSIsInkxMCIsInkxMSIsInkxMiIsInkxMyIsInkxNCIsInkxNSIsIngwMCIsIngwMSIsIngwMiIsIngwMyIsIngwNCIsIngwNSIsIngwNiIsIngwNyIsIngwOCIsIngwOSIsIngxMCIsIngxMSIsIngxMiIsIngxMyIsIngxNCIsIngxNSIsImkiLCJCbG9ja01peCIsInIiLCJoZWFkIiwidGFpbCIsInNjcnlwdEluaXQiLCJwYXNzd29yZCIsInNhbHQiLCJfb3B0cyIsIm9wdHMiLCJka0xlbiIsImFzeW5jVGljayIsIm1heG1lbSIsIk4iLCJwIiwib25Qcm9ncmVzcyIsIm51bWJlciIsInVuZGVmaW5lZCIsIkVycm9yIiwiYmxvY2tTaXplIiwiYmxvY2tTaXplMzIiLCJtZW1Vc2VkIiwiQiIsImMiLCJCMzIiLCJWIiwiVWludDhBcnJheSIsInRtcCIsImJsb2NrTWl4Q2IiLCJ0b3RhbEJsb2NrTWl4IiwiY2FsbGJhY2tQZXIiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJibG9ja01peENudCIsInNjcnlwdE91dHB1dCIsInJlcyIsImZpbGwiLCJzY3J5cHQiLCJQaSIsInBvcyIsImoiLCJrIiwic2NyeXB0QXN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/scrypt.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/sha256.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/sha256.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQsb0JBQW9CO0FBQ3BCLE1BQU1HLE1BQU0sQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNLENBQUNELElBQUlFO0FBQ3pDLG9EQUFvRDtBQUNwRCxNQUFNQyxNQUFNLENBQUNILEdBQUdDLEdBQUdDLElBQU0sSUFBS0QsSUFBTUQsSUFBSUUsSUFBTUQsSUFBSUM7QUFDbEQsbUJBQW1CO0FBQ25CLHlGQUF5RjtBQUN6RixrQkFBa0I7QUFDbEIsTUFBTUUsV0FBVyxJQUFJQyxZQUFZO0lBQzdCO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELHlHQUF5RztBQUN6RyxrQkFBa0I7QUFDbEIsTUFBTUMsS0FBSyxJQUFJRCxZQUFZO0lBQ3ZCO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCw0REFBNEQ7QUFDNUQsbURBQW1EO0FBQ25ELE1BQU1FLFdBQVcsSUFBSUYsWUFBWTtBQUNqQyxNQUFNRyxlQUFlWiwwQ0FBSUE7SUFDckJhLGFBQWM7UUFDVixLQUFLLENBQUMsSUFBSSxJQUFJLEdBQUc7UUFDakIsbUVBQW1FO1FB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U0FBU3ZDLDBEQUFlQSxDQUFDLElBQU0sSUFBSVUsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzPzBkMzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuIl0sIm5hbWVzIjpbIlNIQTIiLCJyb3RyIiwid3JhcENvbnN0cnVjdG9yIiwiQ2hpIiwiYSIsImIiLCJjIiwiTWFqIiwiU0hBMjU2X0siLCJVaW50MzJBcnJheSIsIklWIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJjb25zdHJ1Y3RvciIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsInNoYTI1NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/sha3.js":
/*!****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/sha3.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_u64.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlBH(h, l, s) : _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlSH(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlBL(h, l, s) : _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this, false);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = gen(0x06, 136, 256 / 8);\nconst sha3_384 = gen(0x06, 104, 384 / 8);\nconst sha3_512 = gen(0x06, 72, 512 / 8);\nconst keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = gen(0x01, 136, 256 / 8);\nconst keccak_384 = gen(0x01, 104, 384 / 8);\nconst keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = genShake(0x1f, 168, 128 / 8);\nconst shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ047QUFDK0Q7QUFDM0YsMkNBQTJDO0FBQzNDLE1BQU0sQ0FBQ08sU0FBU0MsV0FBV0MsV0FBVyxHQUFHO0lBQUMsRUFBRTtJQUFFLEVBQUU7SUFBRSxFQUFFO0NBQUM7QUFDckQsTUFBTUMsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLFNBQVNMLE9BQU87QUFDdEIsSUFBSyxJQUFJTSxRQUFRLEdBQUdDLElBQUlOLEtBQUtPLElBQUksR0FBR0MsSUFBSSxHQUFHSCxRQUFRLElBQUlBLFFBQVM7SUFDNUQsS0FBSztJQUNMLENBQUNFLEdBQUdDLEVBQUUsR0FBRztRQUFDQTtRQUFJLEtBQUlELElBQUksSUFBSUMsQ0FBQUEsSUFBSztLQUFFO0lBQ2pDYixRQUFRYyxJQUFJLENBQUMsSUFBSyxLQUFJRCxJQUFJRCxDQUFBQTtJQUMxQixhQUFhO0lBQ2JYLFVBQVVhLElBQUksQ0FBQyxDQUFHSixRQUFRLEtBQU1BLENBQUFBLFFBQVEsS0FBTSxJQUFLO0lBQ25ELE9BQU87SUFDUCxJQUFJSyxJQUFJWjtJQUNSLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJMLElBQUksQ0FBQyxLQUFNTixNQUFRLENBQUNNLEtBQUtKLEdBQUUsSUFBS0UsTUFBTSxJQUFLRDtRQUMzQyxJQUFJRyxJQUFJTCxLQUNKUyxLQUFLVixPQUFRLENBQUNBLE9BQU9ELE9BQU9ZLEVBQUMsSUFBS1g7SUFDMUM7SUFDQUgsV0FBV1ksSUFBSSxDQUFDQztBQUNwQjtBQUNBLE1BQU0sQ0FBQ0UsYUFBYUMsWUFBWSxHQUFHeEIscURBQVMsQ0FBQ1Es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TVEsYUFBYVIsSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHO0FBQ2pELE1BQU1TLFdBQVcsQ0FBQzlDLFFBQVFELFVBQVVFLFlBQWNqRCxrRUFBdUJBLENBQUMsQ0FBQytGLE9BQU8sQ0FBQyxDQUFDLEdBQUssSUFBSWxELE9BQU9FLFVBQVVDLFFBQVErQyxLQUFLQyxLQUFLLEtBQUtDLFlBQVloRCxZQUFZOEMsS0FBS0MsS0FBSyxFQUFFO0FBQ2xLLE1BQU1FLFdBQVdKLFNBQVMsTUFBTSxLQUFLLE1BQU0sR0FBRztBQUM5QyxNQUFNSyxXQUFXTCxTQUFTLE1BQU0sS0FBSyxNQUFNLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanM/MzU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSB1NjQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IHU2NC5yb3RsQkgoaCwgbCwgcykgOiB1NjQucm90bFNIKGgsIGwsIHMpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gdTY0LnJvdGxCTChoLCBsLCBzKSA6IHU2NC5yb3RsU0woaCwgbCwgcyk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhc3NlcnQubnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0LmJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBhc3NlcnQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwidTY0IiwiSGFzaCIsInUzMiIsInRvQnl0ZXMiLCJ3cmFwQ29uc3RydWN0b3IiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJzcGxpdCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEJIIiwicm90bFNIIiwicm90bEwiLCJyb3RsQkwiLCJyb3RsU0wiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImZpbGwiLCJLZWNjYWsiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJudW1iZXIiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwiZXhpc3RzIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnl0ZXMiLCJidWZmZXJPdXQiLCJzZXQiLCJzdWJhcnJheSIsInhvZkludG8iLCJ4b2YiLCJkaWdlc3RJbnRvIiwib3V0cHV0IiwiZGVzdHJveSIsImRpZ2VzdCIsIl9jbG9uZUludG8iLCJ0byIsImdlbiIsInNoYTNfMjI0Iiwic2hhM18yNTYiLCJzaGEzXzM4NCIsInNoYTNfNTEyIiwia2VjY2FrXzIyNCIsImtlY2Nha18yNTYiLCJrZWNjYWtfMzg0Iiwia2VjY2FrXzUxMiIsImdlblNoYWtlIiwib3B0cyIsImRrTGVuIiwidW5kZWZpbmVkIiwic2hha2UxMjgiLCJzaGFrZTI1NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/hashes/esm/utils.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(rsc)/../../node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\n\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */ function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n    let hex = \"\";\n    for(let i = 0; i < uint8a.length; i++){\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToBytes: expected string, got \" + typeof hex);\n    }\n    if (hex.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n    const array = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nfunction utf8ToBytes(str) {\n    if (typeof str !== \"string\") {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nfunction toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */ function concatBytes(...arrays) {\n    if (!arrays.every((a)=>a instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new TypeError(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashConstructor) {\n    const hashC = (message)=>hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashConstructor();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web) {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node) {\n        return new Uint8Array(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node.randomBytes(bytesLength).buffer);\n    } else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSw2REFBNkQ7QUFDN0Qsd0RBQXdEO0FBQ1Y7QUFDOUMsK0JBQStCO0FBQ3hCLE1BQU1DLEtBQUssQ0FBQ0MsTUFBUSxJQUFJQyxXQUFXRCxJQUFJRSxNQUFNLEVBQUVGLElBQUlHLFVBQVUsRUFBRUgsSUFBSUksVUFBVSxFQUFFO0FBQy9FLE1BQU1DLE1BQU0sQ0FBQ0wsTUFBUSxJQUFJTSxZQUFZTixJQUFJRSxNQUFNLEVBQUVGLElBQUlHLFVBQVUsRUFBRUksS0FBS0MsS0FBSyxDQUFDUixJQUFJSSxVQUFVLEdBQUcsSUFBSTtBQUN4RyxxQkFBcUI7QUFDZCxNQUFNSyxhQUFhLENBQUNULE1BQVEsSUFBSVUsU0FBU1YsSUFBSUUsTUFBTSxFQUFFRixJQUFJRyxVQUFVLEVBQUVILElBQUlJLFVBQVUsRUFBRTtBQUM1RiwrREFBK0Q7QUFDeEQsTUFBTU8sT0FBTyxDQUFDQyxNQUFNQyxRQUFVLFFBQVUsS0FBS0EsUUFBV0QsU0FBU0MsTUFBTztBQUN4RSxNQUFNQyxPQUFPLElBQUliLFdBQVcsSUFBSUssWUFBWTtJQUFDO0NBQVcsRUFBRUosTUFBTSxDQUFDLENBQUMsRUFBRSxLQUFLLEtBQUs7QUFDckYsaUdBQWlHO0FBQ2pHLCtDQUErQztBQUMvQyxJQUFJLENBQUNZLE1BQ0QsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCLE1BQU1DLFFBQVFDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDL0U7O0NBRUMsR0FDTSxTQUFTQyxXQUFXQyxNQUFNO0lBQzdCLG9DQUFvQztJQUNwQyxJQUFJLENBQUVBLENBQUFBLGtCQUFrQnhCLFVBQVMsR0FDN0IsTUFBTSxJQUFJ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QUFDQyxlQUFlLENBQUMsSUFBSTFGLFdBQVd3RjtJQUNyRCxPQUNLLElBQUkzRix3REFBTUEsQ0FBQzhGLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUkzRixXQUFXSCx3REFBTUEsQ0FBQzhGLElBQUksQ0FBQ0osV0FBVyxDQUFDQyxhQUFhdkYsTUFBTTtJQUNyRSxPQUNLO1FBQ0QsTUFBTSxJQUFJYSxNQUFNO0lBQ3BCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzP2Y4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVGhlIGltcG9ydCBoZXJlIGlzIHZpYSB0aGUgcGFja2FnZSBuYW1lLiBUaGlzIGlzIHRvIGVuc3VyZVxuLy8gdGhhdCBleHBvcnRzIG1hcHBpbmcvcmVzb2x1dGlvbiBkb2VzIGZhbGwgaW50byBwbGFjZS5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGVyZSBpcyBhbG1vc3Qgbm8gYmlnIGVuZGlhbiBoYXJkd2FyZSwgYnV0IGpzIHR5cGVkIGFycmF5cyB1c2VzIHBsYXRmb3JtIHNwZWNpZmljIGVuZGlhbm5lc3MuXG4vLyBTbywganVzdCB0byBiZSBzdXJlIG5vdCB0byBjb3JydXB0IGFueXRoaW5nLlxuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoIWFycmF5cy5ldmVyeSgoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZCcpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGhhc2hDID0gKG1lc3NhZ2UpID0+IGhhc2hDb25zdHJ1Y3RvcigpLnVwZGF0ZSh0b0J5dGVzKG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5ub2RlLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKS5idWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiY3J5cHRvIiwidTgiLCJhcnIiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJ1MzIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsImNyZWF0ZVZpZXciLCJEYXRhVmlldyIsInJvdHIiLCJ3b3JkIiwic2hpZnQiLCJpc0xFIiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInYiLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJ1aW50OGEiLCJoZXgiLCJoZXhUb0J5dGVzIiwiVHlwZUVycm9yIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJuZXh0VGljayIsImFzeW5jTG9vcCIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJ0b0J5dGVzIiwiZGF0YSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwiZXZlcnkiLCJhIiwicmVkdWNlIiwicmVzdWx0IiwicGFkIiwic2V0IiwiSGFzaCIsImNsb25lIiwiX2Nsb25lSW50byIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJjYWxsIiwiY29uc3RydWN0b3IiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJtZXJnZWQiLCJhc3NpZ24iLCJ3cmFwQ29uc3RydWN0b3IiLCJoYXNoQ29uc3RydWN0b3IiLCJoYXNoQyIsIm1lc3NhZ2UiLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImNyZWF0ZSIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwiaGFzaENvbnMiLCJtc2ciLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwid2ViIiwiZ2V0UmFuZG9tVmFsdWVzIiwibm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@noble/secp256k1/lib/esm/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@noble/secp256k1/lib/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signSync: () => (/* binding */ signSync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ \nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: _1n,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\")\n});\nconst divNearest = (a, b)=>(a + b / _2n) / b;\nconst endo = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar (k) {\n        const { n } = CURVE;\n        const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n        const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n        const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n        const b2 = a1;\n        const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\");\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error(\"splitScalarEndo: Endomorphism failed, k=\" + k);\n        }\n        return {\n            k1neg,\n            k1,\n            k2neg,\n            k2\n        };\n    }\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\n\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message){\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError(\"JacobianPoint expected\");\n}\nclass JacobianPoint {\n    constructor(x, y, z){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError(\"JacobianPoint#fromAffine: expected Point\");\n        }\n        if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p)=>p.z));\n        return points.map((p, i)=>p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n) return this;\n        if (X1 === _0n || Y1 === _0n) return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            } else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === \"bigint\" && scalar === _0n) return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n) return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while(k1 > _0n || k2 > _0n){\n            if (k1 & _1n) k1p = k1p.add(d);\n            if (k2 & _1n) k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg) k1p = k1p.negate();\n        if (k2neg) k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            for(let i = 1; i < 2 ** (W - 1); i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n        if (256 % W) {\n            throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for(let window = 0; window < windows; window++){\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            } else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return {\n            p,\n            f\n        };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        } else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([\n            point,\n            fake\n        ])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null) invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0) return Point.ZERO;\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd) y = mod(-y);\n        } else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd) y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen) return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![\n            0,\n            1,\n            2,\n            3\n        ].includes(recovery)) throw new Error(\"Cannot recover: invalid recovery bit\");\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? \"03\" : \"02\";\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q) throw new Error(\"Cannot recover signature: point at infinify\");\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? \"02\" : \"03\";\n            return `${prefix}${x}`;\n        } else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = \"Point is not on elliptic curve\";\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? \"00\" + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error(\"Invalid signature integer: trailing length\");\n    }\n    return {\n        data: bytesToNumber(res),\n        left: data.subarray(len + 2)\n    };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error(\"Invalid signature: incorrect length\");\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return {\n        r,\n        s\n    };\n}\nclass Signature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = \"Signature.fromCompact\";\n        if (typeof hex !== \"string\" && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== \"string\" && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r)) throw new Error(\"Invalid Signature: r must be 0 < r < n\");\n        if (!isWithinCurveOrder(s)) throw new Error(\"Invalid Signature: s must be 0 < s < n\");\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b)=>b instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    let hex = \"\";\n    for(let i = 0; i < uint8a.length; i++){\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt(\"0x10000000000000000000000000000000000000000000000000000000000000000\");\nfunction numTo32bStr(num) {\n    if (typeof num !== \"bigint\") throw new Error(\"Expected bigint\");\n    if (!(_0n <= num && num < POW_2_256)) throw new Error(\"Expected number 0 <= n < 2^256\");\n    return num.toString(16).padStart(64, \"0\");\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32) throw new Error(\"Error: expected 32 bytes\");\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToNumber: expected string, got \" + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToBytes: expected string, got \" + typeof hex);\n    }\n    if (hex.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\" + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === \"number\" && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n    if (typeof num === \"bigint\" && isWithinCurveOrder(num)) return num;\n    throw new TypeError(\"Expected valid private scalar: 0 < scalar < curve.n\");\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = x * x * x % P;\n    const b3 = b2 * b2 * x % P;\n    const b6 = pow2(b3, _3n) * b3 % P;\n    const b9 = pow2(b6, _3n) * b3 % P;\n    const b11 = pow2(b9, _2n) * b2 % P;\n    const b22 = pow2(b11, _11n) * b11 % P;\n    const b44 = pow2(b22, _22n) * b22 % P;\n    const b88 = pow2(b44, _44n) * b44 % P;\n    const b176 = pow2(b88, _88n) * b88 % P;\n    const b220 = pow2(b176, _44n) * b44 % P;\n    const b223 = pow2(b220, _3n) * b3 % P;\n    const t1 = pow2(b223, _23n) * b22 % P;\n    const t2 = pow2(t1, _6n) * b2 % P;\n    const rt = pow2(t2, _2n);\n    const xc = rt * rt % P;\n    if (xc !== x) throw new Error(\"Cannot find square root\");\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (num === _0n) return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i)=>{\n        if (num === _0n) return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly) return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen){\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n        if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== \"function\") throw new ShaError(\"hmacSha256Sync needs to be set\");\n    }\n    incr() {\n        if (this.counter >= 1000) throw new Error(\"Tried 1,000 k values for sign(), all were invalid\");\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([\n            0x00\n        ]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0) return;\n        this.k = await this.hmac(this.v, Uint8Array.from([\n            0x01\n        ]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([\n            0x00\n        ]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0) return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([\n            0x01\n        ]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while(len < this.qByteLen){\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while(len < this.qByteLen){\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k)) return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n) return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n) return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return {\n        sig,\n        recovery\n    };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === \"bigint\") {\n        num = key;\n    } else if (typeof key === \"number\" && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    } else if (typeof key === \"string\") {\n        if (key.length !== 2 * groupLen) throw new Error(\"Expected 32 bytes of private key\");\n        num = hexToNumber(key);\n    } else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen) throw new Error(\"Expected 32 bytes of private key\");\n        num = bytesToNumber(key);\n    } else {\n        throw new TypeError(\"Expected valid private key\");\n    }\n    if (!isWithinCurveOrder(num)) throw new Error(\"Expected private key: 0 < key < n\");\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    } else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    } catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === \"string\";\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point) return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA)) throw new TypeError(\"getSharedSecret: first arg must be private key\");\n    if (!isProbPub(publicB)) throw new TypeError(\"getSharedSecret: second arg must be public key\");\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [\n        int2octets(d),\n        bits2octets(h1)\n    ];\n    if (extraEntropy != null) {\n        if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return {\n        seed,\n        m,\n        d\n    };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({\n        canonical: true,\n        der: true\n    }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [\n        hashed,\n        recovery\n    ] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while(!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while(!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\n\nconst vopts = {\n    strict: true\n};\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    } catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS()) return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    } catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R) return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error(\"Invalid signature\");\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()){\n        if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32) throw new TypeError(\"sign: Expected 32 bytes of aux randomness\");\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return {\n            point,\n            scalar,\n            x: point.toRawX()\n        };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n) throw new Error(\"sign: Creation of signature failed. k is zero\");\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return {\n            R,\n            rx,\n            k\n        };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error(\"sign: Invalid signature produced\");\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!await schnorrVerify(sig, m, px)) this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px)) this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw) sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey)\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r) return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n        if (error instanceof ShaError) throw error;\n        return false;\n    }\n}\nconst schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined\n};\nconst TAGS = {\n    challenge: \"BIP0340/challenge\",\n    aux: \"BIP0340/aux\",\n    nonce: \"BIP0340/nonce\"\n};\nconst TAGGED_HASH_PREFIXES = {};\nconst utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey (privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash)=>{\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32)=>{\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        } else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        } else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: ()=>utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute (windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages)=>{\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest(\"SHA-256\", concatBytes(...messages));\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash(\"sha256\");\n            messages.forEach((m)=>hash.update(m));\n            return Uint8Array.from(hash.digest());\n        } else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages)=>{\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey(\"raw\", key, {\n                name: \"HMAC\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            }, false, [\n                \"sign\"\n            ]);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign(\"HMAC\", ckey, message);\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac(\"sha256\", key);\n            messages.forEach((m)=>hash.update(m));\n            return Uint8Array.from(hash.digest());\n        } else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages)=>{\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages)=>{\n        if (typeof _sha256Sync !== \"function\") throw new ShaError(\"sha256Sync is undefined, you need to set it\");\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get () {\n            return _sha256Sync;\n        },\n        set (val) {\n            if (!_sha256Sync) _sha256Sync = val;\n        }\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get () {\n            return _hmacSha256Sync;\n        },\n        set (val) {\n            if (!_hmacSha256Sync) _hmacSha256Sync = val;\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9zZWNwMjU2azEvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUVBQXVFLEdBQ2xDO0FBQ3JDLE1BQU1DLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksTUFBTUosT0FBTztBQUNuQixNQUFNSyxRQUFRQyxPQUFPQyxNQUFNLENBQUM7SUFDeEJDLEdBQUdUO0lBQ0hVLEdBQUdULE9BQU87SUFDVlUsR0FBR1YsT0FBTztJQUNWVyxHQUFHWCxPQUFPO0lBQ1ZZLEdBQUdYO0lBQ0hZLElBQUliLE9BQU87SUFDWGMsSUFBSWQsT0FBTztJQUNYZSxNQUFNZixPQUFPO0FBQ2pCO0FBQ0EsTUFBTWdCLGFBQWEsQ0FBQ1IsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJUCxHQUFFLElBQUtPO0FBQzdDLE1BQU1RLE9BQU87SUFDVEYsTUFBTWYsT0FBTztJQUNia0IsYUFBWUMsQ0FBQztRQUNULE1BQU0sRUFBRVIsQ0FBQyxFQUFFLEdBQUdOO1FBQ2QsTUFBTWUsS0FBS3BCLE9BQU87UUFDbEIsTUFBTXFCLEtBQUssQ0FBQ3BCLE1BQU1ELE9BQU87UUFDekIsTUFBTXNCLEtBQUt0QixPQUFPO1FBQ2xCLE1BQU11QixLQUFLSDtRQUNYLE1BQU1JLFlBQVl4QixPQUFPO1FBQ3pCLE1BQU15QixLQUFLVCxXQUFXTyxLQUFLSixHQUFHUjtRQUM5QixNQUFNZSxLQUFLVixXQUFXLENBQUNLLEtBQUtGLEdBQUdSO1FBQy9CLElBQUlnQixLQUFLQyxJQUFJVCxJQUFJTSxLQUFLTCxLQUFLTSxLQUFLSixJQUFJWDtRQUNwQyxJQUFJa0IsS0FBS0QsSUFBSSxDQUFDSCxLQUFLSixLQUFLSyxLQUFLSCxJQUFJWjtRQUNqQyxNQUFNbUIsUUFBUUgsS0FBS0g7UUFDbkIs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bGVzL0Bub2JsZS9zZWNwMjU2azEvbGliL2VzbS9pbmRleC5qcz8wMTg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1zZWNwMjU2azEgLSBNSVQgTGljZW5zZSAoYykgMjAxOSBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCAqIGFzIG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmNvbnN0IF84biA9IEJpZ0ludCg4KTtcbmNvbnN0IENVUlZFID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYTogXzBuLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBQOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gICAgaDogXzFuLFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxufSk7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuY29uc3QgZW5kbyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIHNwbGl0U2NhbGFyKGspIHtcbiAgICAgICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgIH0sXG59O1xuY29uc3QgZmllbGRMZW4gPSAzMjtcbmNvbnN0IGdyb3VwTGVuID0gMzI7XG5jb25zdCBoYXNoTGVuID0gMzI7XG5jb25zdCBjb21wcmVzc2VkTGVuID0gZmllbGRMZW4gKyAxO1xuY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIGZpZWxkTGVuICsgMTtcbmV4cG9ydCB7IENVUlZFIH07XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyh4KSB7XG4gICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICBjb25zdCB4MiA9IG1vZCh4ICogeCk7XG4gICAgY29uc3QgeDMgPSBtb2QoeDIgKiB4KTtcbiAgICByZXR1cm4gbW9kKHgzICsgYSAqIHggKyBiKTtcbn1cbmNvbnN0IFVTRV9FTkRPTU9SUEhJU00gPSBDVVJWRS5hID09PSBfMG47XG5jbGFzcyBTaGFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEphY1BvaW50KG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBKYWNvYmlhblBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCBleHBlY3RlZCcpO1xufVxuY2xhc3MgSmFjb2JpYW5Qb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgeikge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0phY29iaWFuUG9pbnQjZnJvbUFmZmluZTogZXhwZWN0ZWQgUG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5lcXVhbHMoUG9pbnQuWkVSTykpXG4gICAgICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQocC54LCBwLnksIF8xbik7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FmZmluZUJhdGNoKHBvaW50cykge1xuICAgICAgICBjb25zdCB0b0ludiA9IGludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAueikpO1xuICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpO1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQudG9BZmZpbmVCYXRjaChwb2ludHMpLm1hcChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0SmFjUG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgcmV0dXJuIFUxID09PSBVMiAmJiBTMSA9PT0gUzI7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpLCB0aGlzLnopO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgQSA9IG1vZChYMSAqIFgxKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IG1vZChCICogQik7XG4gICAgICAgIGNvbnN0IHgxYiA9IFgxICsgQjtcbiAgICAgICAgY29uc3QgRCA9IG1vZChfMm4gKiAobW9kKHgxYiAqIHgxYikgLSBBIC0gQykpO1xuICAgICAgICBjb25zdCBFID0gbW9kKF8zbiAqIEEpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEUgKiBFKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QoRiAtIF8ybiAqIEQpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChFICogKEQgLSBYMykgLSBfOG4gKiBDKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoXzJuICogWTEgKiBaMSk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydEphY1BvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHg6IFgyLCB5OiBZMiwgejogWjIgfSA9IG90aGVyO1xuICAgICAgICBpZiAoWDIgPT09IF8wbiB8fCBZMiA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChYMSA9PT0gXzBuIHx8IFkxID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgSCA9IG1vZChVMiAtIFUxKTtcbiAgICAgICAgY29uc3QgciA9IG1vZChTMiAtIFMxKTtcbiAgICAgICAgaWYgKEggPT09IF8wbikge1xuICAgICAgICAgICAgaWYgKHIgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBISCA9IG1vZChIICogSCk7XG4gICAgICAgIGNvbnN0IEhISCA9IG1vZChIICogSEgpO1xuICAgICAgICBjb25zdCBWID0gbW9kKFUxICogSEgpO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChyICogciAtIEhISCAtIF8ybiAqIFYpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChyICogKFYgLSBYMykgLSBTMSAqIEhISCk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKFoxICogWjIgKiBIKTtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgUDAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGFyID09PSAnYmlnaW50JyAmJiBzY2FsYXIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBQMDtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIVVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGxldCBwID0gUDA7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgIGxldCBrMXAgPSBQMDtcbiAgICAgICAgbGV0IGsycCA9IFAwO1xuICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIGVuZG8uYmV0YSksIGsycC55LCBrMnAueik7XG4gICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgfVxuICAgIHByZWNvbXB1dGVXaW5kb3coVykge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gVVNFX0VORE9NT1JQSElTTSA/IDEyOCAvIFcgKyAxIDogMjU2IC8gVyArIDE7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDIgKiogKFcgLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgd05BRihuLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBpZiAoIWFmZmluZVBvaW50ICYmIHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuQkFTRSkpXG4gICAgICAgICAgICBhZmZpbmVQb2ludCA9IFBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFcgPSAoYWZmaW5lUG9pbnQgJiYgYWZmaW5lUG9pbnQuX1dJTkRPV19TSVpFKSB8fCAxO1xuICAgICAgICBpZiAoMjU2ICUgVykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCN3TkFGOiBJbnZhbGlkIHByZWNvbXB1dGF0aW9uIHdpbmRvdywgbXVzdCBiZSBwb3dlciBvZiAyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNvbXB1dGVzID0gYWZmaW5lUG9pbnQgJiYgcG9pbnRQcmVjb21wdXRlcy5nZXQoYWZmaW5lUG9pbnQpO1xuICAgICAgICBpZiAoIXByZWNvbXB1dGVzKSB7XG4gICAgICAgICAgICBwcmVjb21wdXRlcyA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhXKTtcbiAgICAgICAgICAgIGlmIChhZmZpbmVQb2ludCAmJiBXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSBKYWNvYmlhblBvaW50Lm5vcm1hbGl6ZVoocHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KGFmZmluZVBvaW50LCBwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGxldCBmID0gSmFjb2JpYW5Qb2ludC5CQVNFO1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gMSArIChVU0VfRU5ET01PUlBISVNNID8gMTI4IC8gVyA6IDI1NiAvIFcpO1xuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxO1xuICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhciwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICBsZXQgZmFrZTtcbiAgICAgICAgaWYgKFVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBrMXAgPSBjb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICBrMnAgPSBjb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBlbmRvLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52Wikge1xuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTyk7XG4gICAgICAgIGlmIChpbnZaID09IG51bGwpXG4gICAgICAgICAgICBpbnZaID0gaXMwID8gXzhuIDogaW52ZXJ0KHopO1xuICAgICAgICBjb25zdCBpejEgPSBpbnZaO1xuICAgICAgICBjb25zdCBpejIgPSBtb2QoaXoxICogaXoxKTtcbiAgICAgICAgY29uc3QgaXozID0gbW9kKGl6MiAqIGl6MSk7XG4gICAgICAgIGNvbnN0IGF4ID0gbW9kKHggKiBpejIpO1xuICAgICAgICBjb25zdCBheSA9IG1vZCh5ICogaXozKTtcbiAgICAgICAgY29uc3QgenogPSBtb2QoeiAqIGl6MSk7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChheCwgYXkpO1xuICAgIH1cbn1cbkphY29iaWFuUG9pbnQuQkFTRSA9IG5ldyBKYWNvYmlhblBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuKTtcbkphY29iaWFuUG9pbnQuWkVSTyA9IG5ldyBKYWNvYmlhblBvaW50KF8wbiwgXzFuLCBfMG4pO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICUgXzJuID09PSBfMG47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcHJlc3NlZEhleChieXRlcykge1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gYnl0ZXMubGVuZ3RoID09PSAzMjtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoaXNTaG9ydCA/IGJ5dGVzIDogYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzKHgpO1xuICAgICAgICBsZXQgeSA9IHNxcnRNb2QoeTIpO1xuICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgaWYgKGlzU2hvcnQpIHtcbiAgICAgICAgICAgIGlmIChpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0Qnl0ZU9kZCA9IChieXRlc1swXSAmIDEpID09PSAxO1xuICAgICAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VbmNvbXByZXNzZWRIZXgoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMuc3ViYXJyYXkoMSwgZmllbGRMZW4gKyAxKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KGZpZWxkTGVuICsgMSwgZmllbGRMZW4gKiAyICsgMSkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGJ5dGVzWzBdO1xuICAgICAgICBpZiAobGVuID09PSBmaWVsZExlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZGVyID09PSAweDAyIHx8IGhlYWRlciA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZGVyID09PSAweDA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuY29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQuZnJvbUhleDogcmVjZWl2ZWQgaW52YWxpZCBwb2ludC4gRXhwZWN0ZWQgMzItJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXMsIG5vdCAke2xlbn1gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjb3ZlcnkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlcjogaW52YWxpZCByZWNvdmVyeSBiaXQnKTtcbiAgICAgICAgY29uc3QgaCA9IHRydW5jYXRlSGFzaChlbnN1cmVCeXRlcyhtc2dIYXNoKSk7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHJhZGogPSByZWNvdmVyeSA9PT0gMiB8fCByZWNvdmVyeSA9PT0gMyA/IHIgKyBuIDogcjtcbiAgICAgICAgY29uc3QgcmludiA9IGludmVydChyYWRqLCBuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoLWggKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgdTIgPSBtb2QocyAqIHJpbnYsIG4pO1xuICAgICAgICBjb25zdCBwcmVmaXggPSByZWNvdmVyeSAmIDEgPyAnMDMnIDogJzAyJztcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG8zMmJTdHIocmFkaikpO1xuICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpO1xuICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWNvdmVyIHNpZ25hdHVyZTogcG9pbnQgYXQgaW5maW5pZnknKTtcbiAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvSGV4KGlzQ29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICB0b0hleChpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB4ID0gbnVtVG8zMmJTdHIodGhpcy54KTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNFdmVuWSgpID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7eH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAwNCR7eH0ke251bVRvMzJiU3RyKHRoaXMueSl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0hleFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KHRydWUpLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0b1Jhd1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCBtc2cgPSAnUG9pbnQgaXMgbm90IG9uIGVsbGlwdGljIGN1cnZlJztcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkgfHwgIWlzVmFsaWRGaWVsZEVsZW1lbnQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IG1vZCh5ICogeSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3MoeCk7XG4gICAgICAgIGlmIChtb2QobGVmdCAtIHJpZ2h0KSAhPT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmRvdWJsZSgpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmFkZChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUob3RoZXIpKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5tdWx0aXBseShzY2FsYXIsIHRoaXMpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgUCA9IEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKTtcbiAgICAgICAgY29uc3QgYVAgPSBhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8IHRoaXMgIT09IFBvaW50LkJBU0UgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKTtcbiAgICAgICAgY29uc3QgYlEgPSBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUoUSkubXVsdGlwbHlVbnNhZmUoYik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGFQLmFkZChiUSk7XG4gICAgICAgIHJldHVybiBzdW0uZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTykgPyB1bmRlZmluZWQgOiBzdW0udG9BZmZpbmUoKTtcbiAgICB9XG59XG5Qb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSk7XG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzBuKTtcbmZ1bmN0aW9uIHNsaWNlREVSKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSA+PSA4ID8gJzAwJyArIHMgOiBzO1xufVxuZnVuY3Rpb24gcGFyc2VERVJJbnQoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnOiAke2J5dGVzVG9IZXgoZGF0YSl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGhgKTtcbiAgICB9XG4gICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiByZXNbMV0gPD0gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHRyYWlsaW5nIGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBieXRlc1RvTnVtYmVyKHJlcyksIGxlZnQ6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlREVSU2lnbmF0dXJlKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT0gMHgzMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIHRhZzogJHtieXRlc1RvSGV4KGRhdGEpfWApO1xuICAgIH1cbiAgICBpZiAoZGF0YVsxXSAhPT0gZGF0YS5sZW5ndGggLSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhOiByLCBsZWZ0OiBzQnl0ZXMgfSA9IHBhcnNlREVSSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgIGNvbnN0IHsgZGF0YTogcywgbGVmdDogckJ5dGVzTGVmdCB9ID0gcGFyc2VERVJJbnQoc0J5dGVzKTtcbiAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nOiAke2J5dGVzVG9IZXgockJ5dGVzTGVmdCl9YCk7XG4gICAgfVxuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKHIsIHMpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAnU2lnbmF0dXJlLmZyb21Db21wYWN0JztcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnICYmICFhcnIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke25hbWV9OiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCBzdHIgPSBhcnIgPyBieXRlc1RvSGV4KGhleCkgOiBoZXg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxMjgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IEV4cGVjdGVkIDY0LWJ5dGUgaGV4YCk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGhleFRvTnVtYmVyKHN0ci5zbGljZSgwLCA2NCkpLCBoZXhUb051bWJlcihzdHIuc2xpY2UoNjQsIDEyOCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2lnbmF0dXJlLmZyb21ERVI6IEV4cGVjdGVkIHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gcGFyc2VERVJTaWduYXR1cmUoYXJyID8gaGV4IDogaGV4VG9CeXRlcyhoZXgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tREVSKGhleCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZTogciBtdXN0IGJlIDAgPCByIDwgbicpO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHMgbXVzdCBiZSAwIDwgcyA8IG4nKTtcbiAgICB9XG4gICAgaGFzSGlnaFMoKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRS5uID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIHRoaXMucyA+IEhBTEY7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kKC10aGlzLnMsIENVUlZFLm4pKSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgICBjb25zdCBzSGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnMpKTtcbiAgICAgICAgY29uc3QgckhleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5yKSk7XG4gICAgICAgIGNvbnN0IHNIZXhMID0gc0hleC5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBySGV4TCA9IHJIZXgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc0xlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoc0hleEwpO1xuICAgICAgICBjb25zdCByTGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChySGV4TCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleEwgKyBzSGV4TCArIDQpO1xuICAgICAgICByZXR1cm4gYDMwJHtsZW5ndGh9MDIke3JMZW59JHtySGV4fTAyJHtzTGVufSR7c0hleH1gO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUlJhd0J5dGVzKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUkhleCgpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiU3RyKHRoaXMucikgKyBudW1UbzMyYlN0cih0aGlzLnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChiKSA9PiBiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgaWYgKCEodWludDhhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmNvbnN0IFBPV18yXzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuZnVuY3Rpb24gbnVtVG8zMmJTdHIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJpZ2ludCcpO1xuICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgUE9XXzJfMjU2KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBudW1iZXIgMCA8PSBuIDwgMl4yNTYnKTtcbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbn1cbmZ1bmN0aW9uIG51bVRvMzJiKG51bSkge1xuICAgIGNvbnN0IGIgPSBoZXhUb0J5dGVzKG51bVRvMzJiU3RyKG51bSkpO1xuICAgIGlmIChiLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IGV4cGVjdGVkIDMyIGJ5dGVzJyk7XG4gICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvTnVtYmVyOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYDB4JHtoZXh9YCk7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcgKyBoZXgubGVuZ3RoKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGhleCkge1xuICAgIHJldHVybiBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gVWludDhBcnJheS5mcm9tKGhleCkgOiBoZXhUb0J5dGVzKGhleCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY2FsYXIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID4gMClcbiAgICAgICAgcmV0dXJuIEJpZ0ludChudW0pO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB2YWxpZCBwcml2YXRlIHNjYWxhcjogMCA8IHNjYWxhciA8IGN1cnZlLm4nKTtcbn1cbmZ1bmN0aW9uIG1vZChhLCBiID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3FydE1vZCh4KSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBjb25zdCBfNm4gPSBCaWdJbnQoNik7XG4gICAgY29uc3QgXzExbiA9IEJpZ0ludCgxMSk7XG4gICAgY29uc3QgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyk7XG4gICAgY29uc3QgXzQ0biA9IEJpZ0ludCg0NCk7XG4gICAgY29uc3QgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeCAqIHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHgpICUgUDtcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybikgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4bikgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0bikgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82bikgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJ0ID0gcG93Mih0MiwgXzJuKTtcbiAgICBjb25zdCB4YyA9IChydCAqIHJ0KSAlIFA7XG4gICAgaWYgKHhjICE9PSB4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJ0O1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHNjcmF0Y2ggPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChudW0gPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHNjcmF0Y2hbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBfMW4pO1xuICAgIGNvbnN0IGludmVydGVkID0gaW52ZXJ0KGxhc3RNdWx0aXBsaWVkLCBwKTtcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gbW9kKGFjYyAqIHNjcmF0Y2hbaV0sIHApO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiBzY3JhdGNoO1xufVxuZnVuY3Rpb24gYml0czJpbnRfMihieXRlcykge1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIGdyb3VwTGVuICogODtcbiAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiB0cnVuY2F0ZUhhc2goaGFzaCwgdHJ1bmNhdGVPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBoID0gYml0czJpbnRfMihoYXNoKTtcbiAgICBpZiAodHJ1bmNhdGVPbmx5KVxuICAgICAgICByZXR1cm4gaDtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIHJldHVybiBoID49IG4gPyBoIC0gbiA6IGg7XG59XG5sZXQgX3NoYTI1NlN5bmM7XG5sZXQgX2htYWNTaGEyNTZTeW5jO1xuY2xhc3MgSG1hY0RyYmcge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hMZW4sIHFCeXRlTGVuKSB7XG4gICAgICAgIHRoaXMuaGFzaExlbiA9IGhhc2hMZW47XG4gICAgICAgIHRoaXMucUJ5dGVMZW4gPSBxQnl0ZUxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDEpO1xuICAgICAgICB0aGlzLmsgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDApO1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIH1cbiAgICBobWFjKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gdXRpbHMuaG1hY1NoYTI1Nih0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGhtYWNTeW5jKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gX2htYWNTaGEyNTZTeW5jKHRoaXMuaywgLi4udmFsdWVzKTtcbiAgICB9XG4gICAgY2hlY2tTeW5jKCkge1xuICAgICAgICBpZiAodHlwZW9mIF9obWFjU2hhMjU2U3luYyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGFFcnJvcignaG1hY1NoYTI1NlN5bmMgbmVlZHMgdG8gYmUgc2V0Jyk7XG4gICAgfVxuICAgIGluY3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgMSwwMDAgayB2YWx1ZXMgZm9yIHNpZ24oKSwgYWxsIHdlcmUgaW52YWxpZCcpO1xuICAgICAgICB0aGlzLmNvdW50ZXIgKz0gMTtcbiAgICB9XG4gICAgYXN5bmMgcmVzZWVkKHNlZWQgPSBuZXcgVWludDhBcnJheSgpKSB7XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAxXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICB9XG4gICAgcmVzZWVkU3luYyhzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmhtYWNTeW5jKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAwXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbmNyKCk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHRoaXMucUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB0aGlzLnYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVN5bmMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCB0aGlzLnFCeXRlTGVuKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHRoaXMudi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHRoaXMudi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5QO1xufVxuZnVuY3Rpb24ga21kVG9TaWcoa0J5dGVzLCBtLCBkLCBsb3dTID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgayA9IHRydW5jYXRlSGFzaChrQnl0ZXMsIHRydWUpO1xuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qga2ludiA9IGludmVydChrLCBuKTtcbiAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKTtcbiAgICBjb25zdCByID0gbW9kKHEueCwgbik7XG4gICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBtb2Qoa2ludiAqIG1vZChtICsgZCAqIHIsIG4pLCBuKTtcbiAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gc2lnLnIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTtcbiAgICBpZiAobG93UyAmJiBzaWcuaGFzSGlnaFMoKSkge1xuICAgICAgICBzaWcgPSBzaWcubm9ybWFsaXplUygpO1xuICAgICAgICByZWNvdmVyeSBePSAxO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWcsIHJlY292ZXJ5IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcml2YXRlS2V5KGtleSkge1xuICAgIGxldCBudW07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIG51bSA9IGtleTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoa2V5KSAmJiBrZXkgPiAwKSB7XG4gICAgICAgIG51bSA9IEJpZ0ludChrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMiAqIGdyb3VwTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAzMiBieXRlcyBvZiBwcml2YXRlIGtleScpO1xuICAgICAgICBudW0gPSBoZXhUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSBncm91cExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gYnl0ZXNUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcml2YXRlIGtleTogMCA8IGtleSA8IG4nKTtcbiAgICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHVibGljS2V5KHB1YmxpY0tleSkge1xuICAgIGlmIChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICBwdWJsaWNLZXkuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgc2lnbmF0dXJlLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihzaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzaWduYXR1cmUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVNpZ25hdHVyZShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICBpZiAoc3RyKVxuICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuICogMiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbiAqIDI7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXRTaGFyZWRTZWNyZXQ6IHNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgY29uc3QgYiA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNCKTtcbiAgICBiLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBieXRlcy5sZW5ndGggPiBmaWVsZExlbiA/IGJ5dGVzLnNsaWNlKDAsIGZpZWxkTGVuKSA6IGJ5dGVzO1xuICAgIHJldHVybiBieXRlc1RvTnVtYmVyKHNsaWNlKTtcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzKGJ5dGVzKSB7XG4gICAgY29uc3QgejEgPSBiaXRzMmludChieXRlcyk7XG4gICAgY29uc3QgejIgPSBtb2QoejEsIENVUlZFLm4pO1xuICAgIHJldHVybiBpbnQyb2N0ZXRzKHoyIDwgXzBuID8gejEgOiB6Mik7XG59XG5mdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgIHJldHVybiBudW1UbzMyYihudW0pO1xufVxuZnVuY3Rpb24gaW5pdFNpZ0FyZ3MobXNnSGFzaCwgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5KSB7XG4gICAgaWYgKG1zZ0hhc2ggPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduOiBleHBlY3RlZCB2YWxpZCBtZXNzYWdlIGhhc2gsIG5vdCBcIiR7bXNnSGFzaH1cImApO1xuICAgIGNvbnN0IGgxID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgZCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgYml0czJvY3RldHMoaDEpXTtcbiAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dHJhRW50cm9weSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGV4dHJhRW50cm9weSA9IHV0aWxzLnJhbmRvbUJ5dGVzKGZpZWxkTGVuKTtcbiAgICAgICAgY29uc3QgZSA9IGVuc3VyZUJ5dGVzKGV4dHJhRW50cm9weSk7XG4gICAgICAgIGlmIChlLmxlbmd0aCAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ246IEV4cGVjdGVkICR7ZmllbGRMZW59IGJ5dGVzIG9mIGV4dHJhIGRhdGFgKTtcbiAgICAgICAgc2VlZEFyZ3MucHVzaChlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTtcbiAgICBjb25zdCBtID0gYml0czJpbnQoaDEpO1xuICAgIHJldHVybiB7IHNlZWQsIG0sIGQgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2lnKHJlY1NpZywgb3B0cykge1xuICAgIGNvbnN0IHsgc2lnLCByZWNvdmVyeSB9ID0gcmVjU2lnO1xuICAgIGNvbnN0IHsgZGVyLCByZWNvdmVyZWQgfSA9IE9iamVjdC5hc3NpZ24oeyBjYW5vbmljYWw6IHRydWUsIGRlcjogdHJ1ZSB9LCBvcHRzKTtcbiAgICBjb25zdCBoYXNoZWQgPSBkZXIgPyBzaWcudG9ERVJSYXdCeXRlcygpIDogc2lnLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgcmV0dXJuIHJlY292ZXJlZCA/IFtoYXNoZWQsIHJlY292ZXJ5XSA6IGhhc2hlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBzZWVkLCBtLCBkIH0gPSBpbml0U2lnQXJncyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzLmV4dHJhRW50cm9weSk7XG4gICAgY29uc3QgZHJiZyA9IG5ldyBIbWFjRHJiZyhoYXNoTGVuLCBncm91cExlbik7XG4gICAgYXdhaXQgZHJiZy5yZXNlZWQoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhhd2FpdCBkcmJnLmdlbmVyYXRlKCksIG0sIGQsIG9wdHMuY2Fub25pY2FsKSkpXG4gICAgICAgIGF3YWl0IGRyYmcucmVzZWVkKCk7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnKHNpZywgb3B0cyk7XG59XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKGhhc2hMZW4sIGdyb3VwTGVuKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhkcmJnLmdlbmVyYXRlU3luYygpLCBtLCBkLCBvcHRzLmNhbm9uaWNhbCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydCB7IHNpZ24sIHNpZ25TeW5jIH07XG5jb25zdCB2b3B0cyA9IHsgc3RyaWN0OiB0cnVlIH07XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gdm9wdHMpIHtcbiAgICBsZXQgc2lnO1xuICAgIHRyeSB7XG4gICAgICAgIHNpZyA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIGlmIChvcHRzLnN0cmljdCAmJiBzaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2gobXNnSGFzaCk7XG4gICAgbGV0IFA7XG4gICAgdHJ5IHtcbiAgICAgICAgUCA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IHNpbnYgPSBpbnZlcnQocywgbik7XG4gICAgY29uc3QgdTEgPSBtb2QoaCAqIHNpbnYsIG4pO1xuICAgIGNvbnN0IHUyID0gbW9kKHIgKiBzaW52LCBuKTtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpO1xuICAgIGlmICghUilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHYgPSBtb2QoUi54LCBuKTtcbiAgICByZXR1cm4gdiA9PT0gcjtcbn1cbmZ1bmN0aW9uIHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuY2xhc3MgU2Nobm9yclNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4OiBleHBlY3RlZCA2NCBieXRlcywgbm90ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQocikgfHwgIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleCgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdYKCk7XG59XG5jbGFzcyBJbnRlcm5hbFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSB1dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzaWduOiBFeHBlY3RlZCB2YWxpZCBtZXNzYWdlLCBub3QgXCIke21lc3NhZ2V9XCJgKTtcbiAgICAgICAgdGhpcy5tID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgeCwgc2NhbGFyIH0gPSB0aGlzLmdldFNjYWxhcihub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgdGhpcy5weCA9IHg7XG4gICAgICAgIHRoaXMuZCA9IHNjYWxhcjtcbiAgICAgICAgdGhpcy5yYW5kID0gZW5zdXJlQnl0ZXMoYXV4UmFuZCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmQubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpZ246IEV4cGVjdGVkIDMyIGJ5dGVzIG9mIGF1eCByYW5kb21uZXNzJyk7XG4gICAgfVxuICAgIGdldFNjYWxhcihwcml2KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdik7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHBvaW50Lmhhc0V2ZW5ZKCkgPyBwcml2IDogQ1VSVkUubiAtIHByaXY7XG4gICAgICAgIHJldHVybiB7IHBvaW50LCBzY2FsYXIsIHg6IHBvaW50LnRvUmF3WCgpIH07XG4gICAgfVxuICAgIGluaXROb25jZShkLCB0MGgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyKHQwaCkpO1xuICAgIH1cbiAgICBmaW5hbGl6ZU5vbmNlKGswaCkge1xuICAgICAgICBjb25zdCBrMCA9IG1vZChieXRlc1RvTnVtYmVyKGswaCksIENVUlZFLm4pO1xuICAgICAgICBpZiAoazAgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogQ3JlYXRpb24gb2Ygc2lnbmF0dXJlIGZhaWxlZC4gayBpcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IHsgcG9pbnQ6IFIsIHg6IHJ4LCBzY2FsYXI6IGsgfSA9IHRoaXMuZ2V0U2NhbGFyKGswKTtcbiAgICAgICAgcmV0dXJuIHsgUiwgcngsIGsgfTtcbiAgICB9XG4gICAgZmluYWxpemVTaWcoUiwgaywgZSwgZCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaG5vcnJTaWduYXR1cmUoUi54LCBtb2QoayArIGUgKiBkLCBDVVJWRS5uKSkudG9SYXdCeXRlcygpO1xuICAgIH1cbiAgICBlcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSB1dGlscy50YWdnZWRIYXNoO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgYXdhaXQgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZShhd2FpdCB0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIShhd2FpdCBzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgY2FsY1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHsgbSwgZCwgcHgsIHJhbmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IHV0aWxzLnRhZ2dlZEhhc2hTeW5jO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZSh0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZSh0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIXNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJTaWduKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsYygpO1xufVxuZnVuY3Rpb24gc2Nobm9yclNpZ25TeW5jKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsY1N5bmMoKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmF3ID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2Nobm9yclNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWcgPSByYXcgPyBzaWduYXR1cmUgOiBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICBpZiAocmF3KVxuICAgICAgICBzaWcuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zaWcsXG4gICAgICAgIG06IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpLFxuICAgICAgICBQOiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpIHtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCBub3JtYWxpemVQcml2YXRlS2V5KHMpLCBtb2QoLWUsIENVUlZFLm4pKTtcbiAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB1dGlscy50YWdnZWRIYXNoKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnlTeW5jKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByLCBzLCBtLCBQIH0gPSBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUodXRpbHMudGFnZ2VkSGFzaFN5bmMoVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTaGFFcnJvcilcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSB7XG4gICAgU2lnbmF0dXJlOiBTY2hub3JyU2lnbmF0dXJlLFxuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgc2lnblN5bmM6IHNjaG5vcnJTaWduU3luYyxcbiAgICB2ZXJpZnlTeW5jOiBzY2hub3JyVmVyaWZ5U3luYyxcbn07XG5Qb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IG5vZGVDcnlwdG8sXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IFRBR1MgPSB7XG4gICAgY2hhbGxlbmdlOiAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAgIGF1eDogJ0JJUDAzNDAvYXV4JyxcbiAgICBub25jZTogJ0JJUDAzNDAvbm9uY2UnLFxufTtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzLFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIG1vZCxcbiAgICBpbnZlcnQsXG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYmlnaW50VG8zMkJ5dGVzOiBudW1UbzMyYixcbiAgICBfbm9ybWFsaXplUHJpdmF0ZUtleTogbm9ybWFsaXplUHJpdmF0ZUtleSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbiA9IGdyb3VwTGVuICsgODtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoIDwgbWluTGVuIHx8IGhhc2gubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODZgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBtb2QoYnl0ZXNUb051bWJlcihoYXNoKSwgQ1VSVkUubiAtIF8xbikgKyBfMW47XG4gICAgICAgIHJldHVybiBudW1UbzMyYihudW0pO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aCA9IDMyKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21CeXRlcyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB1dGlscy5oYXNoVG9Qcml2YXRlS2V5KHV0aWxzLnJhbmRvbUJ5dGVzKGdyb3VwTGVuICsgOCkpLFxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBwb2ludCA9PT0gUG9pbnQuQkFTRSA/IHBvaW50IDogbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjYWNoZWQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgIGNhY2hlZC5tdWx0aXBseShfM24pO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0sXG4gICAgc2hhMjU2OiBhc3luYyAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by53ZWIuc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNvbmNhdEJ5dGVzKC4uLm1lc3NhZ2VzKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIYXNoIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHNoYTI1NiBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG1hY1NoYTI1NjogYXN5bmMgKGtleSwgLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNrZXkgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnSE1BQycsIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0gfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb25jYXRCeXRlcyguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5zaWduKCdITUFDJywgY2tleSwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIbWFjIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4gaGFzaC51cGRhdGUobSkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgaG1hYy1zaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICBobWFjU2hhMjU2U3luYzogdW5kZWZpbmVkLFxuICAgIHRhZ2dlZEhhc2g6IGFzeW5jICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IGF3YWl0IHV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2hhMjU2KHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIHRhZ2dlZEhhc2hTeW5jOiAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF9zaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoYUVycm9yKCdzaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IF9zaGEyNTZTeW5jKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2hhMjU2U3luYyh0YWdQLCAuLi5tZXNzYWdlcyk7XG4gICAgfSxcbiAgICBfSmFjb2JpYW5Qb2ludDogSmFjb2JpYW5Qb2ludCxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyh1dGlscywge1xuICAgIHNoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaGEyNTZTeW5jO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICBpZiAoIV9zaGEyNTZTeW5jKVxuICAgICAgICAgICAgICAgIF9zaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgaG1hY1NoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9obWFjU2hhMjU2U3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfaG1hY1NoYTI1NlN5bmMpXG4gICAgICAgICAgICAgICAgX2htYWNTaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG59KTtcbiJdLCJuYW1lcyI6WyJub2RlQ3J5cHRvIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzhuIiwiQ1VSVkUiLCJPYmplY3QiLCJmcmVlemUiLCJhIiwiYiIsIlAiLCJuIiwiaCIsIkd4IiwiR3kiLCJiZXRhIiwiZGl2TmVhcmVzdCIsImVuZG8iLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJiMiIsIlBPV18yXzEyOCIsImMxIiwiYzIiLCJrMSIsIm1vZCIsImsyIiwiazFuZWciLCJrMm5lZyIsIkVycm9yIiwiZmllbGRMZW4iLCJncm91cExlbiIsImhhc2hMZW4iLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwid2VpZXJzdHJhc3MiLCJ4IiwieDIiLCJ4MyIsIlVTRV9FTkRPTU9SUEhJU00iLCJTaGFFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImFzc2VydEphY1BvaW50Iiwib3RoZXIiLCJKYWNvYmlhblBvaW50IiwiVHlwZUVycm9yIiwieSIsInoiLCJmcm9tQWZmaW5lIiwicCIsIlBvaW50IiwiZXF1YWxzIiwiWkVSTyIsInRvQWZmaW5lQmF0Y2giLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiaSIsInRvQWZmaW5lIiwibm9ybWFsaXplWiIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIloxWjEiLCJaMloyIiwiVTEiLCJVMiIsIlMxIiwiUzIiLCJuZWdhdGUiLCJkb3VibGUiLCJBIiwiQiIsIkMiLCJ4MWIiLCJEIiwiRSIsIkYiLCJYMyIsIlkzIiwiWjMiLCJhZGQiLCJIIiwiciIsIkhIIiwiSEhIIiwiViIsInN1YnRyYWN0IiwibXVsdGlwbHlVbnNhZmUiLCJzY2FsYXIiLCJQMCIsIm5vcm1hbGl6ZVNjYWxhciIsImQiLCJrMXAiLCJrMnAiLCJwcmVjb21wdXRlV2luZG93IiwiVyIsIndpbmRvd3MiLCJiYXNlIiwid2luZG93IiwicHVzaCIsIndOQUYiLCJhZmZpbmVQb2ludCIsIkJBU0UiLCJfV0lORE9XX1NJWkUiLCJwcmVjb21wdXRlcyIsInBvaW50UHJlY29tcHV0ZXMiLCJnZXQiLCJzZXQiLCJmIiwid2luZG93U2l6ZSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsIk1hdGgiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHkiLCJwb2ludCIsImZha2UiLCJmMXAiLCJmMnAiLCJpbnZaIiwiaXMwIiwiaW52ZXJ0IiwiaXoxIiwiaXoyIiwiaXozIiwiYXgiLCJheSIsInp6IiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIldlYWtNYXAiLCJfc2V0V2luZG93U2l6ZSIsImRlbGV0ZSIsImhhc0V2ZW5ZIiwiZnJvbUNvbXByZXNzZWRIZXgiLCJieXRlcyIsImlzU2hvcnQiLCJsZW5ndGgiLCJieXRlc1RvTnVtYmVyIiwic3ViYXJyYXkiLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwieTIiLCJzcXJ0TW9kIiwiaXNZT2RkIiwiaXNGaXJzdEJ5dGVPZGQiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21VbmNvbXByZXNzZWRIZXgiLCJmcm9tSGV4IiwiaGV4IiwiZW5zdXJlQnl0ZXMiLCJsZW4iLCJoZWFkZXIiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJub3JtYWxpemVQcml2YXRlS2V5IiwiZnJvbVNpZ25hdHVyZSIsIm1zZ0hhc2giLCJzaWduYXR1cmUiLCJyZWNvdmVyeSIsInMiLCJub3JtYWxpemVTaWduYXR1cmUiLCJpbmNsdWRlcyIsInRydW5jYXRlSGFzaCIsInJhZGoiLCJyaW52IiwidTEiLCJ1MiIsInByZWZpeCIsIlIiLCJudW1UbzMyYlN0ciIsIlEiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJoZXhUb0J5dGVzIiwidG9IZXgiLCJ0b0hleFgiLCJzbGljZSIsInRvUmF3WCIsIm1zZyIsImxlZnQiLCJyaWdodCIsImFQIiwiYlEiLCJzdW0iLCJ1bmRlZmluZWQiLCJzbGljZURFUiIsInBhcnNlSW50IiwicGFyc2VERVJJbnQiLCJkYXRhIiwiYnl0ZXNUb0hleCIsInJlcyIsInBhcnNlREVSU2lnbmF0dXJlIiwic0J5dGVzIiwickJ5dGVzTGVmdCIsIlNpZ25hdHVyZSIsImZyb21Db21wYWN0IiwiYXJyIiwiVWludDhBcnJheSIsIm5hbWUiLCJzdHIiLCJoZXhUb051bWJlciIsImZyb21ERVIiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJoYXNIaWdoUyIsIkhBTEYiLCJub3JtYWxpemVTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4Iiwic0hleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJySGV4Iiwic0hleEwiLCJySGV4TCIsInNMZW4iLCJyTGVuIiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsImV2ZXJ5IiwicmVkdWNlIiwicmVzdWx0IiwicGFkIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJ2IiwidG9TdHJpbmciLCJwYWRTdGFydCIsInVpbnQ4YSIsIlBPV18yXzI1NiIsIm51bSIsIm51bVRvMzJiIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsImJ5dGUiLCJpc05hTiIsImlzU2FmZUludGVnZXIiLCJwb3cyIiwicG93ZXIiLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJydCIsInhjIiwibnVtYmVyIiwibW9kdWxvIiwidSIsInEiLCJtIiwiZ2NkIiwibnVtcyIsInNjcmF0Y2giLCJsYXN0TXVsdGlwbGllZCIsImFjYyIsImludmVydGVkIiwicmVkdWNlUmlnaHQiLCJiaXRzMmludF8yIiwiZGVsdGEiLCJoYXNoIiwidHJ1bmNhdGVPbmx5IiwiX3NoYTI1NlN5bmMiLCJfaG1hY1NoYTI1NlN5bmMiLCJIbWFjRHJiZyIsInFCeXRlTGVuIiwiZmlsbCIsImNvdW50ZXIiLCJobWFjIiwidmFsdWVzIiwidXRpbHMiLCJobWFjU2hhMjU2IiwiaG1hY1N5bmMiLCJjaGVja1N5bmMiLCJpbmNyIiwicmVzZWVkIiwic2VlZCIsInJlc2VlZFN5bmMiLCJnZW5lcmF0ZSIsIm91dCIsInNsIiwiZ2VuZXJhdGVTeW5jIiwia21kVG9TaWciLCJrQnl0ZXMiLCJsb3dTIiwia2ludiIsInNpZyIsImtleSIsIm5vcm1hbGl6ZVB1YmxpY0tleSIsInB1YmxpY0tleSIsImVycm9yIiwiZ2V0UHVibGljS2V5IiwicmVjb3ZlclB1YmxpY0tleSIsImlzUHJvYlB1YiIsImdldFNoYXJlZFNlY3JldCIsInByaXZhdGVBIiwicHVibGljQiIsImJpdHMyaW50IiwiYml0czJvY3RldHMiLCJ6MSIsInoyIiwiaW50Mm9jdGV0cyIsImluaXRTaWdBcmdzIiwiZXh0cmFFbnRyb3B5IiwiaDEiLCJzZWVkQXJncyIsInJhbmRvbUJ5dGVzIiwiZSIsImZpbmFsaXplU2lnIiwicmVjU2lnIiwib3B0cyIsImRlciIsInJlY292ZXJlZCIsImFzc2lnbiIsImNhbm9uaWNhbCIsImhhc2hlZCIsInNpZ24iLCJwcml2S2V5IiwiZHJiZyIsInNpZ25TeW5jIiwidm9wdHMiLCJzdHJpY3QiLCJ2ZXJpZnkiLCJzaW52Iiwic2Nobm9yckNoYWxsZW5nZUZpbmFsaXplIiwiY2giLCJTY2hub3JyU2lnbmF0dXJlIiwic2Nobm9yckdldFB1YmxpY0tleSIsIkludGVybmFsU2Nobm9yclNpZ25hdHVyZSIsImF1eFJhbmQiLCJnZXRTY2FsYXIiLCJweCIsInJhbmQiLCJwcml2IiwiaW5pdE5vbmNlIiwidDBoIiwiZmluYWxpemVOb25jZSIsImswaCIsImswIiwicngiLCJjYWxjIiwidGFnIiwidGFnZ2VkSGFzaCIsInQiLCJUQUdTIiwiYXV4Iiwibm9uY2UiLCJjaGFsbGVuZ2UiLCJzY2hub3JyVmVyaWZ5IiwiY2FsY1N5bmMiLCJ0YWdnZWRIYXNoU3luYyIsInNjaG5vcnJWZXJpZnlTeW5jIiwic2Nobm9yclNpZ24iLCJzY2hub3JyU2lnblN5bmMiLCJpbml0U2Nobm9yclZlcmlmeSIsInJhdyIsImZpbmFsaXplU2Nobm9yclZlcmlmeSIsInNjaG5vcnIiLCJ2ZXJpZnlTeW5jIiwiY3J5cHRvIiwibm9kZSIsIndlYiIsInNlbGYiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsImlzVmFsaWRQcml2YXRlS2V5IiwiX2JpZ2ludFRvMzJCeXRlcyIsIl9ub3JtYWxpemVQcml2YXRlS2V5IiwiaGFzaFRvUHJpdmF0ZUtleSIsIm1pbkxlbiIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tUHJpdmF0ZUtleSIsInByZWNvbXB1dGUiLCJjYWNoZWQiLCJzaGEyNTYiLCJtZXNzYWdlcyIsImJ1ZmZlciIsInN1YnRsZSIsImRpZ2VzdCIsImNyZWF0ZUhhc2giLCJmb3JFYWNoIiwidXBkYXRlIiwiY2tleSIsImltcG9ydEtleSIsImNyZWF0ZUhtYWMiLCJzaGEyNTZTeW5jIiwiaG1hY1NoYTI1NlN5bmMiLCJ0YWdQIiwidGFnSCIsImMiLCJjaGFyQ29kZUF0IiwiX0phY29iaWFuUG9pbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwidmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@noble/secp256k1/lib/esm/index.js\n");

/***/ })

};
;